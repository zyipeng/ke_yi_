<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python爬虫之csdn博客迁移]]></title>
    <url>%2F2019%2F05%2F17%2F90266014%2F</url>
    <content type="text"><![CDATA[目的：将csdn上的不是md格式的博客爬下来放到github上面去 实现流程1.爬到博客的总页数，获取每页的url2.爬到每一页的所包含的博客，将所有的博客url爬下来3.爬到每一篇博客的标题和内容4.爬到每一篇博客所含的图片下载下来5.将爬到的文章和图片打包保存 实现步骤爬虫的基本工作 首先访问url将url对应的页面存到字符串 然后到页面字符串里面寻找想要的东西 继续访问url，继续寻找，知道找到真正想要的为止 爬取博客的总页数，获取每一页的url 获取总页数，打开自己博客的首页，然后翻页发现传过来好多包，然后发现里面有一个js文件时用来设置翻页显示的。并且在html源码里面是没有翻页的源码的。（这些代码是js生成的）所以需要将js生成的代码一起获取。 获取每一页的url 获取html，我知道的有两种方式 通过requests包里面的requests.get(url).text获得页面代码 通过webdriver中的selenium包里面的driver=webdriver.PhantomJS(executable_path(‘[phantomjs.exe绝对路径]’)driver.get(url)访问url页面 ，通过driver.page_source获得页面代码 示例代码12345678910111213import requestsfrom selenium import webdriverurl=&quot;https://blog.csdn.net/ke_yi_/article/details/90080807&quot;res=requests.get(url).textdriver=webdriver.PhantomJS(executable_path=&apos;D:\\Program Files\\phantomjs-2.1.1-windows\\bin\\phantomjs.exe&apos;)driver.get(url)f1=open(&quot;date1.html&quot;,&quot;a&quot;,encoding=&quot;utf-8&quot;)f2=open(&quot;data2.html&quot;,&quot;a&quot;,encoding=&quot;utf-8&quot;)f1.write(res)f2.write(driver.page_source)f1.close()f2.close()print(&quot;yes&quot;) 获取每一页的博客url 遍历每一页，获取每一页的html页面，找到博客url的特征，写出正则表达式，得到每个博客的url放入列表。 爬到每一篇博客的标题和内容 -通过寻找标题和内容的特征，写出正则表达式，但是由于文章的标签是双标签前面左标签好判断，有标签就有点难寻找。因此我在这里是通过两次正则才得到整个博客正文。 下载每一篇博客所有的图片 下载图片需要得到图片的url，首先通过对得到的正文内容进行正则表达式查找所有图片的url，然后下载图片。由于图片需要显示，因此在保存正文之前需要将正文中的url改成本地的url，下载图片的时候可以有更加优化，因为两次都是需要查找url的位置，然后再进行操作，分开就会多需要一些时间。 图片下载的时候，csdn我的有两种图片标签格式，一种是png?或jpg？结束的，一种是gif”结束的，所以在编正则表达式需要注意。 下载图片 下载图片我是通过urlretrieve的urllib.request里面的urlretrieve(img_url,local_img_url)下载。 将图片和博客打包 图片的话可以用先建一个文件夹，然后将所有图片都放入。博客开始我是以博客标题作为文件名，但是博客标题中有很多特殊字符，所以最有我是存为md格式，将标题放在文件里面。（#其实最终我将博客放csdn上的时候，由于我的标题里面有冒号，导致出错。） 保存文件 123f=open(&quot;newfile.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;)f.write(&quot;filecontent&quot;)f.close() 遇到的错误最终效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[平衡查找树]]></title>
    <url>%2F2019%2F05%2F16%2F90080807%2F</url>
    <content type="text"><![CDATA[概念：是二叉查找树的一种优化，它规定查找树一直平衡，因此查找的时间会更加优化。基本操作：查找、插入、删除、遍历。其操作基本和查找树一样。但是有一些不同。因为需要保持查找树的平衡，所以每一次对元素的的添加和删除都需要对查找树进行维护，使其处于平衡状态。（平衡：每一个叶子节点的深度相差不能超过1）。维护的方式有单旋转和双旋转，单旋转分为左、右旋转，双旋转分为左右、右左旋转。旋转的目的是为了保持查找树的平衡。单旋转 左旋转：如果节点插入在N的左孩子的左子树左旋转：如果节点插入在N的右孩子的右子树中双旋转：由两次单旋转来实现，先是对节点N的孙子节点的旋转，然后是对节点N的新孩子的旋转。 右-左旋转：如果插入发生在N的有孩子的左子树中左-右旋转：如果插入发生在N左孩子的右子树中参考文献：《数据结构与算法分析java语言描述》（第二版）Frank M.Carrano著 金名 等译 清华大学出版社出版]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉查找树]]></title>
    <url>%2F2019%2F05%2F16%2F90079605%2F</url>
    <content type="text"><![CDATA[概念：一棵二叉树，其节点可以比较（含有Comparable对象），并按一下方式组织节点：1.节点中的数据大于节点左子树中的数据2.节点中的数据小于节点右子树中的数据主要操作：查找、插入、删除、遍历插入操作：首先寻找符合树的组织方式的父节点，然后插入其合适的位置。查找操作：为查找而设计，由于节点按照一定顺序，查找的时候比较节点大小，接着查找相应的子树。遍历操作：和一般的树的遍历操作一样，先、中、后序遍历。删除操作：删除容易破坏其组织方式，需分情况讨论。若是叶子节点的话，可以直接删除。 若是含有一个子树的节点的话，可以将自己删除，然后将其父节点指向字节的应用指向子树节点。 若是含有两个子树的节点的话，解决方案分为两种： 3.1在其左子树中找一个最大的节点并删除，然后用该节点的内容替换自己。 3.2在其右子树中找一个最小的节点并删除，然后用该节点的内容替换自己。 （由于，左子树中最大节点肯定没有右子树、右子树中最小节点肯定没有左子树，可以用前面的方法删除） 参考文献：《数据结构与算法分析java语言描述》（第二版）Frank M.Carrano著 金名 等译 清华大学出版社出版]]></content>
  </entry>
  <entry>
    <title><![CDATA[networkx笔记1]]></title>
    <url>%2F2019%2F05%2F16%2F89915383%2F</url>
    <content type="text"><![CDATA[# edges通过设置不同的边显示不同的效果nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)#首先将所有边全部设置nx.draw_networkx_edges(G, pos, edgelist=[(0, 1), (1, 2), (2, 3), (3, 0)], width=8, alpha=0.5, edge_color=’r’)#再设置一部分边nx.draw_networkx_edges(G, pos, edgelist=[(4, 5), (5, 6), (6, 7), (7, 4)], width=8, alpha=0.5, edge_color=’b’)#再设置另一部分边#设置边颜色的深浅nodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=’blue’)#获得边的对象列表edges = nx.draw_networkx_edges(G, pos, node_size=node_sizes, arrowstyle=’-&gt;’, arrowsize=10, edge_color=edge_colors, edge_cmap=plt.cm.Blues, width=2)# set alpha value for each edge设置每一条边的状态for i in range(M): edges[i].set_alpha(edge_alphas[i])pc = mpl.collections.PatchCollection(edges, cmap=plt.cm.Blues)#设置旁边比较条pc.set_array(edge_colors)plt.colorbar(pc)#找到需设置边列表的技巧elarge=[(u,v) for (u,v,d) in G.edges(data=True) if d[‘weight’] &gt;0.5]esmall=[(u,v) for (u,v,d) in G.edges(data=True) if d[‘weight’] &lt;=0.5]# edgesnx.draw_networkx_edges(G,pos,edgelist=elarge,width=6)nx.draw_networkx_edges(G,pos,edgelist=esmall,width=6,alpha=0.5,edge_color=’b’,style=’dashed’)# labelsnx.draw_networkx_labels(G,pos,font_size=20,font_family=’sans-serif’)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python基础和networkx笔记]]></title>
    <url>%2F2019%2F05%2F16%2F89915232%2F</url>
    <content type="text"><![CDATA[pip freeze #查看已经安装的模块pip install * #如果为已安装模块就会显示安装目录数学操作符 [指数]、%、//[整除]、/、、-、+漂亮打印字典pprint.pprint()pprint.pfromat()字符串里面的isX函数islower()、isupper（）、isalpha（）[只包含字母]、isalnum（）[只包含字母和数字]、isdecimal（）[只包含数字]、isspace（）[只包含空格、制表符、换行]、istitle（）[里面每一个单词都是大写字母开头其他都是小写字母] [所有这些都是非空]‘a’.join([‘cats’,’rats’,’bats’])‘cats,rats,bats’.split(‘,’)pyperclip.paste()、pyperclip.copy()#剪贴板操作‘ hello word ‘.strip()、.lstrip()、.rstrip()‘hello’.rjust(10)、.ljust(10)、.center(10)‘hello world!’.startswith(‘hello’)、endswith(‘world!’)正则表达式匹配1.用improt re导入正则表达式模块2.用re.complie()函数创建一个Regex对象（记得使用原始字符串）3.向Regex对象的search()方法传入想查找的字符串。返回Match对象4.调用Match对象的group()方法，返回实际匹配文本的字符串5.调用Match对象的findall()方法，返回所用实际匹配文本的字符串6.re.complie()函数第二个参数re.IGNORECASE[忽略大小写]、re.DOTALL [让句点包含换行]、re.VERBOSE[编写注释]符号1. ?匹配零次或一次前面的分组2. 匹配零次或多次前面的分组3. +匹配一次或多次前面的分组4. {n}匹配n次前面的分组5. {n,}匹配n次或更多前面的分组6. {,m}匹配零次到m次前面的分组7. {n,m}匹配至少n次、至多m次前面的分组8. {n,m}?或*？或+？对前面的分组进行非贪心匹配9. ^spam意味着字符串必须以spam开始10. spam$意味着字符串必须以spam结尾11. . 匹配所有字符，除换行符外12. \d、\w、\s 分别匹配 数字、单词、空格13. \D、\W、\S 分别匹配 除数字、单词、空格外的所有字符14. [abc] 匹配方括号内的任意字符15. [^abc] 匹配不在方括号内的任意字符文件操作基本操作os.path.join(‘usr’,’bin’,’spam’)os.getcwd()、os.chdir(‘C:\Windows\System32’)os.makedirs(‘C:\delicious\walnut\waffles’)os.path.abspath(‘.’)、os.path.isabs(‘.’)、os.path.relpath(porpusepath,startpath)os.path.dirname(path)、os.path.basename(path)、os.path.split(path)‘C:\Windows\System32\calc.exe’.split(os.path.sep)os.path.getsize(‘.\calc.exe’)、os.listdir(‘.’)os.path.exists(‘C:\Windows’)、os.path.isdir(‘C:\Windows’)、os.path.isfile(‘C:\Windows’)hellofile=open(‘C:\User\filename.txt’)#第二个参数w、a、r，返回一个File对象hellocontext=hellofile.read()hellocontext=hellofile.readlines()hellofile.write(‘hello world!\n’)shelve模块import shelveshelfFile=shelve.open(‘mydata’)cats=[‘Zophie’,’Pooka’]shelfFile[‘cats’]=catsshelfFile.close()shelfFile=shelve.open(‘mydata’)type(shelfFile)#检查数据是否正确存储shelfFile[‘cats’]list(shelfFile.keys())list(shelfFile.values())shelfFile.close()用pprint.pformat()函数保存变量import pprintcats=[{‘name’:’Zophie’,’desc’:’chubby’}]fileObj=open(‘myCats.py’,’w’)fileObj.write(‘cats=’+pprint.pformat(cats)+’\n’)fileObj.close()Networkx无向图import networkx an nx #导入包重名为nximport matplotlib.pyplot as plt G=nx.Graph() #建立空的无向图G.add_node(1) #添加节点1G.add_edge(2,3) #添加边2-3（隐含添加2、3节点）print(G.nodes()) #输入全部节点print(G.edges()) #输出全部边print(G.number_of_edges()) #输出边数pos=nx.spectral_layout(G) #定义一个布局nx.draw(G,pos,with_labels=False,node_size=30)#绘制#with_labels决定节点带不带标签，node_size决定节点直径plt.show() #显示图形操作excel文件improt openpyxl #导入openpyxl模块wb=openpyxl.load_workbook(‘example.xlsx’)#打开一个excel文件wb.get_sheet_names() #获得工作簿中所有的表名的列表sheet=wb.get_sheet_by_name(‘Sheet3’)#获得工作表Sheet3的Worksheet对象sheet.title #返回工作表的名字anotherSheet=wb.get_active_sheet() #获得打开工作簿出现的工作表a1=sheet[‘A1’] #表示该工作表的一个单元格a1.value #单元格内保存的值print(‘Cell ‘+str(a.coordinate)+’, Row ‘+str(a1.row)+’,Column ‘+a1.lumn+’ is ‘+a1.value)#’Cell A1, Row 1, Column A is Apples’for i in range(1,8,2): print(i,sheet.cell(row=i,column=2).value)sheet.max_row #获取最大行sheet.max_colum #获取最大列from openpyxl.utils import get_column_letter,column_index_from_string#引入函数get_column_letter(1) #将数字装还成excel列的形式column_index_from_string(‘AA’) #将列的形式转换成数字（不区分大小写）#从列表中取得行和列#一行一行显示for rowOfCellObjects in sheet[‘A1’:’C3’]: for cellobj in rowOfCellObjects: print(cellObj.coordinate,cellObj.value)#输出一行for cellObj in sheet.row[1]: print(cellObj.value)#输出一列for cellObj in sheet.columns[1]: print(cellObj.value)NumPyndarray数组数组创建函数：array： array([数据、列表、元组、数组和其他序列类型])#数据类型指定或自动、默认直接复制输入数据asarray: #如果输入不是ndarray就复制arange： #类似内置rangeones、ones_like: #创建一个全1adarray数组，ones(2,3)、ones_like([[1,2,3],[2,3,4]])zeros、zeros_like:#创建全0数组empty、empty_like:#创建空值数组eye、identity： #创建N x N单位矩阵（对角线全1，其它为0）NumPy的数据类型：intN、floatN、complexN、bool、object[Python对象类型]、string_[例如要创建一个长度为10的字符串、应使用S10]、unicode_例：arr=np.array([1,2,3]),dtype=np.float64)arr.dtype #显示类型arr1=arr.astype(np.int64) #显式类型转换未完成。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[R语言基础语法]]></title>
    <url>%2F2019%2F05%2F16%2F89915128%2F</url>
    <content type="text"><![CDATA[一、基础操作函数source(‘~/.active-rstudio-document’)#列出workspace中所有对象ls()#删除某个变量rm（）#查看R保存文件的目录getwd()#保存文件save（yourname，file=’yourname.rda’）#提取保存的工作结果load（’yourname.rda’)#安装扩展包install.packages(‘fortunes’)#载入扩展包library(fortunes)#卸载扩展包detach(package:fortunes)#查看帮助？……二、基本数学函数1、基本算符+、-、*、/、^、%%[取模]、%/%[取整]、complex()[复数]、1.33e4[科学计算]2、基本数学函数abs（）、log(x,base=y)[y为底，x的对数，y默认为e]、exp(x)[x的自然指数]、sqrt(x)、factorial(x)[x的阶乘]、choose(x,y)[x个数选y个数的组合数]；近似函数：round(123.123,digits=4)、round(4.5)、signif(123.123,4)[保留有效数]、floor(x)[最近整数]、trunc(x)[截取整数]；三角函数：sin()、cos()、tan()Inf[无穷大]、NaN[无定义]、NA[缺失值]值检测：is.finite()[是否有限]、is.infinite()、is.nan()、is.na()；未完成。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2019%2F05%2F16%2F89741142%2F</url>
    <content type="text"><![CDATA[基数排序思想：先将序列按照个位装入十个组，然后从0到9将各组内数拿出来，按照十位装入是个组，最后以同样的方式按照百位装入，完成操作之后就已经排好序了。排序图解：排序代码：代码设计：首先将判断所有数字都是多少位，必须将高位为空补零，存为字符串，或者直接通过整数位数求余取整获得数据。然后使用循环从个位到最高位遍历所有数，分组。设置分组，每一个分组必须是一个动态数组。每一次取数，需要按照上一次装入的组从0组开始，取出一个数就装到对应的本次分组的组。取出的时候，每取空一个组就需要到下一个组取数，因此取数的时候要判断边界。如果减少代码的复杂度可以每次将组里面的数取出装入原来的数组，再做和第一次取数一样的循环。时间复杂度：O(dn)可以简单的看成是O(n)空间复杂度：动态数组的话空间会少一点，需要2n，如果是十个数组的话，就需要11n。]]></content>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F05%2F16%2F89737217%2F</url>
    <content type="text"><![CDATA[与前面归并排序不同的另一种分治策略—-快速排序与归并排序不同的是：快排不要求分成相等的两半、归并主要是合并，快排主要是划分、归并有一个辅助数组，快排不要。java类库中的快排：java.until中的Arrays使用快排对基本类型的数组按升序排序。方法:public static void sort(type[] a);public static void sort(type[] a,int first,int last); 快速排序的思想：先在序列中找到一个支点，使支点左边元素小于等于支点元素，右边元素大于等于支点元素（称为划分）。然后再对左右两部分执行同样的划分。创建划分步骤：在选定支点之后，将它与最后一个元素相交换，使得再创建划分时支点不成为障碍。从第一个元素开始向后寻找第一个大于或等于支点的节点1，再从倒数第二个元素开始向前寻找第一个小于或等于支点的节点2，如果节点1小于节点2则交换节点1、2。继续做这样的寻找交换，直到最后一次完成，将最后一次不小于支点的元素与支点交换，划分完成。快速排序图解：（图解1，使用的是选取第一个元素为支点） 支点的选择：最好的情况，支点就是序列的中值，致使划分后两部分近似相等。完全达到这种情况时浪费时间的，近似达到的方法是三者取中值支点法将数组中第一个元素和中间一个元素以及最后一个元素的中值作为支点（先排序三个元素，取第二个就是）。调整划分算法：三者取中值法处理之后，第一个元素和最后一个元素，分别小于大于支点元素，因此不要对其执行划分，划分算法中先将中间元素与last-1处元素交换，从左右开始查找的步骤只需要分别从first+1、last-2处进行。因为有第一个元素小于支点，最后一个元素大于支点的限制，再寻找的过程中没有必要考虑数组越界的界限。快速排序源代码：public class Quick_Sort { static int MIN_SIZE=3;//由于快排判断考虑的是多余三个元素的序列，必须大于等于3 private static&lt;T extends Comparable&lt;?super T&gt;&gt; void sortFirstMiddleLast(T[] a,int first,int mid,int last){ order(a,first,mid); order(a,mid,last); order(a,first,mid); } private static&lt;T extends Comparable&lt;?super T&gt;&gt; void order(T[] a,int i,int j){ if(a[i].compareTo(a[j])&gt;0){ swap(a,i,j); } } private static void swap(Object[] array,int i,int j){ Object temp=array[i]; array[i]=array[j]; array[j]=temp; } private static&lt;T extends Comparable&lt;?super T&gt;&gt; int partition(T[] a,int first,int last){ int mid=(first+last)/2; sortFirstMiddleLast(a,first,mid,last); swap(a,mid,last-1); int pivotIndex=last-1; T pivot=a[pivotIndex]; int indexFromLeft=first+1; int indexFromRight=last-2; boolean done=false; while(!done){ while(a[indexFromLeft].compareTo(pivot)&lt;0){ indexFromLeft++; } while(a[indexFromRight].compareTo(pivot)&gt;0){ indexFromRight–; } assert a[indexFromLeft].compareTo(pivot)&gt;=0&amp;&amp;a[indexFromRight].compareTo(pivot)&lt;=0; if(indexFromLeft&lt;indexFromRight){ swap(a,indexFromLeft,indexFromRight); indexFromLeft++; indexFromRight–; }else{ done=true; } } swap(a,pivotIndex,indexFromLeft); pivotIndex=indexFromLeft; return pivotIndex; } public static&lt;T extends Comparable&lt;?super T&gt;&gt; void quickSort(T[] a,int first,int last){ if(last-first+1&lt;MIN_SIZE){//此时执行插入排序 Insert_Sort.insertionSort(a,first,last); }else{//此时执行快速排序 int pivotIndex=partition(a,first,last); quickSort(a,first,pivotIndex-1); quickSort(a,pivotIndex+1,last); } }}时间复杂度：O(n*lgn)最坏是n^2空间复杂度：O(n)]]></content>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2019%2F05%2F16%2F89716142%2F</url>
    <content type="text"><![CDATA[归并排序思想：将一个序列分成两半然后对两半分别排序，再将他们归并为一个有序序列。归并排序图解： 归并排序的代码：(迭代版本代码由于写的急，没来的急优化，所以可读性不是很好）//递归版本归并排序public class Recursion_MergeSort { public static &lt;T extends Comparable&lt;? super T&gt;&gt; void merge_Sort(T[] a,int first,int last){ T[] tempArray=(T[])new Comparable&lt;?&gt;[a.length]; mergeSort(a,tempArray,first,last); } public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] a,T[] tempArray,int first,int last){ if(first&lt;last){ int mid=(first+last)/2; mergeSort(a,tempArray,first,mid); mergeSort(a,tempArray,mid+1,last); int i=first,j=first,k=mid+1; while(j&lt;=mid&amp;&amp;k&lt;=last){ if(a[j].compareTo(a[k])&gt;0){ tempArray[i++]=a[k++]; }else{ tempArray[i++]=a[j++]; } } while(i&lt;=last&amp;&amp;j&lt;=mid){ tempArray[i++]=a[j++]; } while(i&lt;=last&amp;&amp;k&lt;=last){ tempArray[i++]=a[k++]; } for(i=0;i&lt;=last;i++){ a[i]=tempArray[i]; } } }}//迭代版本递归排序public class Interation_MergeSort { /* By ke_yi_ @param a / public static &lt;T extends Comparable&lt;? super T&gt;&gt; void merge_Sort(T[] a){ int i,j; T[] tempArray=(T[]) new Comparable&lt;?&gt;[a.length]; for(i=2;i&lt;a.length;i=i&lt;&lt;1){ for(j=0;ji&lt;a.length;j++){ mergeSort(a,tempArray,ij,i(j+1)); } } mergeSort(a,tempArray,0,i); } public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] a, T[] tempArray, int first, int last) { int i=first,j=first,mid=(first+last)/2; int k=mid; mid=mid&gt;a.length?a.length:mid; last=last&gt;a.length?a.length:last; while(j&lt;mid&amp;&amp;k&lt;last){ if(a[j].compareTo(a[k])&gt;0){ tempArray[i++]=a[k++]; }else{ tempArray[i++]=a[j++]; } } while(j&lt;mid){ tempArray[i++]=a[j++]; } while(k&lt;last){ tempArray[i++]=a[k++]; } for(i=first;i&lt;last;i++){ a[i]=tempArray[i]; } }}时间复杂度：O(nlgn)最好、最坏、平均都是空间复杂度：O(n)需要使用2n的空间]]></content>
  </entry>
  <entry>
    <title><![CDATA[软考中级之软件设计师心得]]></title>
    <url>%2F2019%2F05%2F16%2F89637815%2F</url>
    <content type="text"><![CDATA[软件设计师考试差不多过去半年了，证书是前不久下来的，记录一下心得，讲讲我当时的一些疑惑。首先说说为什么报吧，和大多人一样，我报软考纯粹抱着试一试的态度，因为看到有几个认识的学长报了，然后感觉自己大学什么东西也没有就去考个证来证明一下自己大学是没有和其他人一样在寝室打游戏。然后当时报之前 我是对软考的性质进行了一下了解，比如软考是怎样考啊，软考有什么科目，软考有用吗等等。这些资料是需要在报考前搜集好的，我是这么做的。主要途径就是百度，还有软考官网，如果有学长可以指导那就更好咯。软考，分为低级、中级、高级。低级和中级是只有上午和下午两场笔试，高级还加一个论文，具体可以去软考官网了解。软考官网还可以查到报考点和考点。对于软考有用吗？其实当时我也是查了，但是所有类似这样的问题，有用吗，难吗等都是没有标准答案的，只有靠自己去了解。我当时就是在百度文库下了一些真题了解了它的难度，然后还找了考纲，了解它大概考什么。报名之后，我基本上是用空余时间看教程，视频，真题。视频我是在逼站上找的，直接搜索软件设计师就有很多。真题我是在百度文库和希赛，然后还有一个专门做题的软件，也是在网上找的，但是好像软件商城没有。说说考试内容的一些心得吧！其实考试的题目涵盖的范围是有点多的，但是题目百分之八九十都是挺简单的，上午的选择题基本上都不难，但是会考一些你可能没有见过的题目，不过也没事因为占比不大，我当时是有六七个题目是自己没有见过的，然后后面的英文题目我也是没有把握的，但是考试75分，题目1分一个，减去20个题目题目都还有55分。下午的题目也是不难的，但是需要一些做题的技巧。前面两个题目是软件工程和数据库那一块的题目，开始我做的时候也确实摸不着头脑。但是我想了一下，这么大的一个项目怎么可能要你一场考试就给思考清楚，肯定是不要弄懂也能做出来的不。虽然这么说，但是也不能完全依靠技巧，因为毕竟是考证书，学也是挺重要的不。后面的程序题，也是有技巧的，但是我当时没有去网上找这方面的技巧，因为毕竟自己也是一个acmer。然而我当时考试的时候有一个算法我确实是没有看懂，但是我感觉我是做出来了的。因为上下文确实能看出一些规律技巧，只要自己仔细。考完之后，一直到成绩出来那段时间都还是没底的，因为上午那几个没有见过的题目确实给我下了一跳，然后下午那个程序题着实给了我一记重锤。开始那几天我是这样想的：唉！时间还是应该多花点在上午点选择题的知识点上。唉！还是应该多花点时间做题目的。唉！还是应该多学点英语的。；到成绩出来我们学校去报的有70%拿到了证书，其实我有点不太理解，可能我底子确实要好一点。所以之后别人问我难吗？我基本上是说，内容确实有点广，但是难不难我确实没法告诉你，你可以去做一套真题试试。现在已经过去有一点时间了，对于软考吧，确实学到了很多，思维也是上升了很多。并且现在大三（计算机科学与技术专业）上的一些课基本上讲也只讲到我掌握的那个程度。软件设计师，主要还是在于软件如何设计？软件设计要注意哪些内容？软件设计需要哪些？；从上面三个问题来看，其实隐约的锻炼了个人的设计能力，虽然我现在主要还是一个人写代码，但是我写代码的时候看到了不一样的东西。这个是我当时学习过程中搜集的资料]]></content>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2019%2F05%2F16%2F89636370%2F</url>
    <content type="text"><![CDATA[希尔排序思想：插入排序的一种变体。由于插入排序对于特别乱的序列排序会很糟。而它就是先将序列变成接近有序的序列。排序步骤：举例：10、16、11、4、15、3、9、6、1、17、8、12、7（1）分组：将上面序列分为6组，按照每一组按照相隔多少取一个数，比如第一组取0号、6号、12号。如下： （2）分组排序：对每一组进行插入排序，得到数组的状态为7、1、4、8、3、9、16、11、17、15、12、10；如下：（3）缩小分格距离（一般缩小为上一次分组的一般），继续分组，排序，知道分组距离为1。 排序图解： 希尔排序代码： public class Sheel_Sort { //对a序列中的第first组进行排序， //这个组是从first元素开始间距为 //space的位置的所有元素 private static &lt;T extends Comparable&lt;? super T&gt;&gt; void incrementalInsertionSort(T[] a,int first,int last,int space){ int unsorted,i; for(unsorted=first+space;unsorted&lt;=last;unsorted=unsorted+space){ T firstUnsorted=a[unsorted]; for(i=unsorted-space;(i&gt;=first)&amp;&amp;(firstUnsorted.compareTo(a[i])&lt;0);i=i-space){ a[i+space]=a[i]; } a[i+space]=firstUnsorted; } } public static&lt;T extends Comparable&lt;? super T&gt;&gt; void shellSort(T[] a,int first,int last){ int n=last-first+1; for(int space=n/2;space&gt;0;space=space/2){ for(int begin=first;begin&lt;first+space;begin++){ incrementalInsertionSort(a, begin, last, space); } } } public static void main(String[] args) { Integer[] a={9,8,7,6,5,4,3,2,1}; Sheel_Sort.shellSort(a, 0, 8); for(Integer i:a){ System.out.println(i); } }}时间复杂度：O(n^1.5) 平均情况是这样，最坏情况还是n^2，如果当space为偶数时进行优化的话，可以实现搜友都是n^2空间复杂度：O(n)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven war解读]]></title>
    <url>%2F2019%2F05%2F16%2F89567277%2F</url>
    <content type="text"><![CDATA[maven是干嘛的：maven其实是一个项目构建和管理的工具，主要就是提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。是可以方便的编译代码、进行依赖管理、管理二进制库等的。maven war项目中的pom.xml文件：描述了maven项目的基本信息，比如groupId，artifactId，version等。也可以对maven项目的远程仓库，打包形式，资源依赖关系等进行配置。一个最简单的pom.xml文件至少需要包含四个元素：modelVersion, groupId, artiffactId和version。创建Maven war项目：new-&gt;project-&gt;maven project-&gt;(勾选create a simple project)-&gt;Group Id和Artifact Id是为了保证项目唯一性而提出的；Group Id：可以简单理解为项目开发团队的统一标识，一般分为多个段；实际开发中一般使用两段，第一段代表域，类似org，com，cn等；第二段代表公司名称或者团队名称；ArtifactId：可以简单理解为实际的项目名称；在实际的开发过程中，创建包时包名最好以Group Id+Artifact Id开头；例如，在一个项目中设置了Group Id为com.zyipeng，Artifact Id为test，则Service层的包，完整的包名应该为com.zyipeng.test.service。Maven war项目的web.xml文件中servlet标签内容：重定向类：表示根据servlet-name定向到具体的java servlet类调用service方法，实现请求的操作和响应重定向路径：表示访问相应的路径就可以调用配置的重定向类。 Maven war项目文件的架构简单简绍：]]></content>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2019%2F05%2F16%2F89511579%2F</url>
    <content type="text"><![CDATA[插入排序思想：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据；插入排序图解：插入排序代码：//迭代版本public class Interation_InsertSort { public static&lt;T extends Comparable&lt;? super T&gt;&gt; void I_insertionSort(T[] a,int first,int last){ T firstUnsorted=null; for(int unsorted=first+1;unsorted&lt;last;unsorted++){ firstUnsorted=a[unsorted]; insertInOrder(firstUnsorted,a,first,unsorted-1); } } private static&lt;T extends Comparable&lt;? super T&gt;&gt; void insertInOrder(T element,T[] a,int begin,int end){ int index=end; while((index&gt;=begin)&amp;&amp;(element.compareTo(a[index])&lt;0)){ a[index+1]=a[index]; index–; } a[index+1]=element; }} //递归版本public class Recursion_InsertSort { private static&lt;T extends Comparable&lt;? super T&gt;&gt; void R_insertionSort(T[] a,int first,int last){ if(first&lt;last){ R_insertionSort(a,first,last-1); insertInOrder(a[last],a,first,last-1); } } private static&lt;T extends Comparable&lt;? super T&gt;&gt; void insertInOrder(T element,T[] a,int begin,int end){ if(!(element.compareTo(a[end])&lt;0)){ a[end+1]=element; }else if(begin&lt;end){ a[end+1]=a[end]; insertInOrder(element, a, begin, end-1); }else{ a[end+1]=a[end]; a[end]=element; } }}时间复杂度：O(n^2)空间复杂度：n]]></content>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2019%2F05%2F16%2F89480670%2F</url>
    <content type="text"><![CDATA[选择排序思想：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。选择排序图解：选择排序代码（java）：package sort;public class SelectSort { public static&lt;T extends Comparable&lt;? super T&gt;&gt; void sort(T[] a,int n){ for(int i=0;i&lt;n-1;i++){ int indexOfSmall=getIndexOfSmallest(a,i,n-1); swap(a,i,indexOfSmall); } } private static&lt;T extends Comparable&lt;? super T&gt;&gt; int getIndexOfSmallest(T[] a,int left,int right){ T min=a[left]; int MinIndex=left; for(int i=left+1;i&lt;=right;i++){ if(a[i].compareTo(min)&lt;0){ min=a[i]; MinIndex=i; } } return MinIndex; } private static void swap(Object[] a,int i,int j){ Object temp=a[i]; a[i]=a[j]; a[j]=temp; }}时间复杂度：O(n^2)空间复杂度：O(n)]]></content>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯-审美课（二进制，加打表时间优化）]]></title>
    <url>%2F2019%2F05%2F16%2F88696980%2F</url>
    <content type="text"><![CDATA[此题使用二进制取反简化判断，使用打表方法达到时间复杂度的优化，然后计算所有反下标标记的元素值的和就得到了答案的两倍。 算法训练 审美课 时间限制：1.0s 内存限制：256.0MB问题描述 《审美的历程》课上有n位学生，帅老师展示了m幅画，其中有些是梵高的作品，另外的都出自五岁小朋友之手。老师请同学们分辨哪些画的作者是梵高，但是老师自己并没有答案，因为这些画看上去都像是小朋友画的……老师只想知道，有多少对同学给出的答案完全相反，这样他就可以用这个数据去揭穿披着皇帝新衣的抽象艺术了（支持帅老师^_^）。 答案完全相反是指对每一幅画的判断都相反。输入格式 第一行两个数n和m，表示学生数和图画数； 接下来是一个n*m的01矩阵A： 如果aij=0，表示学生i觉得第j幅画是小朋友画的； 如果aij=1，表示学生i觉得第j幅画是梵高画的。输出格式 输出一个数ans：表示有多少对同学的答案完全相反。样例输入3 21 00 11 0样例输出2样例说明 同学1和同学2的答案完全相反； 同学2和同学3的答案完全相反； 所以答案是2。数据规模和约定 对于50%的数据：n&lt;=1000； 对于80%的数据：n&lt;=10000； 对于100%的数据：n&lt;=50000，m&lt;=20。 时间是1s，数据规模也不小，空间256。眼瞎，明显是一道空间换时间的题目了。首先暴力做法（没过）直接两个循环输入，三个循环判断。然后加入二进制抑或运算，一直想加入先计算相同元素的个数然后再计算相反对数，但是没有。两个循环输入，两个循环计算结果，时间复杂度似乎要少很多，但是没过。#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int d[50000];int main(){ int n,m,t; while(cin&gt;&gt;n&gt;&gt;m){ for(int i=0;i&lt;n;i++){ cin&gt;&gt;t; d[i]=t; for(int j=1;j&lt;m;j++){ cin&gt;&gt;t; d[i]&lt;&lt;=1; d[i]+=t; } } int res=0; for(int i=0;i&lt;n;i++){ for(int j=i+1;j&lt;n;j++){ if((d[i]^d[j])==((1&lt;&lt;m)-1)){ res++; } } } cout&lt;&lt;res&lt;&lt;endl; } return 0;}最后，正确答案，用大表法将相同元素放一块，然后通过与(1&lt;&lt;m)-1相抑或取反得到想法的打表数组下标。#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int d[50000];int su[1048578];int main(){ int n,m,t; while(cin&gt;&gt;n&gt;&gt;m){ memset(su,0,sizeof(su)); for(int i=0;i&lt;n;i++){ cin&gt;&gt;t; d[i]=t; for(int j=1;j&lt;m;j++){ cin&gt;&gt;t; d[i]&lt;&lt;=1; d[i]+=t; } su[d[i]]++; } int res=0; int temp=(1&lt;&lt;m)-1; for(int i=0;i&lt;n;i++){ int tem=d[i]^temp; res+=su[tem]; } cout&lt;&lt;res/2&lt;&lt;endl; } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql的like模糊查找常用标识符]]></title>
    <url>%2F2019%2F05%2F16%2F88557420%2F</url>
    <content type="text"><![CDATA[下面列举常用的几种标识含义；1:% 表示零个或多个字符的任意字符串： 1. LIKE’Mi%’ 将搜索以字母 Mi开头的所有字符串（如 Michael）。 2. LIKE’%er’ 将搜索以字母 er 结尾的所有字符串（如 Worker、Reader）。 3. LIKE’%en%’ 将搜索在任何位置包含字母 en 的所有字符串（如 When、Green）。2:_（下划线）表示任何单个字符： 1. LIKE’_heryl’ 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。3：[ ] 表示指定范围 ([a-f]) 或集合 ([abcdef]) 中的任何单个字符： LIKE’[CK]ars[eo]n’ 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。LIKE’[M-Z]inger’ 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。D：[^] 不属于指定范围 ([a-f]) 或集合 ([abcdef]) 的任何单个字符： 1. LIKE’M[^c]%’ 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。4： 它同于DOS命令中的通配符，代表多个字符： 1. cc代表cc,cBc,cbc,cabdfec等多个字符。5：？同于DOS命令中的？通配符，代表单个字符 : 1. b?b代表brb,bFb等。6：# 大致同上，不同的是代只能代表单个数字。 1. k#k代表k1k,k8k,k0k 。7：[!] 排除 它只代表单个字符。举例：例1，查询name字段中包含有“明”字的。select from table1 where name like ‘%明%’例2，查询name字段中以“李”字开头。select from table1 where name like ‘李‘例3，查询name字段中含有数字的。select from table1 where name like ‘%[0-9]%’例4，查询name字段中含有小写字母的。select from table1 where name like ‘%[a-z]%’例5，查询name字段中不含有数字的。select from table1 where name like ‘%[!0-9]%’以上例子能列出什么值来显而易见。但在这里，我们着重要说明的是通配符“”与“%”的区别。很多朋友会问，为什么我在以上查询时有个别的表示所有字符的时候用”%”而不用“”？先看看下面的例子能分别出现什么结果：select from table1 where name like ‘明‘select from table1 where name like ‘%明%’大家会看到，前一条语句列出来的是所有的记录，而后一条记录列出来的是name字段中含有“明”的记录，所以说，当我们作字符型字段包含一个子串的查询时最好采用“%”而不用“”,用“”的时候只在开头或者只在结尾时，而不能两端全由“*”代替任意字符的情况下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql引擎]]></title>
    <url>%2F2019%2F05%2F16%2F88554213%2F</url>
    <content type="text"><![CDATA[创建表时指定表的引擎和字符集create table t1(id int) engine=myisam/innodb charset=utf8/gbk;引擎：引擎是用来将查询语句转化为对数据库的操作。比如你输入SQL的数据库查询语句，那它的引擎，就将SQL语句转化为对数据库的操作在数据库中查寻某项，它是实现了对用户的一个接口。不同的语言用不同的引擎 。如：JAVA 的JDBC（Java Database Connectivity），ODBC，JET等… …数据库的引擎：数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。通俗的解释：比如web开发一般喜欢用myisam，因为myisam具有快速读取操作。而InnoDB就有灵活的特性，因此可以使用它来早就灵活性技术的MYSQL+API等等。所以数据库的引擎通俗的讲就像我们的发动机，汽车用大的发动机，摩托车用小的各取所长。MyISAM适合：（1）做很多count 的计算；（2）插入不频繁，查询非常频繁；（3）没有事务。InnoDB适合：（1）可靠性要求比较高，或者要求事务；（2）表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定数据引擎的创建数据库的引擎包括：MySQL数据库引擎取决于MySQL在安装的时候是如何被编译的。要添加一个新的引擎，就必须重新编译MYSQL。在缺省情况下，MYSQL支持三个引擎：ISAM、MYISAM和HEAP。另外两种类型INNODB和BERKLEY（BDB），也常常可以使用。如果技术高超，还可以使用MySQL+API自己做一个引擎。引擎查用sql语句：1.查看表的引擎：show create table t;2.修改表的引擎：alter table t engine=innodb;3.查看可以提供哪些引擎：show engines;4.查看当前默认的存储引擎：show variables like ‘%storage_engine%’; 各个引擎介绍：ISAM：ISAM是一个定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到 数据库被查询的次数要远大于更新的次数。因此，ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM的两个主要不足之处在于，它不 支持事务处理，也不能够容错：如果你的硬盘崩溃了，那么数据文件就无法恢复了。如果你正在把ISAM用在关键任务应用程序里，那就必须经常备份你所有的实 时数据，通过其复制特性，MYSQL能够支持这样的备份应用程序。MyISAM：MyISAM是MySQL的ISAM扩展格式和缺省的数据库引擎。除了提供ISAM里所没有的索引和字段管理的大量功能，MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMCHK工具和用来恢复浪费空间的 MyISAMPACK工具。MYISAM强调了快速读取操作，这可能就是为什么MySQL受到了WEB开发如此青睐的主要原因：在WEB开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和INTERNET平台提供商只允许使用MYISAM格式。MyISAM格式的一个重要缺陷就是不能在表损坏后恢复数据。HEAP：HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。在数据行被删除的时候，HEAP也不会浪费大量的空间。HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格。InnoDB：InnoDB数据库引擎都是造就MySQL灵活性的技术的直接产品，这项技术就是MYSQL+API。在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MyISAM数据库引擎不支持事务处理（transaction process）也不支持外来键。尽管要比ISAM和 MyISAM引擎慢很多，但是InnoDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。如前所述，如果你的设计需要这些特性中的一者 或者两者，那你就要被迫使用后两个引擎中的一个了。如果感觉自己的确技术高超，你还能够使用MySQL+API来创建自己的数据库引擎。这个API为你提供了操作字段、记录、表格、数据库、连接、安全帐号的功能，以及建立诸如MySQL这样DBMS所需要的所有其他无数功能。深入讲解API已经超出了本文的范围，但是你需要了解MySQL+API的存在及其可交换引擎背后的技术，这一点是很重要的。估计这个插件式数据库引擎的模型甚至能够被用来为MySQL创建本地的XML提供器（XML provider）。（任何读到本文的MySQL+API开发人员可以把这一点当作是个要求。）MyISAM与InnoDB的区别（收集于网上）InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。以下是一些细节和具体实现的差别：1.InnoDB不支持FULLTEXT类型的索引。2.InnoDB 中不保存表的具体行数，也就是说，执行select count（） fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count（）语句包含where条件时，两种表的操作是一样的。3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。5.LOAD TABLE FROMMASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如updatetable set num=1 where name like “a%”两种类型最主要的差别就是Innodb支持事务处理与外键和行级锁。而MyISAM不支持。所以MyISAM往往就容易被人认为只适合在小项目中使用。我作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，但是从我目前运维的数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是我的首选。原因如下：1、首先我目前平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。3、从平台角度来说，经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为我平台上最小的一个数据库实例的数据量基本都是几十G大小。4、从我接触的应用逻辑来说，select count（） 和order by是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD，MYI的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，虽然MyISAM可能会逊色Innodb，但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些selectcount（*）操作，非常适合大项目总量约几亿的rows某一类型（如日志，调查统计）的业务表。当然Innodb也不是绝对不用，用事务的项目如模拟炒股项目，我就是用Innodb的，活跃用户20多万时候，也是很轻松应付了，因此我个人也是很喜欢Innodb的，只是如果从数据库平台应用出发，我还是会首MyISAM。另外，可能有人会说你MyISAM无法抗太多写操作，但是我可以通过架构来弥补，说个我现有用的数据库平台容量：主从数据总量在几百T以上，每天十多亿pv的动态页面，还有几个大项目是通过数据接口方式调用未算进pv总数，（其中包括一个大项目因为初期memcached没部署，导致单台数据库每天处理9千万的查询）。而我的整体数据库服务器平均负载都在0.5-1左右。]]></content>
  </entry>
  <entry>
    <title><![CDATA[每次打开mysql服务不要像上一篇文章那样复杂，将bin加到path]]></title>
    <url>%2F2019%2F05%2F16%2F88383404%2F</url>
    <content type="text"><![CDATA[找到自己的mysql安装目录，将bin目录路径复制例如我的然后右键我的电脑—-&gt;点击属性—-&gt;点击高级 系统设置—-&gt;点击环境变量 编辑系统变量的path,粘贴自己的bin路径，保存 以后打开服务就只要管理员身份运行cmd，然后mysqld install。或者其他的一些与mysql相关的命令也直接输入就好了，不要再cd到目录了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[打开mysqld服务]]></title>
    <url>%2F2019%2F05%2F16%2F88383239%2F</url>
    <content type="text"><![CDATA[首先找到你mysql的安装目录（例如我的） 然后将路径复制，例如我的（D:\Program Files\MySQL\MySQL Server 5.5\bin）（没有加到path的方法）然后右键cmd管理员身份运行，首先cd到bin目录下（例如我的，因为我的是在d盘符下所以我首先切换到d盘符，然后我再，cd +bin路径）然后再运行mysqld install命令(例如我的）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python3.7.2卸载不了和正确卸载方式]]></title>
    <url>%2F2019%2F05%2F16%2F88183474%2F</url>
    <content type="text"><![CDATA[python3.7.2卸载顺序错了，然后导致卸载不完全，不能再此安装程序打开控制面板—-&gt;点开卸载程序—-&gt;找到python3.7.2右键选择更改—-&gt;点击修复 等待修复完成再回到控制面板的卸载程序页面，右键python3.7.2，点击卸载。不要卸载其他有python英文的程序，卸载其他就卸载不了python3.7.2了，或者在系统里面有很多卸载不干净的文件，电脑管家都卸载不了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[myeclipse激活工具闪退问题]]></title>
    <url>%2F2019%2F05%2F16%2F88084683%2F</url>
    <content type="text"><![CDATA[安装激活教程注：安装myeclipse会自动安装java。激活工具闪退，是由于没有运行的java环境，只要把java的bin文件夹加入环境变量，再重新激活就好了。不知道java安装目录的查找方法：首先：windows—-&gt;preferences然后：java—-&gt;installed JREs最后：打开箭头所示的路径，进入bin文件夹，将路径加入环境变量]]></content>
  </entry>
  <entry>
    <title><![CDATA[office安装教程]]></title>
    <url>%2F2019%2F05%2F16%2F88082481%2F</url>
    <content type="text"><![CDATA[1.去官网下载office 的ios镜像2.下载官网下载office部署工具3.将ios镜像装载4.运行部署工具 文件内容修改教程： 左边修改到右边 id表示的内容具体解释 修改文件名为config（随便一个短的就行）5.运行cmd，cd到文件所在的文件夹（桌面）输入命令setup.exe /configure config.xml 等待一下就安装完成了]]></content>
  </entry>
  <entry>
    <title><![CDATA[txt文件在widnows下确确实实是一行字符串，但它实实在在是多行字符串构成]]></title>
    <url>%2F2019%2F05%2F16%2F86562783%2F</url>
    <content type="text"><![CDATA[最近在学习python，在使用作者的实例数据的时候，用widnows下的nodepad打开看到的是完整的一行数据但是用python读取文件的时候却读出了多个字符串我使用notepad++打开以后显示的和理论上的是一样的，多行其实因为windows使用的换行是\n而linux系统下是\r，所以那个txt文件里面的换行就是\r，但是nodepad也没有将转义字符\r显示出来，我猜测可能是这样的：\r在windows里面有另外的转义的含义，也有可能nodepad默认将\r这个转义字符忽略]]></content>
  </entry>
  <entry>
    <title><![CDATA[安装networkx体验（win10+python37)]]></title>
    <url>%2F2019%2F05%2F16%2F86532618%2F</url>
    <content type="text"><![CDATA[开始百度了一下安装方式，需要下载networkx、pywin32、numpy、matplotlib一些软件。根据百度的提示，手动下载，手动安装，完全没有成功，也不排除问题在我。安装失败然后我通过pip下载，下载最新的python，使用自带pip，pip在python安装文件夹的scripts文件夹下面，将路径加入path（这样就不要在pip所在文件夹下运行pip命令），通过pip install （前面四个需要安装的模块都是可以这样安装的）。#安装下载的whl文件也是可以用pip的，pip install （文件路径+文件全名），其实我也是因为看到whl文件可以用pip安装才想到用它去安装那些的 / xyx安装成功后就可以开始调用这些东西了，去调用试试。，不行再回来接着写下面是安装的全部过程，中间因为网速问题有几次中断【当时使用的是管理院权限下的dos，因为我将python安装在敏感的地方，需要管理员权限才能更改】Microsoft Windows [版本 10.0.17134.523](c) 2018 Microsoft Corporation。保留所有权利。C:\WINDOWS\system32&gt;pip install numpyCollecting numpy Using cached https://files.pythonhosted.org/packages/dd/3e/0d7a914ee6cceef588dd83b18e257dc474ac67028a8d340dfec644878128/numpy-1.16.0-cp37-cp37m-win_amd64.whlInstalling collected packages: numpySuccessfully installed numpy-1.16.0C:\WINDOWS\system32&gt;pip install matplotlibCollecting matplotlib Downloading https://files.pythonhosted.org/packages/5c/ee/efaf04efc763709f6840cd8d08865d194f7453f43e98d042c92755cdddec/matplotlib-3.0.2-cp37-cp37m-win_amd64.whl (8.9MB) 66% |█████████████████████▌ | 6.0MB 11kB/s eta 0:04:25Exception:Traceback (most recent call last): File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 331, in _error_catcher yield File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 413, in read data = self._fp.read(amt) File “c:\program files\python37\lib\site-packages\pip_vendor\cachecontrol\filewrapper.py”, line 62, in read data = self.fp.read(amt) File “c:\program files\python37\lib\http\client.py”, line 447, in read n = self.readinto(b) File “c:\program files\python37\lib\http\client.py”, line 491, in readinto n = self.fp.readinto(b) File “c:\program files\python37\lib\socket.py”, line 589, in readinto return self._sock.recv_into(b) File “c:\program files\python37\lib\ssl.py”, line 1052, in recv_into return self.read(nbytes, buffer) File “c:\program files\python37\lib\ssl.py”, line 911, in read return self._sslobj.read(len, buffer)socket.timeout: The read operation timed outDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File “c:\program files\python37\lib\site-packages\pip_internal\cli\base_command.py”, line 143, in main status = self.run(options, args) File “c:\program files\python37\lib\site-packages\pip_internal\commands\install.py”, line 318, in run resolver.resolve(requirement_set) File “c:\program files\python37\lib\site-packages\pip_internal\resolve.py”, line 102, in resolve self._resolve_one(requirement_set, req) File “c:\program files\python37\lib\site-packages\pip_internal\resolve.py”, line 256, in _resolve_one abstract_dist = self._get_abstract_dist_for(req_to_install) File “c:\program files\python37\lib\site-packages\pip_internal\resolve.py”, line 209, in _get_abstract_dist_for self.require_hashes File “c:\program files\python37\lib\site-packages\pip_internal\operations\prepare.py”, line 283, in prepare_linked_requirement progress_bar=self.progress_bar File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 836, in unpack_url progress_bar=progress_bar File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 673, in unpack_http_url progress_bar) File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 897, in _download_http_url _download_url(resp, link, content_file, hashes, progress_bar) File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 617, in _download_url hashes.check_against_chunks(downloaded_chunks) File “c:\program files\python37\lib\site-packages\pip_internal\utils\hashes.py”, line 48, in check_against_chunks for chunk in chunks: File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 585, in written_chunks for chunk in chunks: File “c:\program files\python37\lib\site-packages\pip_internal\utils\ui.py”, line 159, in iter for x in it: File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 574, in resp_read decode_content=False): File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 465, in stream data = self.read(amt=amt, decode_content=decode_content) File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 430, in read raise IncompleteRead(self._fp_bytes_read, self.length_remaining) File “c:\program files\python37\lib\contextlib.py”, line 130, in exit__ self.gen.throw(type, value, traceback) File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 336, in _error_catcher raise ReadTimeoutError(self._pool, None, ‘Read timed out.’)pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=’files.pythonhosted.org’, port=443): Read timed out.C:\WINDOWS\system32&gt;pip install matplotlibCollecting matplotlib Downloading https://files.pythonhosted.org/packages/5c/ee/efaf04efc763709f6840cd8d08865d194f7453f43e98d042c92755cdddec/matplotlib-3.0.2-cp37-cp37m-win_amd64.whl (8.9MB) 100% |████████████████████████████████| 8.9MB 88kB/sCollecting python-dateutil&gt;=2.1 (from matplotlib) Downloading https://files.pythonhosted.org/packages/74/68/d87d9b36af36f44254a8d512cbfc48369103a3b9e474be9bdfe536abfc45/python_dateutil-2.7.5-py2.py3-none-any.whl (225kB) 100% |████████████████████████████████| 235kB 75kB/sRequirement already satisfied: numpy&gt;=1.10.0 in c:\program files\python37\lib\site-packages (from matplotlib) (1.16.0)Collecting pyparsing!=2.0.4,!=2.1.2,!=2.1.6,&gt;=2.0.1 (from matplotlib) Downloading https://files.pythonhosted.org/packages/de/0a/001be530836743d8be6c2d85069f46fecf84ac6c18c7f5fb8125ee11d854/pyparsing-2.3.1-py2.py3-none-any.whl (61kB) 100% |████████████████████████████████| 71kB 59kB/sCollecting kiwisolver&gt;=1.0.1 (from matplotlib) Downloading https://files.pythonhosted.org/packages/7c/be/7ae355b45699460e369ebf88d86058fca26827933974cc3f6b6b7800a324/kiwisolver-1.0.1-cp37-none-win_amd64.whl (57kB) 100% |████████████████████████████████| 61kB 86kB/sCollecting cycler&gt;=0.10 (from matplotlib) Downloading https://files.pythonhosted.org/packages/f7/d2/e07d3ebb2bd7af696440ce7e754c59dd546ffe1bbe732c8ab68b9c834e61/cycler-0.10.0-py2.py3-none-any.whlCollecting six&gt;=1.5 (from python-dateutil&gt;=2.1-&gt;matplotlib) Downloading https://files.pythonhosted.org/packages/73/fb/00a976f728d0d1fecfe898238ce23f502a721c0ac0ecfedb80e0d88c64e9/six-1.12.0-py2.py3-none-any.whlRequirement already satisfied: setuptools in c:\program files\python37\lib\site-packages (from kiwisolver&gt;=1.0.1-&gt;matplotlib) (40.6.2)Installing collected packages: six, python-dateutil, pyparsing, kiwisolver, cycler, matplotlibSuccessfully installed cycler-0.10.0 kiwisolver-1.0.1 matplotlib-3.0.2 pyparsing-2.3.1 python-dateutil-2.7.5 six-1.12.0C:\WINDOWS\system32&gt;pip install networkxCollecting networkx Downloading https://files.pythonhosted.org/packages/f3/f4/7e20ef40b118478191cec0b58c3192f822cace858c19505c7670961b76b2/networkx-2.2.zip (1.7MB) 17% |█████▌ | 296kB 7.7kB/s eta 0:03:03Exception:Traceback (most recent call last): File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 331, in _error_catcher yield File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 413, in read data = self._fp.read(amt) File “c:\program files\python37\lib\site-packages\pip_vendor\cachecontrol\filewrapper.py”, line 62, in read data = self.fp.read(amt) File “c:\program files\python37\lib\http\client.py”, line 447, in read n = self.readinto(b) File “c:\program files\python37\lib\http\client.py”, line 491, in readinto n = self.fp.readinto(b) File “c:\program files\python37\lib\socket.py”, line 589, in readinto return self._sock.recv_into(b) File “c:\program files\python37\lib\ssl.py”, line 1052, in recv_into return self.read(nbytes, buffer) File “c:\program files\python37\lib\ssl.py”, line 911, in read return self._sslobj.read(len, buffer)socket.timeout: The read operation timed outDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File “c:\program files\python37\lib\site-packages\pip_internal\cli\base_command.py”, line 143, in main status = self.run(options, args) File “c:\program files\python37\lib\site-packages\pip_internal\commands\install.py”, line 318, in run resolver.resolve(requirement_set) File “c:\program files\python37\lib\site-packages\pip_internal\resolve.py”, line 102, in resolve self._resolve_one(requirement_set, req) File “c:\program files\python37\lib\site-packages\pip_internal\resolve.py”, line 256, in _resolve_one abstract_dist = self._get_abstract_dist_for(req_to_install) File “c:\program files\python37\lib\site-packages\pip_internal\resolve.py”, line 209, in _get_abstract_dist_for self.require_hashes File “c:\program files\python37\lib\site-packages\pip_internal\operations\prepare.py”, line 283, in prepare_linked_requirement progress_bar=self.progress_bar File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 836, in unpack_url progress_bar=progress_bar File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 673, in unpack_http_url progress_bar) File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 897, in _download_http_url _download_url(resp, link, content_file, hashes, progress_bar) File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 617, in _download_url hashes.check_against_chunks(downloaded_chunks) File “c:\program files\python37\lib\site-packages\pip_internal\utils\hashes.py”, line 48, in check_against_chunks for chunk in chunks: File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 585, in written_chunks for chunk in chunks: File “c:\program files\python37\lib\site-packages\pip_internal\utils\ui.py”, line 159, in iter for x in it: File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 574, in resp_read decode_content=False): File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 465, in stream data = self.read(amt=amt, decode_content=decode_content) File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 430, in read raise IncompleteRead(self._fp_bytes_read, self.length_remaining) File “c:\program files\python37\lib\contextlib.py”, line 130, in exit__ self.gen.throw(type, value, traceback) File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 336, in _error_catcher raise ReadTimeoutError(self._pool, None, ‘Read timed out.’)pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=’files.pythonhosted.org’, port=443): Read timed out.C:\WINDOWS\system32&gt;pip install networkxCollecting networkx Downloading https://files.pythonhosted.org/packages/f3/f4/7e20ef40b118478191cec0b58c3192f822cace858c19505c7670961b76b2/networkx-2.2.zip (1.7MB) 100% |████████████████████████████████| 1.7MB 187kB/sCollecting decorator&gt;=4.3.0 (from networkx) Downloading https://files.pythonhosted.org/packages/bc/bb/a24838832ba35baf52f32ab1a49b906b5f82fb7c76b2f6a7e35e140bac30/decorator-4.3.0-py2.py3-none-any.whlInstalling collected packages: decorator, networkx Running setup.py install for networkx … doneSuccessfully installed decorator-4.3.0 networkx-2.2C:\WINDOWS\system32&gt;pip install pywin32Collecting pywin32 Downloading https://files.pythonhosted.org/packages/a3/8a/eada1e7990202cd27e58eca2a278c344fef190759bbdc8f8f0eb6abeca9c/pywin32-224-cp37-cp37m-win_amd64.whl (9.0MB) 47% |███████████████ | 4.3MB 7.0kB/s eta 0:11:20Exception:Traceback (most recent call last): File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 331, in _error_catcher yield File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 413, in read data = self._fp.read(amt) File “c:\program files\python37\lib\site-packages\pip_vendor\cachecontrol\filewrapper.py”, line 62, in read data = self.fp.read(amt) File “c:\program files\python37\lib\http\client.py”, line 447, in read n = self.readinto(b) File “c:\program files\python37\lib\http\client.py”, line 491, in readinto n = self.fp.readinto(b) File “c:\program files\python37\lib\socket.py”, line 589, in readinto return self._sock.recv_into(b) File “c:\program files\python37\lib\ssl.py”, line 1052, in recv_into return self.read(nbytes, buffer) File “c:\program files\python37\lib\ssl.py”, line 911, in read return self._sslobj.read(len, buffer)socket.timeout: The read operation timed outDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File “c:\program files\python37\lib\site-packages\pip_internal\cli\base_command.py”, line 143, in main status = self.run(options, args) File “c:\program files\python37\lib\site-packages\pip_internal\commands\install.py”, line 318, in run resolver.resolve(requirement_set) File “c:\program files\python37\lib\site-packages\pip_internal\resolve.py”, line 102, in resolve self._resolve_one(requirement_set, req) File “c:\program files\python37\lib\site-packages\pip_internal\resolve.py”, line 256, in _resolve_one abstract_dist = self._get_abstract_dist_for(req_to_install) File “c:\program files\python37\lib\site-packages\pip_internal\resolve.py”, line 209, in _get_abstract_dist_for self.require_hashes File “c:\program files\python37\lib\site-packages\pip_internal\operations\prepare.py”, line 283, in prepare_linked_requirement progress_bar=self.progress_bar File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 836, in unpack_url progress_bar=progress_bar File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 673, in unpack_http_url progress_bar) File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 897, in _download_http_url _download_url(resp, link, content_file, hashes, progress_bar) File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 617, in _download_url hashes.check_against_chunks(downloaded_chunks) File “c:\program files\python37\lib\site-packages\pip_internal\utils\hashes.py”, line 48, in check_against_chunks for chunk in chunks: File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 585, in written_chunks for chunk in chunks: File “c:\program files\python37\lib\site-packages\pip_internal\utils\ui.py”, line 159, in iter for x in it: File “c:\program files\python37\lib\site-packages\pip_internal\download.py”, line 574, in resp_read decode_content=False): File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 465, in stream data = self.read(amt=amt, decode_content=decode_content) File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 430, in read raise IncompleteRead(self._fp_bytes_read, self.length_remaining) File “c:\program files\python37\lib\contextlib.py”, line 130, in exit__ self.gen.throw(type, value, traceback) File “c:\program files\python37\lib\site-packages\pip_vendor\urllib3\response.py”, line 336, in _error_catcher raise ReadTimeoutError(self._pool, None, ‘Read timed out.’)pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=’files.pythonhosted.org’, port=443): Read timed out.C:\WINDOWS\system32&gt;pip install pywin32Collecting pywin32 Downloading https://files.pythonhosted.org/packages/a3/8a/eada1e7990202cd27e58eca2a278c344fef190759bbdc8f8f0eb6abeca9c/pywin32-224-cp37-cp37m-win_amd64.whl (9.0MB) 100% |████████████████████████████████| 9.1MB 6.3kB/sInstalling collected packages: pywin32Successfully installed pywin32-224C:\WINDOWS\system32&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[protocol family unavailable]]></title>
    <url>%2F2019%2F05%2F16%2F86288399%2F</url>
    <content type="text"><![CDATA[出项这种问题的原因可能很多，但是我的问题我是通过关闭防火墙解决的。开始出现这个问题我没有觉得关闭防火墙有用，因为我上一次不照样能运行吗！但是后来我新建了一个项目还是出现同样的问题，打开日记一看，有一个这样的错误：Cannot start internal HTTP server. Git integration, JavaScript debugger and LiveEdit may operate with errors. Please check your firewall settings and restart Android Studio于是我将所有的防火墙都关闭，特别是那个红色标记的：回想了一下，上一次运行的时候，确实没有，电脑也是正常睡眠，但是这一次开机我们充好电再开的，我想可能就是因为电脑没有电关机了，然后开机防火墙自动开启。我也不记得as是需要关闭防火墙去了，哎，新手嘛！]]></content>
  </entry>
  <entry>
    <title><![CDATA[宠物顶顶顶]]></title>
    <url>%2F2019%2F05%2F16%2F85216558%2F</url>
    <content type="text"><![CDATA[复制粘贴到自定义栏目&lt;img src=”20181222185219565.png”&gt;&lt;img src=”20181222185219673.png”&gt;&lt;img src=”20181222185219574.png”&gt;&lt;img src=”20181222185219584.png”&gt;&lt;img src=”20181222185219622.png”&gt;&lt;img src=”20181222185219587.png”&gt;&lt;img src=”20181222185219678.png”&gt;&lt;img src=”20181222185219697.png”&gt;&lt;img src=”2018122218522080.png”&gt;&lt;img src=”20181222185219690.png”&gt;&lt;img src=”20181222185219765.png”&gt;&lt;img src=”20181222185219786.png”&gt;&lt;img src=”20181222185220163.png”&gt;&lt;img src=”20181222185219856.png”&gt;&lt;img src=”2018122218522061.png”&gt;&lt;img src=”20181222185220200.png”&gt;&lt;img src=”20181222185220360.png”&gt;&lt;img src=”20181222185221169.png”&gt;&lt;img src=”20181222185220606.png”&gt;&lt;img src=”20181222185909860.png”&gt;&lt;img src=”20181222185909911.png”&gt;&lt;img src=”20181222185909910.png”&gt;&lt;img src=”20181222185909909.png”&gt;&lt;img src=”20181222185909911.png”&gt;&lt;img src=”20181222185909913.png”&gt;&lt;img src=”20181222185909912.png”&gt;&lt;img src=”20181222185909928.png”&gt;&lt;img src=”20181222185909914.png”&gt;&lt;img src=”20181222185909941.png”&gt;&lt;img src=”20181222185909956.png”&gt;&lt;img src=”20181222185909983.png”&gt;&lt;img src=”201812221859107.png”&gt;&lt;img src=”2018122218591026.png”&gt;&lt;img src=”2018122218591053.png”&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库复习笔记]]></title>
    <url>%2F2019%2F05%2F16%2F85213894%2F</url>
    <content type="text"><![CDATA[数据库复习笔记第一章、绪论1.数据库管理体统：是位于用户与操作系统之间的一层管理软件，是计算机基础软件。主要功能有，数据定义，数据组织、存储和管理，数据操纵，数据库事务管理、运行管理，数据库的建立与维护等。2.数据库系统：是由数据库、数据库管理系统和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统。3.数据结构化：数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的主要区别。所谓“整体”结构化是指数据库中的数据不再仅仅针对某一个应用，而是面向整个组织或企业；不仅数据内部结构化，而是整体，数据之间是有联系的。4.数据独立性：包括物理独立性（是指用户的应用程序与数据库中数据的物理存储是相互独立的），逻辑独立性（是指用户的应用程序与数据库的逻辑结构是相互独立的，也就是逻辑结构改变，用户程序不变）。5.数据由数据库管理系统统一管理和控制 1）数据的安全性保护：是指保护数据以防止不合法使用造成数据泄密和破坏。 2）数据的完整性检查：是指数据的正确性、有效性和相容性。 3）并发控制：多个用户同时操作数据，相互干扰产生错，因此必须对并发操作加以控制。 4）数据库恢复：计算机硬件、软件故障和操作员的失误以及故意破坏造成的影响进行恢复。6.数据库：是长期存储在计算机内有组织、大量、共性数据的集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。7.数据模型：是对现实数据的抽象，应满足三方面的要求：真实地模拟现实世界，容易为人理解，便于在计算机上实现。 两类数据模型： 1）概念模型：是按照用户地观点来对数据信息建模，主用于数据库设计。 2）逻辑模型和物理模型：逻辑模型主要包括层次、网状、关系、面向对象、关系对象、半结构化等数据模型。主用数据库管理系统地实现；物理模型是数据库系统的核心和基础。8.概念模型： 1）码：唯一标识实体的属性集。 2）联系：指不同实体集之间的联系。一对一、一对多、多对多等。9.数据模型的主要组成因素：数据结构、数据操作和数据的完整性约束。 1）数据结构：描述数据库组成对象以及对象之间的联系； 2）数据操作：指数据库中各种对象的实例运行执行操作的集合，包括操作规则。 3）数据的完整性约束：是一组完整性规则。10.关系模型： 1）关系模型的数据结构：关系（一个关系通常是一张表）、元组（表中过的一行）、属性（表中的一列）、码（即码键，表中的一个属性组）、域（具有相同数据类型值的集合）、分量（元组中一个属性值）、关系模式（对关系的描述）。关系模型要求关系必须是规范化的，每一个分量是不可分的数据项。 2）关系模型数据操纵和完整性约束：操作对象和操作结果是关系；关系模型把存储路径向用户隐藏。 3）关系模型的优缺点：建立在严格的数学概念的基础上；概念单一；存储路径对用户透明，从而具有更高的数据独立性、安全保密性，简化了程序员的共组和数据库开发建立的工作。11.数据库系统模式：是数据库中全体数据的逻辑结构和特征的描述。模式是相对稳定的而实体是相对变动的。12.数据库的三级模式结构： 1）模式：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的藐视，是所有用户的公共数据视图。 2）外模式：也称子模式或用户模式，是数据库用户能够看见和使用的局部数据逻辑结构和特征的描述，是数据库用户的数据视图，是于某一应用有关的数据的逻辑表示。 3）内模式：也称存储模式，一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。13.数据库的二级映像功能与数据独立性： 1）外模式/模式映像：当模式变化时由DBA对外模式/模式映像作相应改变，可以使模式保持不变，应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证数据与程序的逻辑独立性，简称数据的逻辑独立性 2）模式/内模式映像：当数据库的存储结构改变时，用DBA对模式/内模式映像作相应该百年，可以是模式保持不变，从而 应用程序也不必改变。保证里数据与程序的物理独立性，简称数据的物理独立性14.数据管理员（DBA）职责： 1）决定数据库中的信息内容和结构。 2）决定数据库的存储结构和存储策略。 3）定义数据的安全性要求和完整性约束。 4）监控数据库的使用和运行。 5）数据库的改进和重组、重构。15.用户：指最终用户，分为三类，偶然用户、简单用户、复杂用户（使用数据库语言访问数据库，能通过接口编制应用程序）。第二章、关系数据库1.关系：一组域的笛卡儿积的子集叫做这一组域上的关系。 笛卡儿积：D1 x D2 x … x Dn 关系：R(D1 x D2 x … x Dn)2.候选码：某一属性组的值能唯一地标识一个元组，而其自己不能，则称该属性组为候选码。 一个关系有多个候选码，选定其中一个为主码。 候选码地诸属性成为主属性。 关系模式地所有属性是这个关系模式的候选码，称为全码。3.关系可有有三种类型：基本关系（通常称基本表或基表）、查询表和视图表。4.基本关系具有6条属性：1）列是同质的；2）不同的列可以出自同一个域； 3）列的顺序无所谓；4）任意两个元组的候选码不能取相同的值；5）行的顺序无所谓；6）分量必须取原子值；5.关系数据库：关系数据库的型也称关系数据库的模式，是关系数据库的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。6.基本操作：选择、投影、并、差、笛卡儿积是五种基本操作。7.关系数据语言的分类：关系代数（对关系的运算来表达查询要求）、关系演算（用谓词来表达查询要求）。 结构化查询语言（SQL）：不仅具有丰富的查询功能，而且有数据定义和数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言于一体的关系数据语言。8.实体完整性规则：若属性（指一个或一组属性）A是基本关系R的属性，则A不能取空值。所谓控制就是“不知道”或“不存在”或“无意义”的值。9.参照完整性规则：若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每一个元组在F上的值不许：或者取空值（F的每一个属性值均为空值）；或者等于S中某个元组的主码值。 设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。10.传统的集合运算并： 差： 交： 笛卡儿积： 11.专门的关系运算：选择、投影、连接、除运算。 1）选择：又称为限制。它是关系R中先择满足给定条件的诸元素。记作： 。逻辑表达式F的基本形式： 2）投影:关系R上的投影是从R中选择出若干属性列组成新的关系。记作： ，其中A为R中的一个属性列。 3）连接：连接也称 连接。它是两个关系的笛卡尔积中选取属性间满足一定条件的元组，记作： 其中，A和B分别为R和S上列数相等且可比的属性组，θ是比较运算符。连接运算从R和S的笛卡儿积R×S中选取R关系在A属性组上的值与S关系在B属性上的值满足比较关系θ的元组。 θ为“=”的连接运算称为等值连接。 自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把同名的属性值去掉。 第三章、关系数据库标准语言SQL 1.SQL的特点 1）综合统一：集数据定义、数据操纵、数据控制语言的功能于一体。 2）高度非过程化：只要提出“做什么”，而无需指明“怎么做”。 3）面向集合的操作方式。 4）同一种语言结构提供多种使用方式：即是独立的语言，又是嵌入式语言。 5）语言简介，易学易用：完成核心功能只用了九个动词。 2.SQL的基本概念：]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql基础实验过程+遇到的问题的解决方法(error105处理）]]></title>
    <url>%2F2019%2F05%2F16%2F85213211%2F</url>
    <content type="text"><![CDATA[跳过登录更改密码： 跳过密码登录：首先确保打开mysql服务，mysql路径加入了path中，然后使用管理员方式打开dos，输入命令：mysqld –skip-grant-tables 不要关闭窗口，再打开另一个dos窗口输入命令：mysql 登录成功。 更改密码：打开mysql数据库更改里面的user表，输入命令：mysql&gt;update user set authentication_string=password(‘123456’) where user=’root’;(将root用户密码更改为123456)创建用户（参考博客：https://www.cnblogs.com/wanghetao/p/3806888.html）创建数据库（模式）：create schema text_schema; show databases;在模式里面创建表 ：use text_chema; create table text_table(text_col int,text_col1 smallint); show tables;删除数据库（模式）：drop schema text_chema; show tables;(报错) show databases;创建表：create database school_database; create table student(sno char(9),primary key,sname char(20) unique,ssex char(2),sage smallint,sdept char(20)); show tables; create table course(cno char(4) primary key,cname char(40) not null,cpno char(4),ccredit smallint,foreign key(cpno) references course(cno));//外键 create table sc(sno char(9),cno char(4),grade smallint,primary key(sno,cno),foreign key(sno) references student(sno),foreign key(cno) references course(cno)); 数据类型 数据类型 含义 char(n),character(n) 长度为n的定长字符串 varchar(n),charactervarying(n) 最大长度为n的变长字符串 clob 字符串大对象 blob 二进制大对象 int,interger 长整数（4字节） smallint 短整型（2字节） bigint 大整数（8字节） numeric(p,d), decimal(p,d),dec(p,d) 顶点数，整数部分p位，小数部分d位 real 取决于机器精度的单精度浮点数 double precision 取决于机器精度的双精度浮点数 float(n) 可选精度的浮点数，进度至少n位数字 boolean 逻辑布尔量 date 日期，YYYY-MM-DD time 时间，HH:MM:SS timestamp 时间戳类型 interval 时间间隔类型 修改表：alter table student add s_entrance date; alter table student modify sage int; alter table course add unique(cname);删除表：create table text_table(text_col int); drop table text_table;索引：顺序文件上的索引、B+树索引、散列索引、位图索引。索引分为：unique（表明此索引的每一个索引值只对应唯一的数据记录）、cluster（聚簇索引）。索引的建立与删除：create unique index stusno on student(sno); create unique index coucno on course(cno); create unique index scno on sc(sno asc,cno desc); 修改索引名：alter table sc drop index scno; create unique index scsno on sc(sno asc,cno desc);mysql中engine=innodb和engine=myisam的区别（https://www.cnblogs.com/avivahe/p/5427884.html）修改编码： 1）修改mysql表的字符编码方式：alter table t_name convert to character set utf8 collate utf8_bin; 2）修改数据库的字符集：alter database mydb character set utf8; 3）创建数据库指定数据库的字符集：create database mydb character set utf8;（注意：修改编码是由于外键约束，导致报错，所以只有先撤销外键约束，修改后再建立）撤销外键：查看外键名：show create table course;解除外键：alter table course drop foreign key course_ibfk_1;重新创建外键的时候出现105错误，存在这种报错主要是创建约束时，有属性不一致的情况：ERROR 1005 (HY000): Can’t create table ‘school_database.#sql-1cd8_10’ (errno: 150) 1）类型不一致：外键的引用类型不一样，如主键是int外键是char 2）引用不存在：找不到主表中引用的列 3）编码不一致：引用的字段和外键的字符编码不一致，也可能存储引擎不一样 4）约束不一致：引用的字段和外键的约束不同 插曲：student修改位utf8之后，还是105报错，其实是collate(排序规则)存在差异区别。数据更新： 插入数据： insert into student(sno,sname,ssex,sdept,sage) values(‘201215121’,’李晨’,’男’,’sc’,21); 修改数据： 修改一个元组：update student set sage=22 where sno=’201215121’; 修改多个元组：update student set sage=sage+1; 删除数据： 删除一个元组：delete from student where sno=’201215121’; 删除多个元组：delete from sc; 查看数据：select from student; 向表中增加数据 单表查询：select sno,sname from student; select from student;select sno,2014-sage form student; select sno,’bir:’,2014-sage from student;select sno,’Year of Birth:’,2014-sage birthday,upper(sdept) Dept from student;select distinct sno from sc;//去掉表中的重复行 查询条件 谓词 比较 =，&gt;,&lt;,&gt;=,&lt;=,!=,&lt;&gt;,!&gt;,!&lt;;NOT+表运算符 确定范围 betweed and，not between and 确定集合 in，not in 字符匹配 like,not like 空值 is null,is not null 多重条件（逻辑运算） and,or,not select sname,sdept,sage from student where sage between 20 and 23;select sname,ssex from student where sdept in(‘cs’,’ma’,’is’);select sname,sno,ssex from student where sname like ‘刘%’;select sname from student where sname like ‘欧阳_’;select cno,ccredit from course where cname like ‘db_Design’ ESCAPE’\’;//%表示任意长度字符串，’_’表示任意单个字符。ESCAPE‘\’表示“\”为换码字符。select sname,grade from sc where cno=’3’ order by grade desc;//desc降序、asc升序 聚集函数 功能 count() 统计元组个数 count([distinct|all] &lt;列名&gt;) 统计一列中值的个数 sum([distinct|all] &lt;列名&gt;) 计算一列值得总和（此列是数值型） avg([distinct|all] &lt;列名&gt;) 计算一列值得平均值 max([distinct|all] &lt;列名&gt;) 求一列值中的最大值 min([distinct|all] &lt;列名&gt;) 求一列值中的最大值 group by子句将查询结果按某一列或多列的值分组，值相等的为一组。分组后聚集函数讲座用于每一个组，即每一组都有一个函数值。select cno,count(sno) from sc group by cno;select sno from sc from sc group by sno having count(*)&gt;3;//查询了选修了三门以上课的学生。where子句和having短语的区别：where作用于基本表或视图，从中选出满足条件的元组。having作用于组，从中选出满足条件的组。where子句不能用于聚集函数作为条件表达式。错误：select sno,avg(grade) from sc where avg(grade)&gt;=90 group by sno;正确：select sno,avg(grade) from sc group by sno having avg(grade)&gt;=90;连接查询：select student.sno,sname from student,sc where student.sno=sc.sno and sc.cno=’2’ and sc.grade&gt;90;自身连接：select first.cno,second.cpno from course first,course second where first.cpno=second.cno and second.cpno is not null;外连接 ： select student.sno,sname,ssex,sage,sdept,cno,grade from student left outer join sc on(student.sno=sc.sno);//左外连接 select student.sno,sname,ssex,sage,sdept,cno,grade from student right outer join sc on(student.sno=sc.sno);//右外连接嵌套查询：select sname from student where sno in(select sno from sc where cno=’2’); 查询块：select-from-where语句成为一个查询块。 嵌套查询：将一个查询块嵌套到另一个查询块的where子句或having短语的条件中成为嵌套查询。 带in嵌套查询： 不相关子查询：子查询的查询条件不依赖于父查询。两个查询可以独立实现。 select sno,sname,sdept from student when sdept in(select sdept from student where sname=’刘晨‘); 带比较运算符嵌套查询 相关子查询：子查询的查询条件依赖于父查询。 select sno,cno from sc x where grade&gt;=(select avg(grade) from sc y where y.sno=x.sno); //x是sc的别名，又称为元组变量。参数x.sno的值与父查询相关。 带有any（some）或all谓词嵌套查询 select sname,sage,sdept from student where sage&lt;any(select sage from student whre sdept=’cs’);建立视图：create view is_student as select sno,sname,sage from student where sdept=’is’;//create view只是把视图定义存入数据字典，并不执行其中的select语句。 create view is_student as select sno,sname,sage from student where sdept=’is’ with check option;//对数据进行操作都需要满足sdept=‘is’条件。行列子集视图：从单个基本表导出的，并且只是去掉基本表的某些行或某些列，但保留了主码，则称这类视图为行列子集视图。删除视图：drop view is_student;查询视图： 视图消解：从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。 目前多数关系数据库系统对行列自己视图的查询均能进行正确转换。但对非行列子集视图的查询就不一定能够转换。更新视图：最总作用是表的更新。视图的作用：1）视图能供简化用户的操作、2）视图使用户能以多角度看待同一数据、3）视图对重构数据库提供了一定程度的逻辑独立性、4）视图能够对机密数据提供安全保护、5）适当利用视图可以更清晰地表达查询。]]></content>
  </entry>
  <entry>
    <title><![CDATA[R文件变红原因to按钮变色的优化]]></title>
    <url>%2F2019%2F05%2F16%2F85017003%2F</url>
    <content type="text"><![CDATA[在编写大代码量项目的时候出现，R文件突然全红了。心态一下炸了，红了几天了今天终于解决了。开始对r文件大概理解是它代表资源路径，但是当它报错的时候，开始对自己的认识产生怀疑了，看来还是上课没有认真。R文件的含义：当 Android 应用程序被编译，会自动生成一个 R 类，其中包含了所有 res/ 目录下资源的 ID，如布局文件，资源文件，图片（values下所有文件）的ID等。在写java代码需要用这些资源的时候，你可以使用 R 类，通过子类+资源名或者直接使用资源 ID 来访问资源。既然他是一个自动生成的类，只要我文件路径没有放错，然后调用没有调用错，那么它生成就一定是死的。所以它出现错误除了这两个原因就只有另外一个原因了，那就是编写的res下的文件出错了。于是我重新点了一下Sync Project with Gradle file,就是这个按钮（）。然后发现又报错，错误提示是（颜色错误）仔细思考一下我在选择器中item的drawable的值从原来的图片直接变成了颜色rgb值。然后我重新改成图片，于是乎就可以了。果然还是这个原因。这样实现就必须通过设置两张不同的图片，然后调用，作为一个程序员来说是多么恶心的事情，虽然我可以ps，但所以之后我做了轻微的更改首先我还是将那个值变成颜色，但是这里的颜色是values文件夹下color.xml中的元素也就是在values文件夹下的color.xml文件中加上了下面两条语句。不过作为一个程序员来说还是有点不能忍受，但是，哎算了，第一次写android项目而且这个又是设计方面的东西，感觉没有纠结算法那么有成就感，就暂且放下吧。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[windos命令行设置网络]]></title>
    <url>%2F2019%2F05%2F16%2F83413041%2F</url>
    <content type="text"><![CDATA[由于最近遇到一个问题，电脑更改IP保存的时候出先保存失败的问题原因是由于权限不够，所导致的，由于时间问题也没有去追究为什么是这样的，以后有机会再找吧！首先通过打开dos（强调：管理员运行）将ip和dns改成自动获取方式：命令1：netsh interface ip set address name=”以太网” source=dhcp（作用：更改ip地址为自动获取，“以太网”是根据自己的电脑决定的）命令2：netsh interface ip set dns name=”以太网” source=dhcp（作用：更改dns服务器地址）将IP和dns设置手动方式：命令1：netsh interface ip set address”以太网” static (这里输入ip）（这里输入子网掩码）（这里输入网关）auto （作用：设置静态ip）命令2：netsh interface ip set dns”以太网” static （这里输入dns服务器地址） （作用：设置dns服务器地址）删除ip地址和dns方式：命令1：netsh interface ip set address name=”以太网” source=dhcp（作用：更改ip地址为自动获取，“以太网”是根据自己的电脑决定的）命令2：netsh interface ip set dns name=”以太网” source=dhcp（作用：更改dns服务器地址）]]></content>
  </entry>
  <entry>
    <title><![CDATA[牛客网-21天刷题计划-第2节 进阶-对称的二叉树]]></title>
    <url>%2F2019%2F05%2F16%2F83187444%2F</url>
    <content type="text"><![CDATA[使用非递归的二叉树遍历实现。#include&lt;iostream&gt;using namespace std;const int maxn=10000;/struct TreeNode { int val; struct TreeNode left; struct TreeNode right; TreeNode(int x) : val(x), left(NULL), right(NULL) { }}; /class Solution {public: bool isSymmetrical(TreeNode pRoot) { //头节点为空 if(pRoot==NULL)return true; //定义变量 int top=-1; TreeNodepl[maxn],pr[maxn],p_l,*p_r; //初始化栈 top++;pl[top]=pr[top]=pRoot; //左右序遍历 while(top!=-1) { //头节点出栈 p_l=pl[top];p_r=pr[top];top–; //判断是否对称 if(p_l-&gt;val!=p_r-&gt;val)return false; bool bpll=p_l-&gt;left==NULL,bplr=p_l-&gt;right==NULL; bool bprl=p_r-&gt;left==NULL,bprr=p_r-&gt;right==NULL; if((bpll^bprr)||(bplr^bprl))break; //将子节点入栈 if(p_l-&gt;left!=NULL) { top++; pl[top]=p_l-&gt;left; pr[top]=p_r-&gt;right; } if(p_l-&gt;right!=NULL) { top++; pl[top]=p_l-&gt;right; pr[top]=p_r-&gt;left; } } return top==-1; }}; 经过数十次的提交最后终于过了第一次找出没有考虑这个if(pRoot==NULL)return true;提交多次，会想以前写过的遍历算法，递归和非递归都是一样的思路，没有什么漏洞怀疑栈定义的问题，将maxn改为1000没有用，又改成1e6还是没有用看了一眼老师和其它同学的提交记录都是使用递归的方法，开始就是怀疑栈溢出，但是使用了数组栈还是溢出应该不可能整理了一下思路，有看是整理了一下代码第二次找出判断出错 bool bpll=p_l-&gt;left==NULL,bplr=p_l-&gt;right==NULL; bool bprl=p_r-&gt;left==NULL,bprr=p_r-&gt;right==NULL; if((bpll^bprr)||(bplr^bprl))break;还是不行，继续往下找，发现入栈时，判断是这样写的if(p_l!=NULL)and if(p_l!=NULL)改了过来，过了10%开始肯定了自己的逻辑，找了一下代码，没错第三次找出题意的对称不仅仅是形状上的对称，数值上也要对称相等，加上了if(p_l-&gt;val!=p_r-&gt;val)return false;然后就过了。思路：形状上的对称只要，同时先序遍历后序遍历，如果同时存在相同的子节点就对称，数值就在判断子节点的时候，判断一下数值就行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[0型文法、1型文法、2型文法、3型文法对照]]></title>
    <url>%2F2019%2F05%2F16%2F83184710%2F</url>
    <content type="text"><![CDATA[最近刚刚学编译原理，把对那几种文法罗列一下！ 0型文法其中,至少含有一个非终结符，并且，表示终结符和非终结符的并集。1型文法：又称为上下文有关文法，（1）：式子左边可以有多个字符，但必须有一个非终结符（2）：式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符（3）：左边长度必须小于右边（例外）2型文法：又称为上下文无关文法，（1）：式子左边只能有一个字符，而且必须是非终结符（2）：式子右边可以有多个字符，可以是终结符，也可以是非终结符，8但必须是有限个字符3型文法：又称为正规文法（正规文法又包括左线性文法和右线性文法）或或（大写字母表示非终结符，小写字母表示终结符）]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu14+vmwear联网]]></title>
    <url>%2F2019%2F05%2F16%2F83064233%2F</url>
    <content type="text"><![CDATA[1.在虚拟机中添加vmnet8，设置为nat模式点击虚拟机菜单栏的编辑–&gt;虚拟网络编辑器：弹出窗口如下 2. 打开网络共享中心–&gt;更改适配器设置：可以看到有一个vmnet8然后点击物理机联网的适配器–&gt;共享–&gt;勾选“允许其他网络用户。。。。”–&gt;选择vmnet8–&gt;确认保存 3.设置ubuntu14虚拟计算机网络属性，选择自定义为vnet8，确认保存，进入虚拟计算机就可以了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[实验室网线联网经验]]></title>
    <url>%2F2019%2F05%2F16%2F83063776%2F</url>
    <content type="text"><![CDATA[由于学校实验室是局域网，所给的ip都是分配好了的，需要设置固定ip地址才能上网 打开文件管理（按win+E） 在搜索框输入（控制面板\网络和 Internet\网络和共享中心）括号中的内容，enter搜索（打开网络共享中心） 点击以太网 点击属性 双击击ipv4，如下 进入后就可以选择固定ip，输入IP相关信息 最后确认保存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[fzu Problem 2169 shadow]]></title>
    <url>%2F2019%2F05%2F16%2F81981012%2F</url>
    <content type="text"><![CDATA[Problem 2169 shadowAccept: 425 Submit: 1666Time Limit: 1000 mSec Memory Limit : 32768 KB Problem DescriptionYL是shadow国的国王,shadow国有N个城市。为了节省开支,shadow国只有N-1条道路,这N-1条道路使得N个城市连通。某一年,shadow国发生了叛乱,叛军占领了多个城市,王都岌岌可危。王都为编号为1的城市，除了王都外有K个城市有YL的军队。现在这K支军队要向王都进军，并且消灭沿途经过的城市中的叛军。现给出N个城市的道路情况以及城市的叛军数量，问总共需要消灭多少叛军？ Input第一行输入两个整数N，K，接下来输入N(1&lt;=N&lt;=100000)个整数Ai(0&lt;=Ai&lt;=10000)，表示第i个城市的叛军数量。接下来输入K个大于等于1且小于等于N的整数，表示有军队的城市的编号。数据保证王都以及有军队的城市没有叛军。接下来输入N-1行，每行两个整数u、v，表示连接u和v的一条道路。每支军队只能沿着道路走，并且是其所在城市与王都之间的最短路线走。 Output输出一行一个整数表示消灭的叛军数量。 Sample Input4 2 0 3 0 0 3 4 1 2 2 3 2 4 Sample Output3 虽然数据很弱，可以很简单的代码就过，但是还是不要错过这个简单的图算法题目。广度优先搜索，从1开始搜遇到一个有友军的城市就回溯，将路径上的所有敌军消灭，一个队列就可以解决，但是需要制作很多标记，敌军标记，友军标记，访问标记，然后队列就要有上一个城市标记，图因为太大使用邻接表存储，ylarmy.a[i]为0表示没有访问过，1表示访问过，2表示友军所在城市，为3表示皇城。ylarmy.b[i]表示回溯过的城市，也就是走过的路，这个标记是防止走重复路的，因为每一次回溯都回溯到皇城的话就会走太多的重复路，差不多就是dp中剪枝的意思。代码如下：#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=1e5+5;struct Enode{int endpoint;Enode nextEdg;};//边终点标记struct Vnode{int reble_army;Enode firstedg;};//叛军//第一条边struct Graph{Vnode vnode[maxn];int n;}g;struct{int a[maxn];bool b[maxn];}ylarmy;struct queue{int pre,d;};void clearg(int n){ g.n=n; for(int i=0;i&lt;=n;i++) g.vnode[i].firstedg=NULL;}void insert(int start,int end){ Enode p=(Enode)malloc(sizeof(Enode)); p-&gt;endpoint=end; p-&gt;nextEdg=g.vnode[start].firstedg; g.vnode[start].firstedg=p;}int Bfs(){ int ans=0,x;Enode *e; queue q[maxn];int front=-1,rear=-1; rear++;q[rear].pre=-1;q[rear].d=1; ylarmy.a[1]=3;ylarmy.b[1]=true; while(front!=rear){ e=g.vnode[q[++front].d].firstedg; while(e!=NULL{ if(ylarmy.a[e-&gt;endpoint]==2){ ans+=g.vnode[e-&gt;endpoint].reble_army; int d=q[front].d; int pre=q[front].pre; while(!ylarmy.b[d]){ ans+=g.vnode[d].reble_army; g.vnode[d].reble_army=0; ylarmy.b[d]=true; d=q[pre].d; pre=q[pre].pre; } ylarmy.a[e-&gt;endpoint]=0; } if(ylarmy.a[e-&gt;endpoint]==0){ ylarmy.a[e-&gt;endpoint]=1;///表示已经走过的点 q[++rear].pre=front; q[rear].d=e-&gt;endpoint; } e=e-&gt;nextEdg; } } return ans;}int main(){ int n,k; int i,p1,p2,d; while(~scanf(“%d%d”,&amp;n,&amp;k)){ memset(ylarmy.a,0,sizeof(ylarmy.a)); memset(ylarmy.b,0,sizeof(ylarmy.b)); clearg(n); for(i=1;i&lt;=n;i++) scanf(“%d”,&amp;g.vnode[i].reble_army); for(i=0;i&lt;k;i++){ scanf(“%d”,&amp;d); ylarmy.a[d]=2;///表示友军 } i=n-1; while(i–){ scanf(“%d%d”,&amp;p1,&amp;p2); insert(p1,p2); insert(p2,p1); } printf(“%d\n”,Bfs()); } return 0;} 有点长，但是思路很清晰，容易理解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[while与string::length()使用的错误]]></title>
    <url>%2F2019%2F05%2F16%2F81908835%2F</url>
    <content type="text"><![CDATA[在一次做题中，发现while(j&lt;str.length())逻辑不正确的情况，比如当j=0并且str.length()==10的或者其它数，算数上j是要小于str.length()的，但是当用c/c++实现这条代码是cout&lt;&lt;j&lt;str.length()&lt;&lt;endl,输出的是0。很奇怪。当时我做的是nyoj5Binary String Matching 使用的是一个自己改的kmp模板；在模板实现的时候遇到的这个问题正确代码#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int MaxSize=1e5;void GetNextval(string t,int nextval[]){ int j=0,k=-1; nextval[0]=-1; while(j&lt;t.length()) { if(k==-1||t[j]==t[k]) { j++;k++; if(t[j]!=t[k]) nextval[j]=k; else nextval[j]=nextval[k]; } else k=nextval[k]; }}int KMPIndex(string s,string t){ int nextval[MaxSize],i=0,j=0; GetNextval(t,nextval); int result=0; int sl=s.length(),tl=t.length(); while(i&lt;sl){ //cout&lt;&lt;s.length()&lt;&lt;endl&lt;&lt;t.length()&lt;&lt;endl; //cout&lt;&lt;i&lt;&lt;endl&lt;&lt;j&lt;&lt;endl; //cout&lt;&lt;(i&lt;s.length()&amp;&amp;j&lt;t.length())&lt;&lt;endl; while(i&lt;sl&amp;&amp;j&lt;tl)///((i&lt;s.length())&amp;&amp;(j&lt;t.length()))// { if(j==-1||s[i]==t[j]) { i++; j++; } else j=nextval[j]; } if(j==t.length()) { result++; i=i-j+1; j=0; } } return result;}int main(){ //freopen(“C:\Users\zhou\Desktop\in.txt”,”r”,stdin); //freopen(“C:\Users\zhou\Desktop\out.txt”,”w”,stdout); ios::sync_with_stdio(false); string s,t; int n; cin&gt;&gt;n; while(n–) { t.clear();s.clear(); cin&gt;&gt;t&gt;&gt;s; //cout&lt;&lt;t&lt;&lt;endl&lt;&lt;s&lt;&lt;endl; int r=KMPIndex(s,t); cout&lt;&lt;r&lt;&lt;endl; } return 0;} 错误代码如下：（错误代码比正确代码只有kmp函数的while（）中有区别）#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int MaxSize=1e5;void GetNextval(string t,int nextval[]){ int j=0,k=-1; nextval[0]=-1; while(j&lt;t.length()) { if(k==-1||t[j]==t[k]) { j++;k++; if(t[j]!=t[k]) nextval[j]=k; else nextval[j]=nextval[k]; } else k=nextval[k]; }}int KMPIndex(string s,string t){ int nextval[MaxSize],i=0,j=0; GetNextval(t,nextval); int result=0; int sl=s.length(),tl=t.length(); while(i&lt;sl){ //cout&lt;&lt;s.length()&lt;&lt;endl&lt;&lt;t.length()&lt;&lt;endl; //cout&lt;&lt;i&lt;&lt;endl&lt;&lt;j&lt;&lt;endl; //cout&lt;&lt;(i&lt;s.length()&amp;&amp;j&lt;t.length())&lt;&lt;endl; while((i&lt;s.length())&amp;&amp;(j&lt;t.length()))//(i&lt;sl&amp;&amp;j&lt;tl)/// { if(j==-1||s[i]==t[j]) { i++; j++; } else j=nextval[j]; } if(j==t.length()) { result++; i=i-j+1; j=0; } } return result;}int main(){ //freopen(“C:\Users\zhou\Desktop\in.txt”,”r”,stdin); //freopen(“C:\Users\zhou\Desktop\out.txt”,”w”,stdout); ios::sync_with_stdio(false); string s,t; int n; cin&gt;&gt;n; while(n–) { t.clear();s.clear(); cin&gt;&gt;t&gt;&gt;s; //cout&lt;&lt;t&lt;&lt;endl&lt;&lt;s&lt;&lt;endl; int r=KMPIndex(s,t); cout&lt;&lt;r&lt;&lt;endl; } return 0;}解释原因，来自百度知道missgya的回答因为string的length函数，返回类型size_type是个无符号类型：size_type length( ) const;size_type An unsigned integral type for the number of elements in a string 而根据C语言的类型自动转换规则，当signed和unsigned作运算时，signed会自动转换为unsigned。例如：void main(){ int a = -1; unsigned int b = 10; if (a &lt; b) { cout&lt;&lt; “right\n”; } else { cout&lt;&lt; “wrong\n”; }}程序输出结果是wrong。因为在把a和b做比较时，会自动把a变成一个unsigned。同样的原因，当你用：while(i&lt;test.length()&amp;&amp;j&lt;par.length())时，length函数返回的是个unsigned，假如在判断过程中，j变成了-1，j &lt; par.length()这个条件将不会再成立，因此循环退出。为什么while(i&lt;length1&amp;&amp;j&lt;length) 正确呢，因为在此之前你定义的length1和length都是int，已经把length()函数返回的值变成signed了。所以，你可以这么判断：while(i&lt;(signed int)test.length()&amp;&amp;j&lt; (signed int)par.length())]]></content>
  </entry>
  <entry>
    <title><![CDATA[防线（Defense Lines,ACM/ICPC CERC 2010 UVa1471)]]></title>
    <url>%2F2019%2F05%2F16%2F81872158%2F</url>
    <content type="text"><![CDATA[题目大意：给一个长度为n（n&lt;=200000)的序列，你的任务时删除一个连续子序列，使得剩下的序列中有一个长度最大的连续增子序列。预处理得到g[i]（表示a[i]结尾的最长连续增序列）f[i]（表示a[i]开头的最长连续增序列），用set存a[i],g[i],然后通过f[i]找最优的a[j],g[j]。// UVa1471 Defense Lines// Rujia Liu// Algorithm 1: use STL set to maintain the candidates.// This is a little bit more intuitive, but less efficient (than algorithm 2)#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;cassert&gt;using namespace std;const int maxn = 200000 + 5;int n, a[maxn], f[maxn], g[maxn];struct Candidate { int a, g; Candidate(int a, int g):a(a),g(g) {} bool operator &lt; (const Candidate&amp; rhs) const { return a &lt; rhs.a; }};set&lt;Candidate&gt; s;int main() { int T; scanf(“%d”, &amp;T); while(T–) { scanf(“%d”, &amp;n); for(int i = 0; i &lt; n; i++) scanf(“%d”, &amp;a[i]); if(n == 1) { printf(“1\n”); continue; } g[0] = 1; for(int i = 1; i &lt; n; i++)///得到g if(a[i-1] &lt; a[i]) g[i] = g[i-1] + 1; else g[i] = 1; f[n-1] = 1; for(int i = n-2; i &gt;= 0; i–)///得到f if(a[i] &lt; a[i+1]) f[i] = f[i+1] + 1; else f[i] = 1; s.clear(); s.insert(Candidate(a[0], g[0]));//初始化s int ans = 1;//开始时字串的长度为1 for(int i = 1; i &lt; n; i++) { Candidate c(a[i], g[i]); // 找到s中第一个第一个大于或等于c.a的位置 set&lt;Candidate&gt;::iterator it = s.lower_bound(c); bool keep = true; //用于标记c是否满足进入后面考虑情况的条件 //存在小于它的数时，如果c.g更小，那么就没有必要考虑，也就不满足条件 if(it != s.begin()) { Candidate last = *(–it); //找到离它最近的一个小于它的数 int len = f[i] + last.g; ans = max(ans, len); if(c.g &lt;= last.g) keep = false; } if(keep) { s.erase(c); // 删除原来那个c.a的那个 s.insert(c);//插入新的c it = s.find(c); it++; //在c位置后面的数种删除不满足条件的数据 while(it != s.end() &amp;&amp; it-&gt;a &gt; c.a &amp;&amp; it-&gt;g &lt;= c.g) s.erase(it++); } } printf(“%d\n”, ans); } return 0;}//代码来自https://github.com/aoapc-book/aoapc-bac2nd]]></content>
  </entry>
  <entry>
    <title><![CDATA[紫书中所说的代码仓库链接]]></title>
    <url>%2F2019%2F05%2F16%2F81870192%2F</url>
    <content type="text"><![CDATA[git]]></content>
  </entry>
  <entry>
    <title><![CDATA[poj2823----sliding window]]></title>
    <url>%2F2019%2F05%2F16%2F81869769%2F</url>
    <content type="text"><![CDATA[单调队列_优先队列入门题Sliding WindowTime Limit: 12000MS Memory Limit: 65536K Total Submissions: 71411 Accepted: 20312 Case Time Limit: 5000MS DescriptionAn array of size n ≤ 106 is given to you. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves rightwards by one position. Following is an example: The array is [1 3 -1 -3 5 3 6 7], and k is 3.Window position Minimum value Maximum value [1 3 -1] -3 5 3 6 7 -1 3 1 [3 -1 -3] 5 3 6 7 -3 3 1 3 [-1 -3 5] 3 6 7 -3 5 1 3 -1 [-3 5 3] 6 7 -3 5 1 3 -1 -3 [5 3 6] 7 3 6 1 3 -1 -3 5 [3 6 7] 3 7 Your task is to determine the maximum and minimum values in the sliding window at each position. InputThe input consists of two lines. The first line contains two integers n and k which are the lengths of the array and the sliding window. There are n integers in the second line. OutputThere are two lines in the output. The first line gives the minimum values in the window at each position, from left to right, respectively. The second line gives the maximum values. Sample Input8 31 3 -1 -3 5 3 6 7Sample Output-1 -3 -3 -3 3 33 3 5 5 6 7&lt;/span&gt; 两个priority_queue&lt;int&gt;（优先队列）可以实现。用双端队列实现单调队列，同样可以实现。初学者，由于第一次没有初始化mq.k一直wa，后来又rt，因为maxn定义了100。/xk双端队列实现代码：没有优化，优化可能空间会更小，这样看着比较直观。*求最小时，因为窗口滑动的时候，如果是“小 大 较小”这个样的，然后k的范围大于3，那么中间哪个大的数完全可以不要记录在里面。同样求最大时也是一样的。#include&lt;iostream&gt;#include&lt;deque&gt;#define maxn 1000006using namespace std;int a[maxn],ma[maxn],mi[maxn];struct node{ int d; int i; node(int dd,int ii) { d=dd; i=ii; }};template &lt;typename Item&gt;struct monotone_queue{ std::deque&lt;Item&gt; data,ma; int k; void push(Item it) { while(!data.empty()&amp;&amp;data.back().i&lt;=it.i-k)data.pop_back(); while(!data.empty()&amp;&amp;data.front().d&gt;it.d)data.pop_front(); data.push_front(it); while(!ma.empty()&amp;&amp;ma.back().i&lt;=it.i-k)ma.pop_back(); while(!ma.empty()&amp;&amp;ma.front().d&lt;it.d)ma.pop_front(); ma.push_front(it); } void clear(){data.clear();} Item min(){return data.back();} Item max(){return ma.back();}};int main(){ //freopen(“C:\Users\zhou\Desktop\1.in”,”r”,stdin); //freopen(“C:\Users\zhou\Desktop\1.out”,”w”,stdout); monotone_queue&lt;node&gt; mq; int n,k; scanf(“%d%d”,&amp;n,&amp;k); mq.k=k; for(int i=1;i&lt;=n;i++) scanf(“%d”,&amp;a[i]); for(int i=1;i&lt;k;i++) mq.push(node(a[i],i)); int j=0; for(int i=k;i&lt;=n;i++) { mq.push(node(a[i],i)); mi[j]=mq.min().d; ma[j]=mq.max().d; j++; } for(int i=0;i&lt;j-1;i++) printf(“%d “,mi[i]); printf(“%d\n”,mi[j-1]); for(int i=0;i&lt;j-1;i++) printf(“%d “,ma[i]); printf(“%d\n”,ma[j-1]); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[ZOJ Problem Set - 4020]]></title>
    <url>%2F2019%2F05%2F16%2F81808699%2F</url>
    <content type="text"><![CDATA[ZOJ Problem Set - 4020#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int maxn=1e5+5;vector&lt;int&gt; mg[maxn];vector&lt;int&gt; t[maxn];int n,m;struct node{ int x,y; int step;};bool mgph(int xi,int yi,int xe,int ye){ queue&lt;node&gt; qu; node temp; temp.x=yi,temp.y=xi,temp.step=0; t[xi][yi]=-1; qu.push(temp); int x,y; while(!qu.empty()) { temp=qu.front(); //cout&lt;&lt;temp.y&lt;&lt;ends&lt;&lt;temp.x&lt;&lt;ends&lt;&lt;temp.step&lt;&lt;endl; qu.pop(); if(temp.x==ye&amp;&amp;temp.y==xe) { printf(“%d\n”,temp.step); return true; } for(int i=0;i&lt;2;i++) { if((mg[temp.y][temp.x]+temp.step)%2==0) { x=temp.x; switch(i) { case 0: y=temp.y+1;break; case 1: y=temp.y-1;break; } } else { y=temp.y; switch(i) { case 0: x=temp.x+1;break; case 1: x=temp.x-1;break; } } if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;(t[y][x]==0||(t[y][x]==-1&amp;&amp;temp.step%2==0))) { node temp1; temp1.x=x,temp1.y=y,temp1.step=temp.step+1; t[y][x]-=1; qu.push(temp1); } } } return false;}int main(){ int T; scanf(“%d”,&amp;T); while(T–) { scanf(“%d%d”,&amp;n,&amp;m); int d; for(int i=0;i&lt;n;i++){ mg[i].clear(); t[i].clear(); for(int j=0;j&lt;m;j++){ scanf(“%d”,&amp;d); mg[i].push_back(d); t[i].push_back(false); } } int xi,yi,xe,ye; scanf(“%d%d%d%d”,&amp;xi,&amp;yi,&amp;xe,&amp;ye); if(!mgph(xi-1,yi-1,xe-1,ye-1)) { printf(“-1\n”); } } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[csu----J(1812) 三角形和矩形]]></title>
    <url>%2F2019%2F05%2F16%2F81748292%2F</url>
    <content type="text"><![CDATA[多边形交并补模板运用J(1812): 三角形和矩形题目Submit Page Summary Time Limit: 5 Sec Memory Limit: 128 Mb Submitted: 7 Solved: 3 SpecialJudgeDescriptionBobo 有一个三角形和一个矩形，他想求他们交的面积。具体地，三角形和矩形由 8 个整数 x1,y1,x2,y2,x3,y3,x4,y4 描述。 表示三角形的顶点坐标是 (x1,y1),(x1,y2),(x2,y1)， 矩形的顶点坐标是 (x3,y3),(x3,y4),(x4,y4),(x4,y3).Input输入包含不超过 30000 组数据。每组数据的第一行包含 4 个整数 x1,y1,x2,y2 (x1≠x2,y1≠y2).第二行包含 4 个整数 x3,y3,x4,y4 (x3&lt;x4,y3&lt;y4).(0≤xi,yi≤104)Output对于每组数据，输出一个实数表示交的面积。绝对误差或相对误差小于 10-6 即认为正确。Sample Input1 1 3 30 0 2 20 3 3 10 0 2 24462 1420 2060 29694159 257 8787 2970Sample Output1.000000000.75000000439744.13967527Hint / 还要判断是凸包还是凹包，调用相应的函数 面积并，只要和面积减去交即可 /#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;const double eps = 1e-8;int dcmp(double x){ if(x &gt; eps) return 1; return x &lt; -eps ? -1 : 0;}struct Point{ double x, y;}z;double cross(Point a,Point b,Point c) ///叉积{ return (a.x-c.x)(b.y-c.y)-(b.x-c.x)(a.y-c.y);}Point intersection(Point a,Point b,Point c,Point d){ Point p = a; double t =((a.x-c.x)(c.y-d.y)-(a.y-c.y)(c.x-d.x))/((a.x-b.x)(c.y-d.y)-(a.y-b.y)(c.x-d.x)); p.x +=(b.x-a.x)t; p.y +=(b.y-a.y)t; return p;}//计算多边形面积double PolygonArea(Point p[], int n){ if(n &lt; 3) return 0.0; double s = p[0].y (p[n - 1].x - p[1].x); p[n] = p[0]; for(int i = 1; i &lt; n; ++ i) s += p[i].y (p[i - 1].x - p[i + 1].x); return fabs(s 0.5);}double CPIA(Point a[], Point b[], int na, int nb)//ConvexPolygonIntersectArea{ Point p[20], tmp[20]; int tn, sflag, eflag; a[na] = a[0], b[nb] = b[0]; memcpy(p,b,sizeof(Point)(nb + 1)); for(int i = 0; i &lt; na &amp;&amp; nb &gt; 2; i++) { sflag = dcmp(cross(a[i + 1], p[0],a[i])); for(int j = tn = 0; j &lt; nb; j++, sflag = eflag) { if(sflag&gt;=0) tmp[tn++] = p[j]; eflag = dcmp(cross(a[i + 1], p[j + 1],a[i])); if((sflag ^ eflag) == -2) tmp[tn++] = intersection(a[i], a[i + 1], p[j], p[j + 1]); ///求交点 } memcpy(p, tmp, sizeof(Point) tn); nb = tn, p[nb] = p[0]; } if(nb &lt; 3) return 0.0; return PolygonArea(p, nb);}double SPIA(Point a[], Point b[], int na, int nb)///SimplePolygonIntersectArea 调用此函数{ int i, j; Point t1[4], t2[4]; double res = 0, num1, num2; a[na] = t1[0] = a[0], b[nb] = t2[0] = b[0]; for(i = 2; i &lt; na; i++) { t1[1] = a[i-1], t1[2] = a[i]; num1 = dcmp(cross(t1[1], t1[2],t1[0])); if(num1 &lt; 0) swap(t1[1], t1[2]); for(j = 2; j &lt; nb; j++) { t2[1] = b[j - 1], t2[2] = b[j]; num2 = dcmp(cross(t2[1], t2[2],t2[0])); if(num2 &lt; 0) swap(t2[1], t2[2]); res += CPIA(t1, t2, 3, 3) num1 num2; } } return res;}bool cmp_node(Point a,Point b){ double ans=(b.x-z.x)(a.y-z.y)-(b.y-z.y)*(a.x-z.x); if(fabs(ans)&lt;eps) return sqrt(pow(a.x-z.x,2)+pow(a.y-z.y,2))&lt;sqrt(pow(b.x-z.x,2)+pow(b.y-z.y,2)); return ans&gt;0;}void sort_j(Point p[],int n){ int pos=0; for(int i=0;i&lt;n;i++) { if(p[pos].y&gt;p[i].y) pos=i; if(p[pos].y==p[pos].y&amp;&amp;p[pos].x&gt;p[i].x) pos=i; } swap(p[pos],p[0]); z=p[0]; sort(p+1,p+n,cmp_node);}Point p1[maxn], p2[maxn];int n1, n2;int main(){ double x1,x2,x3,x4,y1,y2,y3,y4; while(~scanf(“%lf%lf%lf%lf%lf%lf%lf%lf”,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3,&amp;x4,&amp;y4)) { p1[0].x=x2;p1[0].y=y1; p1[1].x=x1;p1[1].y=y1; p1[2].x=x1;p1[2].y=y2; p2[0].x=x4;p2[0].y=y3; p2[1].x=x3;p2[1].y=y3; p2[2].x=x4;p2[2].y=y4; p2[3].x=x3;p2[3].y=y4; sort_j(p1,3); sort_j(p2,4); double Area = SPIA(p1, p2,3,4); printf(“%.8f\n”,Area); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[csu----G(1809) Parenthesis]]></title>
    <url>%2F2019%2F05%2F16%2F81748253%2F</url>
    <content type="text"><![CDATA[G(1809): Parenthesis题目Submit Page Summary Time Limit: 5 Sec Memory Limit: 128 Mb Submitted: 25 Solved: 7 DescriptionBobo has a balanced parenthesis sequence P=p1 p2…pn of length n and q questions.The i-th question is whether P remains balanced after pai and pbi swapped. Note that questions are individual so that they have no affect on others.Parenthesis sequence S is balanced if and only if:1. S is empty;2. or there exists balanced parenthesis sequence A,B such that S=AB;3. or there exists balanced parenthesis sequence S’ such that S=(S’).InputThe input contains at most 30 sets. For each set:The first line contains two integers n,q (2≤n≤105,1≤q≤105).The second line contains n characters p1 p2…pn.The i-th of the last q lines contains 2 integers ai,bi (1≤ai,bi≤n,ai≠bi). OutputFor each question, output “Yes“ if P remains balanced, or “No“ otherwise.Sample Input4 2(())1 32 32 1()1 2Sample OutputNoYesNo这个代码主要是为了熟悉一下树状数组的运用。#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 100005int s[MAXN];char st[100005];int n;int lowbit(int x){return x&amp;(-x);}int sum(int x){ int sum=0; while(x){ sum+=s[x]; x-=lowbit(x); } return sum;}void add(int x,int a){ while(x&lt;=n){ s[x]+=a; x+=lowbit(x); }}int main(){ int q; while(~scanf(“%d%d”,&amp;n,&amp;q)) { memset(s,0,sizeof(s)); scanf(“%s”,st); for(int i=1;i&lt;=n;i++) { if(st[i-1]==’(‘) add(i,1); else add(i,-1); } int a,b; while(q–) { scanf(“%d%d”,&amp;a,&amp;b); bool flag=true; if(a&gt;b) { a=a+b; b=a-b; a=a-b; } if(st[a-1]==’(‘&amp;&amp;st[b-1]==’)’) { while(a&lt;b) { if(sum(a)-2&lt;0) { flag=false; break; } a++; } } if(flag==false) printf(“No\n”); else printf(“Yes\n”); } } return 0;} 普通求和，比上面的代码优化了好多倍#include&lt;iostream&gt;using namespace std;#define MAXN 100005int sum[MAXN];char s[MAXN];int main(){ int n,q; int a,b; while(~scanf(“%d%d”,&amp;n,&amp;q)) { getchar(); for(int i=1;i&lt;=n;i++) { scanf(“%c”,&amp;s[i]); if(s[i]==’(‘) sum[i]=sum[i-1]+1; else sum[i]=sum[i-1]-1; } while(q–) { scanf(“%d%d”,&amp;a,&amp;b); if(a&gt;b) swap(a,b); bool flag=true; if(s[a]==’(‘&amp;&amp;s[b]==’)’) for(int i=a;i&lt;b;i++) { if(sum[i]&lt;2) { flag=false; break; } } if(flag) printf(“Yes\n”); else printf(“No\n”); } } return 0;} 线段树优化，区间最小，比上面代码好#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define INF 100005#define MAXN 100005using namespace std;struct{ int l,r; int min;}tree[MAXN&lt;&lt;2];int sum[MAXN];char st[MAXN];void BuildTree(int i,int L,int R){ tree[i].l=L; tree[i].r=R; if(L==R) { tree[i].min=sum[L]; return ; } BuildTree(i&lt;&lt;1,L,(L+R)&gt;&gt;1); BuildTree(i&lt;&lt;1|1,((L+R)&gt;&gt;1)+1,R); tree[i].min=min(tree[i&lt;&lt;1].min,tree[i&lt;&lt;1|1].min); return ;}int QueryTree(int L,int R,int i){ if(L&lt;=tree[i].l&amp;&amp;R&gt;=tree[i].r) { return tree[i].min; } int mi=INF; if(L&lt;=tree[i&lt;&lt;1].r) mi=QueryTree(L,R,i&lt;&lt;1); if(R&gt;=tree[i&lt;&lt;1|1].l) mi=min(mi,QueryTree(L,R,i&lt;&lt;1|1)); return mi;}int main(){ int n,q,l,r; while(~scanf(“%d%d”,&amp;n,&amp;q)) { sum[0]=0; scanf(“%s”,st); for(int i=1;i&lt;=n;i++) { if(st[i-1]==’(‘) sum[i]=sum[i-1]+1; else sum[i]=sum[i-1]-1; } BuildTree(1,1,n); while(q–) { scanf(“%d%d”,&amp;l,&amp;r); if(l&gt;r) swap(l,r); if(st[l-1]==’(‘&amp;&amp;st[r-1]==’)’&amp;&amp;QueryTree(l,r-1,1)&lt;2) printf(“No\n”); else printf(“Yes\n”); } } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[csu----A(1803) 2016]]></title>
    <url>%2F2019%2F05%2F16%2F81748151%2F</url>
    <content type="text"><![CDATA[A(1803): 2016题目Submit Page Summary Time Limit: 5 Sec Memory Limit: 128 Mb Submitted: 15 Solved: 12 Description 给出正整数 n 和 m，统计满足以下条件的正整数对 (a,b) 的数量：1. 1≤a≤n,1≤b≤m;2. a×b 是 2016 的倍数。Input输入包含不超过 30 组数据。每组数据包含两个整数 n,m (1≤n,m≤109).Output对于每组数据，输出一个整数表示满足条件的数量。Sample Input32 632016 20161000000000 1000000000Sample Output1305767523146895502644Hint n=a2016+im=b2016+jnm=ab + aj2016 + bi2016 + ij#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define ll long longint main(){ ios::sync_with_stdio(false); ll n,m; while(~scanf(“%lld%lld”,&amp;n,&amp;m)) { ll ans=(n/2016)m+(m/2016)n-(n/2016)(m/2016); for(ll i=1;i&lt;=min(n,(ll)2015);i++) for(ll j=1;j&lt;=min(m,(ll)2015);j++) { if((ij)%2016==0) { ans+=((n-i)/2016+1)*((m-j)/2016+1); } } printf(“%lld\n”,ans); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[多边形面积]]></title>
    <url>%2F2019%2F05%2F16%2F81745674%2F</url>
    <content type="text"><![CDATA[#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define eps 1e-8using namespace std;struct node{ double x,y;}z;bool cmp_node(node a,node b){ double ans=(b.x-z.x)(a.y-z.y)-(b.y-z.y)(a.x-z.x); if(fabs(ans)&lt;eps) return sqrt(pow(a.x-z.x,2)+pow(a.y-z.y,2))&lt;sqrt(pow(b.x-z.x,2)+pow(b.y-z.y,2)); return ans&gt;0;}double PolygonArea(node I[],int cnt){ int pos=0; double ans=0; if(cnt&lt;3)return 0; for(int i=0;i&lt;cnt;i++) { if(I[pos].y&gt;I[i].y) pos=i; else if(I[pos].y==I[i].y&amp;&amp;I[pos].x&gt;I[i].x) pos=i; } swap(I[pos],I[0]); z=I[0]; sort(I+1,I+cnt,cmp_node); for(int i=0;i&lt;cnt;++i) { ans+=(I[(i+1)%cnt].xI[i].y-I[(i+1)%cnt].yI[i].x)/2.0; } return ans;}int main(){ node p[5]; p[0].x=1;p[0].y=5; p[1].x=1;p[1].y=3; p[2].x=3;p[2].y=1; p[3].x=3;p[3].y=3; double area=PolygonArea(p,4); cout&lt;&lt;area&lt;&lt;endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[快速选择问题]]></title>
    <url>%2F2019%2F05%2F16%2F81636443%2F</url>
    <content type="text"><![CDATA[输入n个整数和一个正整数k（1&lt;=k&lt;=n)，输出这k[n]。快速排序将序列分成两部分，大于tmp小于tmp分别对两部分进行排序不要合并void QuickSort(RecType R[],int s,int t,int k){ int i=s,j=t; RecType tmp; if(s&lt;t) { tmp=R[s]; while(i!=j) { while(j&gt;i&amp;&amp;R[j].key&gt;=tmp.key) j–; R[i]=R[j]; while(i&lt;j&amp;&amp;R[i].key&lt;=tmp.key) i++; R[j]=R[i]; } R[i]=tmp; QuickSort(R,i+1,t,k); QuickSort(R,s,i-1,k); }}//代码来自数据结构-李春葆的时间内将k[n]找出来#include&lt;iostream&gt;using namespace std;struct RecType{ int key;};int rk;void QuickSort(RecType R[],int s,int t,int k){ int i=s,j=t; RecType tmp; if(s&lt;t) { tmp=R[s]; while(i!=j) { while(j&gt;i&amp;&amp;R[j].key&gt;=tmp.key) j–; R[i]=R[j]; while(i&lt;j&amp;&amp;R[i].key&lt;=tmp.key) i++; R[j]=R[i]; } R[i]=tmp; if(k&gt;i) QuickSort(R,i+1,t,k); else if(k&lt;i) QuickSort(R,s,i-1,k); else rk=R[k].key; } rk=R[k].key;}int main(){ int s=1,t,k; RecType r[100]; cin&gt;&gt;t&gt;&gt;k; for(int i=1;i&lt;=t;i++) cin&gt;&gt;r[i].key; QuickSort(r,s,t,k); cout&lt;&lt;rk&lt;&lt;endl;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[逆序对]]></title>
    <url>%2F2019%2F05%2F16%2F81633814%2F</url>
    <content type="text"><![CDATA[输入一个序列求序列中的逆序对归并排序代码void merge_sort(int a,int x,int y,int T){if(y-x&lt;=1)return ;int m=x+(y-x)/2;int p=x,q=m,i=x;merge_sort(a,x,m,T);merge_sort(a,m,y,T);while(p&lt;m||q&lt;y){if(q&gt;=y||(p&lt;m&amp;&amp;a[p]&lt;=a[q]))T[i++]=a[p++];elseT[i++]=a[q++];}for(int x;i&lt;y;i++)a[i]=T[i];}//代码来自紫书分治方法，先分开，然后递归求解，最后合并问题。将序列分成差不多等长的两部分，统计i和j均在左边或者均在右边的逆序对数，再统计i在左边，j在右边的逆序对数。求i，j分别在两边的情况，可以通过上面的排序算法所用的技巧算，因为归并排序最后合并i在左j在右，并且两边有序所以每一次找到a[p]&gt;a[q]就可以判定为是逆序，并且可以判定a[p]到a[m]中间的都大于a[q]。于是 可以直接cnt+=m-p。#include&lt;iostream&gt;using namespace std;int a[100];int t[100];int cnt=0;void merge_sort(int a,int x,int y,int T){ if(y-x&gt;1) { int m=x+(y-x)/2; int p=x,q=m,i=x; merge_sort(a,x,m,T); merge_sort(a,m,y,T); while(p&lt;m||q&lt;y) { if(q&gt;=y||(p&lt;m&amp;&amp;a[p]&lt;=a[q])) T[i++]=a[p++]; else {T[i++]=a[q++];cnt+=m-p;} } for(i=x;i&lt;y;i++) a[i]=T[i]; }}int main(){ int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; merge_sort(a,0,n,t); cout&lt;&lt;cnt&lt;&lt;endl;}//代码来自对紫书上修改]]></content>
  </entry>
  <entry>
    <title><![CDATA[最大连续和]]></title>
    <url>%2F2019%2F05%2F16%2F81626898%2F</url>
    <content type="text"><![CDATA[用一般暴力方法：best = a[i]//初始化最大值for(int i = 1;i &lt;= n;i++)for(int j = i;j &lt;= n;j++){int sum=0; //检查连续子序列a[i] + … … + a[j]for(int k = i;k &lt;= j;k++)sum += a[k]; //累加元素和if(sum &gt; best) best = sum;//更新最大值}优化时间复杂度为s[0]=0;//s存前缀和for(int i = 1; i &lt;= n; i++)s[i]=s[i-1]+a[i];for(int i = 1; i &lt;= n; i++)for(int j = i; j &lt;= n; j++)best = max(best, s[j]-s[i-1]);分治法使时间复杂度更优int maxum(int *a,int x,int y)//返回数组在[x,y)区间中最大连续和{int v,l,r,maxs;if(y-x==1)return a[x];//只有一个元素，直接返回int m=(x+y)/2;int maxs=max(maxsum(a,x,m),maxsum(a,m,y));//分治第二步：递归求解v=0;l=a[m-1];for(int i=m-1;i&gt;=x;i–)l=max(l,v+=a[i]);//分治第三步合并(1)：从分界点开始往左的最大连续和lv=0;r=a[m];for(int i=m;i&lt;y;i++)r=max(r,v+=a[i]);//分支第三部合并(2):从分界点开始往右的最大连续和rreturn max(maxs,l+r);//把子问题的解与l和r比较}用前面时间复杂度为的代码加以改进，在的到s后对数组进行维护，得到s的前i项最小，在后面的是s[j]-s[i-1]中只要找到最小的s[i-1]就ok了，所以只要直接减去维护后的s[i-1]就可以了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件运行不了需安装.NET fremework3.5，或0xc0000135初始化失败怎么解决]]></title>
    <url>%2F2019%2F05%2F16%2F81605760%2F</url>
    <content type="text"><![CDATA[xp的0xc0000135初始化失败怎么解决win10的需安装.NET fremework3.5都是没有安装要安装.NET fremework3.5的原因要安装系统也是有的，只要选中上图的.NET fremework3.5选项是会弹出提示安装的，但是亲身体验有点慢，于是找了一下教程https://jingyan.baidu.com/article/fedf0737acc34f35ac897782.html离线安装包安装方法（推荐） 1 下载NET Framework 3.5.zip文件包 下载链接：https://pan.baidu.com/s/1brhhrY3 密码：2fc8 2 将下载的NET Framework 3.5.zip解压，解压后如下图！ 3 将解压得到【sxs】文件夹复制到C盘根目录（就是直接拖进C盘,用完后可以删除） 4 【右键】&gt;【以管理员身份运行】NET Framework 3.5，完成 温馨提示：一定要【右键】以管理员身份运行NET Framework 3.5！ 5 随后会出现一个黑框，等到100%就完成了！有时速度会很快，闪一下就过去了。 6 第一种方法完成！不明白的地方看说明！ END 方法2：在线安装方法（不推荐） 如图，右键点击【Windows标】 点击【功能和应用】 现在window10会进入如图的界面，滚动到最下面点击【应用和程序】 点击【启用或关闭Windows功能】 然后如图，勾上图示选项 最后点击【确定】，然后就等着系统自己安装完成！]]></content>
  </entry>
  <entry>
    <title><![CDATA[windows10关闭安全服务]]></title>
    <url>%2F2019%2F05%2F16%2F81588384%2F</url>
    <content type="text"><![CDATA[一、彻底关闭系统自带的windows defender不管你用的是哪个版本的Win10，其实只要停了Windows Defender的实时监控，也就等于让这款内置杀软“离职”，至少是被架空了。所以，在创意者更新中，进入Windows Defender安全中心，找到“病毒和威胁防护设置”，把里面“实时保护”等选项关了就好。老版本Win10在设置→更新和安全→Windows Defender中关闭“实时保护”之类的开关就行。新版本中找不到这个东西，就用注册表关闭的方法关闭Windows Defender安全中心具体方法如下：1、win+R打开运行小窗口，输入regedit，按回车键进入注册表编辑器。2、定位到HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SecurityHealthService3、在右侧找到DWORD（32位）值，命名为Start。4、修改数值数据为4。5、重启文件资源管理器，或注销再登录/重启系统。Windows10系统彻底关闭Windows Defender的技巧就为大家介绍到这里了。按照上述步骤操作，会看到Windows Defender安全中心不再出现，再配合停用Windows Defender，内置安全软件就不会打扰到大家了。当然，如果用户安装第三方杀软或安全软件，Windows Defender会自动被关闭。 二、彻底关闭360关闭360以后发现其实后台还是有360的主动防御服务，打开任务管理器，找到360的主动服务，点击结束任务是关闭不了的。因为360为了防止病毒强制结束进程而设有进程保护所以我们是无法通过任务管理器结束360的360涉及到系统底层的一些东西所以被默认为是系统进程不能随便关闭要想退出只能通过它自身退出360涉及到系统底层的一些东西所以被默认为是系统进程不能随便关闭要想退出只能通过它自身退出在你右下角的360图标上点右键退出选择时间或者完全关闭退出就行了360涉及到系统底层的一些东西所以被默认为是系统进程不能随便关闭要想退出只能通过它自身退出 选择网络防护中心最下面的，主动防御服务]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux卸载软件]]></title>
    <url>%2F2019%2F05%2F16%2F81560063%2F</url>
    <content type="text"><![CDATA[在终端里 apt-get安装的软件：安装软件sudo apt-get install softname1 softname2softname3……卸载软件 sudo apt-get remove softname1 softname2 softname3……卸载并清除配置sudo apt-get remove –purgesoftname1更新软件信息数据库 sudo apt-get update进行系统升级sudo apt-get upgrade, sudo apt-get distupgrade搜索软件包 sudo apt-cache search softname1 softname2 softname3……安装的deb包要用此方法：安装deb软件包 dpkg -i xxx.deb删除软件包 dpkg -r xxx.deb连同配置文件一起删除 dpkg -r –purge xxx.deb查看软件包信息 dpkg -info xxx.deb查看文件拷贝详情 dpkg -L xxx.deb查看系统中已安装软件包信息 dpkg -l重新配置软件包 dpkg-reconfigure xxx在“synaptic pakagemanager”里:点搜索，输入软件名在需要安装或卸载的软件上右击－点标记－最后点应用现在还可以在 software center里面,直接卸载。卸载源代码编译的的软件：cd 源代码目录make clean./configure（make）make uninstallrm -rf 目录清理系统：sudo apt-get autocleansudo apt-get cleansudo apt-get autoremove（或使用ubuntu-tweak清理）]]></content>
  </entry>
  <entry>
    <title><![CDATA[SecureCRT链接失败+ubuntu中root用户登录失败]]></title>
    <url>%2F2019%2F05%2F16%2F81559288%2F</url>
    <content type="text"><![CDATA[事情是这样的，前几天使用redhat的时候用到了securecrt软件登录linux终端，最近又使用ubuntu系统，在使用找这个软件的时候发现连接不了然后在找了好久终于找到了原因。原来是Ubuntu是没有带ssh这个软件的，// 1.sudo apt-get install openssh-server openssh-client// 2.rpm -qa | grep ssh查看SSH是否安装 若没有执行第1步// 3.service sshd status 查看是否开启 如果没有继续下面// 4.启动SSH服务 service sshd restart 停止服务 service sshd stop // 5.netstat -antp | grep sshd 查看是否启动22端口// 6.chkconfig sshd on 设置SSH服务为开机启sudo apt install ssh 下载这个软件后是用root用户还是不能链接思考了一下是不是密码忘了然后我就直接gurb模式改了root密码，像前一篇文章一样改了之后我又登，发现还是登不上，我还是怀疑密码有问题于是打开虚拟机登了一下，发现密码还真是错的，于是又进入那个模式开始改密码，发现进去不了了于是我找原因，其实我第一次进入的时候是在虚拟机加载界面的时候像redhat那样随便按e进入的，原来redhat还没有打开开机grub选项，于是我又找到grub的配置文件/etc/default/grub打开/etc/default/grub文件找到 GRUB_HIDDEN_TIMEOUT=0 这行，使用#注释掉，变成 #GRUB_HIDDEN_TIMEOUT=0 找到 GRUB_TIMEOUT=10 把10变成3,意思是等待3秒钟。 保存文件其实在这个过程中，还好我的本地用户在root组中，不然可能就要以其它的方式进入grub了，因为grub这个文件是readonly只读文件sudo chmod 666 grub，更改文件权限，当然是在/etc/default文件目录下执行的然后vi grub 然后改咯（命令模式下：i前插，a后插，x删字，dd删行，p粘贴，u撤回，hjkl移动；然后wq保存退出）执行命令 sudo update-grub 现在启动的时候就会显示grub菜单了，如果3秒内不选择，则会自动进入系统。有了这个以后，用上一篇文章更改，但是在下面登录的时候，老是提示要ctrl+d,然后一直循环，仔细一看说要确认密码，然后改输入，上一次没有打开Num Lock，的数字密码后enter，就进入了root了更改密码以后，还是不行于是我又找，发现下载的ssh是没有把root设置允许的,于是寻找配置文件$ sudo vi /etc/ssh/sshd_config找到PermitRootLogin no（prohibit password)一行，改为PermitRootLogin yes重启 openssh serverservice sshd restart然后就可以了登陆了。 中间参考文章https://blog.csdn.net/sfe1012/article/details/53113271https://blog.csdn.net/xiaocai9999/article/details/78012235https://blog.csdn.net/cnyygj/article/details/76086430]]></content>
  </entry>
  <entry>
    <title><![CDATA[牛客2018年第七次acm暑期培训----A-Minimum Cost Perfect Matching]]></title>
    <url>%2F2019%2F05%2F16%2F81556915%2F</url>
    <content type="text"><![CDATA[链接：https://www.nowcoder.com/acm/contest/145/A来源：牛客网Minimum Cost Perfect Matching时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 262144K，其他语言524288KSpecial Judge, 64bit IO Format: %lld题目描述You have a complete bipartite graph where each part contains exactly n nodes, numbered from 0 to n - 1 inclusive.The weight of the edge connecting two vertices with numbers x and y is (bitwise AND).Your task is to find a minimum cost perfect matching of the graph, i.e. each vertex on the left side matches with exactly one vertex on the right side and vice versa. The cost of a matching is the sum of cost of the edges in the matching. denotes the bitwise AND operator. If you’re not familiar with it, see {https://en.wikipedia.org/wiki/Bitwise_operation#AND}.输入描述:The input contains a single integer n (1 ≤ n ≤ 5 105).输出描述:Output n space-separated integers, where the i-th integer denotes pi (0 ≤ pi ≤ n - 1, the number of the vertex in the right part that is matched with the vertex numbered i in the left part. All pi should be distinct.Your answer is correct if and only if it is a perfect matching of the graph with minimal cost. If there are multiple solutions, you may output any of them. 示例1输入3输出0 2 1说明For n = 3, p0 = 0, p1 = 2, p2 = 1 works. You can check that the total cost of this matching is 0, which is obviously minimal.#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=500100;int d[MAXN];int c[20];int main(){ int n,i,j; c[0]=1; for(int i=0;i&lt;20;i++) { c[i+1]=2&lt;&lt;i; } scanf(“%d”,&amp;n); int p=upper_bound(c,c+20,n-1)-c; if(p!=0)p–; for(int i=n-1;i&gt;=0;i–) { if(i!=0&amp;&amp;d[i]==0) { while(i&lt;c[p])p–; d[i]=2c[p]-i-1; d[2*c[p]-i-1]=i; } } for(int i=0;i&lt;n-1;i++) printf(“%d “,d[i]); printf(“%d\n”,d[n-1]); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux跳过root密码登陆]]></title>
    <url>%2F2019%2F05%2F16%2F81544164%2F</url>
    <content type="text"><![CDATA[redhat：进入grub模式，然后向下面一样，在最后加s，enter，b进入系统ubuntu：进入grub模式，然后将recover，前面的ro改成rw，ctrl+x保存，root登陆系统 passwd更改root密码Ubuntu，第一次成功了，之后不知道为什么失败了好几次。]]></content>
  </entry>
  <entry>
    <title><![CDATA[dos查看文件md5值命令]]></title>
    <url>%2F2019%2F05%2F16%2F81368498%2F</url>
    <content type="text"><![CDATA[certutil -hashfile 路径+文件名 MD5]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态规划----最长上升子序列]]></title>
    <url>%2F2019%2F05%2F16%2F81362652%2F</url>
    <content type="text"><![CDATA[有一个长为n的数列a0,a1… …an-1。请求出这个序列中最长的上升子序列的长度。上升子序列指的是对于任意的i&lt;j都满足ai&lt;aj的子序列。限制条件{ n[1,1000]、n[0,1000000] }dp[i]表示以ai为末尾的最长上升子序列的长度dp[i]=max( 1,max{dp[j]+1 | j&lt;i且aj&lt;ai })#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1e3+1;int n;int a[MAXN];int dp[MAXN];int solve(){ int re=0; for(int i=0;i&lt;n;i++){ dp[i]=1; for(int j=0;j&lt;i;j++) if(a[j]&lt;a[i]) dp[i]=max(dp[i],dp[j]+1); re=max(re,dp[i]); } return re;}int main(){ scanf(“%d”,&amp;n); for(int i=0;i&lt;n;i++) scanf(“%d”,&amp;a[i]); printf(“%d\n”,solve()); return 0;}前面的dp针对最末位元素的最长的子序列。如果子序列的长度相同，那么最末位的元素较小的在之后会更加有优势，因此反过来针对相同长度，末尾元素较小会更加有优势。dp[i]表示长度位i+1的上升子序列中末尾元素的最小值（不存在的话就时INF）更新数组：开始将dp初始化为INF，然后由前到后逐个考虑数列的元素，对于每个aj，如果i=0或者dp[i-1]&lt;aj的话，就用dp[i]=min(dp[i],a[j])进行更新。最终找到dp[i]&lt;INF的最大值的i+1就是结果。直接实现时间还是，但还可以优化。首先dp数列中除INF之外是单调递增的，因此可以知道对于每个aj最多只需要一次更新。对于这次更新究竟在什么位置，不必逐个遍历，可以利用二分搜索，这样时间就变成了。int dp[MAXN];int solve(){ fill(dp,dp+n,INF); for(int i=0;i&lt;n;i++) *lower_bound(dp,dp+n,a[i])=a[i]; return lowwer_bound(dp,dp+n,INF)-dp;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态规划----最长公共子序列]]></title>
    <url>%2F2019%2F05%2F16%2F81332834%2F</url>
    <content type="text"><![CDATA[给定连个字符串s1s2… …sn和t1t2… …tn。求出这两个字符串最长的公共子序列的长度。字符串s1s2… …sn的子序列可以表示为si1si2… …sim(i1&lt;i2&lt;… …&lt;sim)的序列。（1&lt;=n,m&lt;=1000)dp[i][j]表示s1… … si和t1… …tj对应的LCS的长度。当s[i+1]==t[i+1]时，dp[i+1][j+1] = max(dp[i][j]+1, dp[i+1][j], dp[i][j+1])；//其实只要dp[i+1][j+1]=dp[i][j]+1 就可以了。其它情况，dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])； #include&lt;cstdio&gt;using namespace std;const int MAXN=1001;int char s[MAXN],t[MAXN];int n,m;int solve(){ for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) { if(s[i-1]==t[i-1]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); } return dp[n][m];}int main(){ scanf(“%d%d”,&amp;n,&amp;m); scanf(“%s%s”,s,t); printf(“%d”,solve); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态规划----背包问题]]></title>
    <url>%2F2019%2F05%2F16%2F81327068%2F</url>
    <content type="text"><![CDATA[0-1背包之一n个重量价值分别为wi，vi的物品。从这些物品中挑选出总重量不超过W的物品，求价值总和的最大值。限制条件{n(1,100)、wi,vi(1,100)、W(1,1000)}枚举+dfs：#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;int w[MAXN],v[MAXN];int n;int solve(int i,int j){ int re; if(i==n) re=0; else if(j&lt;w[i]) re=solve(i+1,j); else re=max(solve(i+1,j),solve(i+1,j-w[i])+v[i]); return re;}int main(){ int i,W; scanf(“%d%d”,&amp;n,&amp;W); for(i=0;i&lt;n;i++) scanf(“%d%d”,w[i],v[i]); printf(“%d\n”,solve(0,W)); return 0;}由于dfs会出现很多重复计算的情况；剪枝后；int dp[MAXN][MAXN];int solve(int i,int j){ int re; if(dp[i][j]) re = dp[i][j]; else if(i==n) re = 0; else if(j&lt;w[i]) re = solve(i+1,j); else re = max(solve(i+1,j),solve(i+1,j-w[i])+v[i]); return re=dp[i][j];}动态规划递推1：dp[i][j]表示考虑第i个物品后w用j的最优挑选方案dp[n][j]=0；当j&lt;w[j]时，dp[i][j]=dp[i+1][j]；其它，dp[i][j]=max(dp[i+1][j],dp[i+1][j-w[i]]+v[i])；int dp[MAXN][MAXN_W];int solve(){ for(int i=n-1;i&gt;=0;i–) for(int j=0;j&lt;=w;j++) if(j&lt;w[i]) dp[i][j]=dp[i+1][j]; else dp[i][j]=max(dp[i+1][j],dp[i+1][j-w[i]]+v[j]); return dp[0][w];}递推2：dp[i+1][j]表示从前i个物品中选出总重量不超过j的物品时总价值的最大值dp[0][j]=0；当j&lt;w[i]时，dp[i+1][j]=dp[i][j]；其它情况，dp[i+1][j]=max(dp[i][j],dp[i][j-w[i]]+v[i])；int solve(){ for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=w;j++) if(j&lt;w[i]) dp[i+1][j]=dp[i][j]; else dp[i+1][j]=max(dp[i+1][j],dp[i+1][j-w[i]]+v[i]); return dp[n][w];}状态转移：“前 i 个物品中挑选总重量不超过 j 时的状态” 向 “前 i+1 个物品中选取总重不超过 j ” 和 “前 j+1 个物品中选取总重不超过 j+w[i] 时的状态” 转移。void solve(){ for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=w;j++) { dp[i+1][j]=max(dp[i+1][j],dp[i][j]); if(j+w[i]&lt;=W) dp[i+1][j+w[i]] = max(dp[i+1][j+w[i]],dp[i][j]+v[i]); } return dp[n][W];}完全背包有n种重量和价值分别为wi，vi的物体。从这些物品中挑选总重量不超过W的物品，求出挑选物品价值总和的最大值。限制条件：{ n[1,100] 、wi,vi[1,1000]、W[1,10000]) }dp[i+1][j]表示从前 i 种物品中挑选总重量不超过 j 时总价值的最大值。dp[0][j]=0；dp[i+1][j] = max{ dp[ i-kw[i]]+kv[i] | 0&lt;=k }；int dp[MAXN][MAXN];int solve(){ for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=W;j++) for(int k=0;kw[i]&lt;=j;k++) dp[i+1][j] = max(dp[i+1][j],dp[i][j-kw[i]]+kv[i]); return dp[n][w];}上面的程序三层循环。其实在计算每一行的结果的时候都重复计算了，j=j+w[i]，在dp[i][j] 计算dp[i][j`-kw[i]]+kv[i]后，会计算dp[i][j-k`w[i]]+k*v[i]，而当k=k-1前面的计算就是和后面的计算是一样的。也就是当k&gt;0的时候的计算都是重复计算。 dp[i+1][j] = max{ dp[i][j-kw[i]]+kv[i] | 0&lt;=k }​​​​​​​ = max( dp[i][j],max{ dp[i][j-kw[i]]+kv[i] | 1&lt;=k ) = max( dp[i][j],max{ dp[i][(j-w[i])-kw[i]]+kv[i] | 0&lt;=k }+v[i]) = max( dp[i][j],dp[i+1][j-w[i]]+v[i])#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=101;int dp[MAXN][MAXN];int v[MAXN],w[MAXN];int n,W;int solve(){ for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=W;j++) if(j&lt;w[i]) dp[i+1][j]=dp[i][j]; else dp[i+1][j]=max( dp[i][j],dp[i+1][j-w[i]]+v[i] ); return dp[n][W];}int main(){ scanf(“%d%d”,&amp;n,&amp;W); for(int i=0;i&lt;n;i++) scanf(“%d%d”,&amp;w[i],&amp;v[i]); printf(“%d\n”,solve()); return 0;}使用一维数组实现0-1背包和完全背包#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=101;int dp[MAXN];int w[MAXN],v[MAXN];int n,W;int solve_01(){ for(int i=0;i&lt;n;i++) for(int j=W;j&gt;=w[i];j–) dp[j]=max(dp[j],dp[j-w[i]]+v[i]); return dp[W];}int solve_com(){ for(int i=0;i&lt;n;i++) for(int j=w[i];j&lt;=W;j++) dp[j]=max(dp[j],dp[j-w[i]]+v[i]); return dp[W];}int main(){ scanf(“%d%d”,&amp;n,&amp;W); for(int i=0;i&lt;n;i++) scanf(“%d%d”,&amp;w[i],&amp;v[i]); char op[10]; scanf(“%s”,op); if(op[0]==’0’) printf(“%d\n”,solve_01()); else printf(“%d\n”,solve_com()); return 0;} 0-1背包之二有n个重量和价值分别为wi,vi的物品。从这些物品中挑选总重量不超过W的物品，求所有挑选方案中价值总和最大值。限制条件：{ n[1,n]、wi[1,1e7]、vi[1,100]、W[1,1e9] }；因为限制条件的变化，如果方法不变的话dp数组中的j最大为1e9，内存是超级大的，因此可以试着改变DP的对象。之前的方法中，是真多重量，这里不妨针对价值计算最小的重量。dp[i+1][j]表示前i个物品中挑选出价值总和为j时总重量的最小值（不存在时就是一个充分大的数值INF）。dp[0][0]=0；dp[0][j]=INF；dp[i+1][j]=min(dp[i][j],dp[i][j-v[i]]+w[i])； #include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100,MAXV=100,INF=1e9+1;int dp[MAXN+1][MANXMANV+1];int w[MAXN],v[MAXN];int n,W;int solve(){ fill(dp[0],dp[0]+MAXNMAXV+1,INF); dp[0][0]=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=MAXNMAXV;j++) if(j&lt;v[i]) dp[i+1][j]=dp[i][j]; else dp[i+1][j]=min(dp[i][j],dp[i][j-v[i]]+w[i]); int re=0; for(int i=0;i&lt;=MAXNMAXV;i++) if(dp[n][i]&lt;=W) re = i; return re;}int main(){ scanf(“%d%d”,&amp;n,&amp;W); for(int i=0;i&lt;n;i++) scanf(“%d%d”,&amp;w[i],&amp;v[i]); printf(“%d\n”,solve()); return 0;}多重背包有n种不同大小的数组ai，每种各mi个。判断是否可以从这些数组之中选出若干使他们的和恰好为k。限制条件{ n[1,100]、ai,mi[1,100000]、k[1,100000] }dp[i+1][j]表示前i种数加和得到j时第i种数最多能剩余多少个（不能加和得到i的情况下为-1）dp[i][j]&gt;=0时，dp[i+1][j]=m[i]；j&lt;a[i]或者dp[i+1][j-a[i]]&lt;=0时，dp[i+1][j]=-1；其它情况，dp[i+1][j]=dp[i+1][j-a[i]]-1； #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1e5+1;int a[MAXN],m[MAXN];int dp[MAXN];int n,k;void solve(){ memset(dp,-1,sizeof(dp)); dp[0]=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=k;j++) if(dp[j]&gt;=0) dp[j]=m[i]; else if(j&lt;a[i]||dp[j-a[i]]&lt;=0) dp[j]=-1; else dp[j]=dp[j-a[i]]-1; if(dp[k]&gt;=0)printf(“Yes\n”); else printf(“No\n”);}int main(){ scanf(“%d%d”,&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf(“%d”,a[i]); for(int i=0;i&lt;n;i++) scanf(“%d”,m[i]); solve(); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[贪心算法---codeforce680D Bear and Tower of Cubes]]></title>
    <url>%2F2019%2F05%2F16%2F81321147%2F</url>
    <content type="text"><![CDATA[D. Bear and Tower of Cubestime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLimak is a little polar bear. He plays by building towers from blocks. Every block is a cube with positive integer length of side. Limak has infinitely many blocks of each side length.A block with side a has volume a3. A tower consisting of blocks with sides a1, a2, …, ak has the total volume a13 + a23 + … + ak3.Limak is going to build a tower. First, he asks you to tell him a positive integer X — the required total volume of the tower. Then, Limak adds new blocks greedily, one by one. Each time he adds the biggest block such that the total volume doesn’t exceed X.Limak asks you to choose X not greater than m. Also, he wants to maximize the number of blocks in the tower at the end (however, he still behaves greedily). Secondarily, he wants to maximize X.Can you help Limak? Find the maximum number of blocks his tower can have and the maximum X ≤ m that results this number of blocks.InputThe only line of the input contains one integer m (1 ≤ m ≤ 1015), meaning that Limak wants you to choose X between 1 and m, inclusive.OutputPrint two integers — the maximum number of blocks in the tower and the maximum required total volume X, resulting in the maximum number of blocks.ExamplesinputCopy48outputCopy9 42inputCopy6outputCopy6 6每一次选择最大的x3和次大的x3计算两个中更优的那个，贪心加dfs。#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int MAXN=1e5+10;ll x3[MAXN];pair&lt;ll,ll&gt;ans(0,0);void dfs(ll m,ll cnt,ll t){ if(!m){ ans=max(ans,make_pair(cnt,t)); return ; } int q=upper_bound(x3+1,x3+100002,m)-x3; q–; dfs(m-x3[q],cnt+1,t+x3[q]); if(q&gt;1)dfs(x3[q]-1-x3[q-1],cnt+1,t+x3[q-1]);}int main(){ ll m; for(ll i=1;i&lt;=100001;i++) x3[i]=iii; scanf(“%I64d”,&amp;m); dfs(m,0,0); printf(“%I64d %I64d\n”,ans.first,ans.second);}]]></content>
  </entry>
  <entry>
    <title><![CDATA[贪心算法----Fence Repair(POJ 3253)]]></title>
    <url>%2F2019%2F05%2F16%2F81298918%2F</url>
    <content type="text"><![CDATA[Fence RepairTime Limit: 2000MS Memory Limit: 65536KTotal Submissions: 60866 Accepted: 20067DescriptionFarmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.InputLine 1: One integer N, the number of planks Lines 2..N+1: Each line contains a single integer describing the length of a needed plankOutputLine 1: One integer: the minimum amount of money he must spend to make N-1 cutsSample Input3858Sample Output34切割方法最优就是每一次都切割两个最大的，倒过来就是将最小的接上 ，然后再将接好的替换原来的两根，再找最小的。形成一棵二叉树，二叉树的木板长度x节点深度的总和就是最优。#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=2e4+10;int L[N];int main(){ int n,i; long long total=0; scanf(“%d”,&amp;n); for(i=0;i&lt;n;i++) scanf(“%d”,&amp;L[i]); sort(L,L+n); for(i=0;i&lt;n-1;i++) { total+=(L[i]+L[i+1]); L[i+1]+=L[i]; for(int j=i+2;j&lt;n&amp;&amp;L[j]&lt;L[j-1];j++) swap(L[j],L[j-1]); } printf(“%lld\n”,total); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[线段树拓展----HDU 6315 Naive Operations]]></title>
    <url>%2F2019%2F05%2F16%2F81296350%2F</url>
    <content type="text"><![CDATA[Naive OperationsTime Limit: 6000/3000 MS (Java/Others) Memory Limit: 502768/502768 K (Java/Others)Total Submission(s): 2623 Accepted Submission(s): 1143Problem DescriptionIn a galaxy far, far away, there are two integer sequence a and b of length n.b is a static permutation of 1 to n. Initially a is filled with zeroes.There are two kind of operations:1. add l r: add one for al,al+1…ar2. query l r: query ∑ri=l⌊ai/bi⌋InputThere are multiple test cases, please read till the end of input file.For each test case, in the first line, two integers n,q, representing the length of a,b and the number of queries.In the second line, n integers separated by spaces, representing permutation b.In the following q lines, each line is either in the form ‘add l r’ or ‘query l r’, representing an operation.1≤n,q≤100000, 1≤l≤r≤n, there’re no more than 5 test cases.OutputOutput the answer for each ‘query’, each one line.Sample Input5 121 5 2 4 3add 1 4query 1 4add 2 5query 2 5add 3 5query 1 5add 2 4query 1 4add 2 5query 2 5add 2 2query 1 5Sample Output112446题目大意：两个数组，长度都为n，b数组元素属于[1,n],每个元素都不相同，a数组初始都为0，输入n,q,然后输入b数组，再输入q行，两种操作，add表示a数组[i,j]每个元素加一，q表示 计算[i,j]的∑ri=l⌊ai/bi⌋。分析：每个元素增一对整体的共享都是不相同的，相当于每一个b元素都对应一种进制，查询的时候计算区间和。建设线段树的时候用两个元素俩判断性质：maxa表示区间最大的a元素的值，minb表示区间最小的b元素的值，建树的时候，minb表示区间最小，mina都为0，更新的时候判断maxa&gt;=minb？是则向下产生影响，如果是叶子节点那就对总数产生影响。其它操作都是基本的区间更新区间查询的操作。#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int MAXN=1e5+10;struct{ int l,r,lazy; ll maxa,minb,cnt;}tree[MAXN&lt;&lt;2];ll b[MAXN];void PushUp(int i){//求子节点和 tree[i].minb=min(tree[i&lt;&lt;1].minb,tree[i&lt;&lt;1|1].minb); tree[i].maxa=max(tree[i&lt;&lt;1].maxa,tree[i&lt;&lt;1|1].maxa); tree[i].cnt=tree[i&lt;&lt;1].cnt+tree[i&lt;&lt;1|1].cnt;}void BuildTree(int i,int L,int R){//建立一颗[L,R]的树 tree[i].l=L; tree[i].r=R; tree[i].lazy=0; tree[i].maxa=0; tree[i].cnt=0; if(L==R){ tree[i].minb=b[L]; return ; } BuildTree(i&lt;&lt;1,L,(L+R)&gt;&gt;1); BuildTree(i&lt;&lt;1|1,((L+R)&gt;&gt;1)+1,R); tree[i].minb=min(tree[i&lt;&lt;1].minb,tree[i&lt;&lt;1|1].minb); return ;}void PushDown(int i){//判断延迟父节点的延迟变量，作用到子节点 if(tree[i].lazy){ tree[i&lt;&lt;1].maxa+=tree[i].lazy; tree[i&lt;&lt;1|1].maxa+=tree[i].lazy; tree[i&lt;&lt;1].lazy+=tree[i].lazy; tree[i&lt;&lt;1|1].lazy+=tree[i].lazy;//更新左右子节点的lazy tree[i].lazy=0;//将lazy传给子节点后字节归零 }}void Update(int L,int R,int i){//更新[L,R] if(L&lt;=tree[i].l&amp;&amp;R&gt;=tree[i].r){ tree[i].maxa++; if(tree[i].maxa&lt;tree[i].minb) { tree[i].lazy++; return ; } if(tree[i].l==tree[i].r&amp;&amp;tree[i].maxa&gt;=tree[i].minb) { tree[i].cnt++; tree[i].minb+=b[tree[i].l]; return ; } } PushDown(i);//否则，将i的延迟变化量作用到左右子节点上 if(L&lt;=tree[i&lt;&lt;1].r) Update(L,R,i&lt;&lt;1); if(R&gt;=tree[i&lt;&lt;1|1].l) Update(L,R,i&lt;&lt;1|1); PushUp(i);}ll Query(int L,int R,int i){//查询[L,R]区间，从i开始查询 if(L&lt;=tree[i].l&amp;&amp;R&gt;=tree[i].r) return tree[i].cnt; PushDown(i); ll t=0; if(L&lt;=tree[i&lt;&lt;1].r) t+=Query(L,R,i&lt;&lt;1); if(R&gt;=tree[i&lt;&lt;1|1].l) t+=Query(L,R,i&lt;&lt;1|1); return t;}int main(){ int n,q,l,r; while(~scanf(“%d%d”,&amp;n,&amp;q)) { for(int i=1;i&lt;=n;i++) scanf(“%lld”,&amp;b[i]); BuildTree(1,1,n); while(q–) { char op[6]; scanf(“%s”,op); scanf(“%d%d”,&amp;l,&amp;r); if(op[0]==’q’) printf(“%lld\n”,Query(l,r,1)); else Update(l,r,1); } } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Saruman`s Army(POJ 3069)]]></title>
    <url>%2F2019%2F05%2F16%2F81293215%2F</url>
    <content type="text"><![CDATA[Saruman’s ArmyTime Limit: 1000MS Memory Limit: 65536KTotal Submissions: 13974 Accepted: 7011DescriptionSaruman the White must lead his army along a straight path from Isengard to Helm’s Deep. To keep track of his forces, Saruman distributes seeing stones, known as palantirs, among the troops. Each palantir has a maximum effective range of R units, and must be carried by some troop in the army (i.e., palantirs are not allowed to “free float” in mid-air). Help Saruman take control of Middle Earth by determining the minimum number of palantirs needed for Saruman to ensure that each of his minions is within R units of some palantir.InputThe input test file will contain multiple cases. Each test case begins with a single line containing an integer R, the maximum effective range of all palantirs (where 0 ≤ R ≤ 1000), and an integer n, the number of troops in Saruman’s army (where 1 ≤ n ≤ 1000). The next line contains n integers, indicating the positions x1, …, xn of each troop (where 0 ≤ xi ≤ 1000). The end-of-file is marked by a test case with R = n = −1.OutputFor each test case, print a single integer indicating the minimum number of palantirs needed.Sample Input0 310 20 2010 770 30 1 7 15 20 50-1 -1Sample Output24将点从小到大排序，从左边开始选点，排除覆盖的点，再从新开始选点。#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){ int r,n,d=0; int data[1010]; while(cin&gt;&gt;r&gt;&gt;n&amp;&amp;(r!=-1||n!=-1)) { d++; for(int i=0;i&lt;n;i++) cin&gt;&gt;data[i]; sort(data,data+n); int i=0; int a=data[0]; int b=data[n-1]; int total=0; while(i&lt;n&amp;&amp;a&lt;=b) { while(i&lt;n&amp;&amp;data[i]&lt;=a+r)i++; a=data[i-1]; while(i&lt;n&amp;&amp;data[i]&lt;=a+r)i++; total++; if(i&lt;n)a=data[i]; } cout&lt;&lt;total&lt;&lt;endl; } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[字典序最小问题 Best Cow Line (POJ 3617)]]></title>
    <url>%2F2019%2F05%2F16%2F81292522%2F</url>
    <content type="text"><![CDATA[Best Cow LineTime Limit: 1000MS Memory Limit: 65536KTotal Submissions: 32184 Accepted: 8533DescriptionFJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges.The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names.FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order.Given the initial order of his cows, determine the least lexicographic string of initials he can make this way.Input Line 1: A single integer: N Lines 2..N+1: Line i+1 contains a single initial (‘A’..’Z’) of the cow in the ith position in the original lineOutputThe least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line.Sample Input6ACDBCB先对第一个字母和最后一个字母进行比较，取较小的那个，如果相等对顺序序列和逆序序列进行比较，取小的那头。#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int main(){ char cow[2010],ne[2010]; int n; scanf(“%d”,&amp;n); getchar(); for(int i=0;i&lt;n;i++){ scanf(“%c”,&amp;cow[i]); getchar(); } int a=0,b=n-1,j=0; while(a&lt;=b) { bool cmp=false; for(int i=0;a+i&lt;=b;i++) { if(cow[a+i]&lt;cow[b-i]) { cmp=false; break; } else if(cow[a+i]&gt;cow[b-i]) { cmp=true; break; } } if(cmp) { ne[j++]=cow[b–]; } else { ne[j++]=cow[a++]; } } for(int i=0;i&lt;n;i++){ printf(“%c”,ne[i]); if((i+1)%80==0&amp;&amp;i&lt;n-1) printf(“\n”); }}]]></content>
  </entry>
  <entry>
    <title><![CDATA[RMQ]]></title>
    <url>%2F2019%2F05%2F16%2F81241132%2F</url>
    <content type="text"><![CDATA[RMQ（Range Minimum/Maximum Query），即区间最值查询，是指这样一个问题：对于长度为n的数列A，回答若干次询问RMQ(i,j)，返回数列A中下标在区间[i,j]中的最小/大值。本文介绍一种比较高效的ST算法解决这个问题。ST（Sparse Table）算法可以在O(nlogn)时间内进行预处理，然后在O(1)时间内回答每个查询。 1）预处理设A[i]是要求区间最值的数列，F[i, j]表示从第i个数起连续2^j个数中的最大值。（DP的状态）例如：A数列为：3 2 4 5 6 8 1 2 9 7F[1，0]表示第1个数起，长度为2^0=1的最大值，其实就是3这个数。同理 F[1,1] = max(3,2) = 3, F[1，2]=max(3,2,4,5) = 5，F[1，3] = max(3,2,4,5,6,8,1,2) = 8;并且我们可以容易的看出F[i,0]就等于A[i]。（DP的初始值） 我们把F[i，j]平均分成两段（因为F[i，j]一定是偶数个数字），从 i 到i + 2 ^ (j - 1) - 1为一段，i + 2 ^ (j - 1)到i + 2 ^ j - 1为一段(长度都为2 ^ (j - 1))。于是我们得到了状态转移方程F[i, j]=max（F[i，j-1], F[i + 2^(j-1)，j-1]）。 2)查询假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询1，2，3，4，5，我们可以查询1234和2345）。因为这个区间的长度为j - i + 1,所以我们可以取k=log2( j - i + 1)，则有：RMQ(i, j)=max{F[i , k], F[ j - 2 ^ k + 1, k]}。举例说明，要求区间[1，5]的最大值，k = log2（5 - 1 + 1）= 2，即求max(F[1, 2]，F[5 - 2 ^ 2 + 1, 2])=max(F[1, 2]，F[2, 2])；void ST(int n) { for (int i = 1; i &lt;= n; i++) dp[i][0] = A[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) { for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) { dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); } }}int RMQ(int l, int r) { int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= r - l + 1) k++; return max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);}转载博客：https://blog.csdn.net/qq_31759205/article/details/75008659]]></content>
  </entry>
  <entry>
    <title><![CDATA[牛客2018年第二次acm暑期培训----H-Diff-prime Pairs]]></title>
    <url>%2F2019%2F05%2F16%2F81238384%2F</url>
    <content type="text"><![CDATA[题目描述：链接：https://www.nowcoder.com/acm/contest/141/H来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 262144K，其他语言524288K64bit IO Format: %lld题目描述Eddy has solved lots of problem involving calculating the number of coprime pairs within some range. This problem can be solved with inclusion-exclusion method. Eddy has implemented it lots of times. Someday, when he encounters another coprime pairs problem, he comes up with diff-prime pairs problem. diff-prime pairs problem is that given N, you need to find the number of pairs (i, j), where and are both prime and i ,j ≤ N. gcd(i, j) is the greatest common divisor of i and j. Prime is an integer greater than 1 and has only 2 positive divisors.Eddy tried to solve it with inclusion-exclusion method but failed. Please help Eddy to solve this problem.Note that pair (i1, j1) and pair (i2, j2) are considered different if i1 ≠ i2 or j1 ≠ j2.输入描述:Input has only one line containing a positive integer N.1 ≤ N ≤ 107输出描述:Output one line containing a non-negative integer indicating the number of diff-prime pairs (i,j) where i, j ≤ N 示例1输入3输出2示例2输入5输出6#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int MAXSIZE=1e7+10;int Mark[MAXSIZE&lt;&lt;2];int prime[MAXSIZE];ll sum(ll n){ if(n%2==0)return (n+1)(n&gt;&gt;1); else return ((n+1)&gt;&gt;1)n;}int Prime(int n){ int index = 0; memset(Mark,0,sizeof(Mark)); for(int i = 2; i &lt;= n; i++) { if(Mark[i] == 0){ prime[index++] = i; } for(int j = 0; j &lt; index &amp;&amp; prime[j] i &lt;= n; j++) { Mark[i prime[j]] = 1; if(i % prime[j] == 0){ break; } } } return index;}int main(){ int n,total,i=2; ll s=0; ios::sync_with_stdio(false); cin&gt;&gt;n; total=Prime(n); s+=sum((ll)total-1)2; while(total&gt;=2){ if(prime[total-1]i&lt;=n){ s+=sum((ll)total-1)*2; i++; } else total–; } cout&lt;&lt;s&lt;&lt;endl; return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[牛客2018年第二次多校培训----A-run]]></title>
    <url>%2F2019%2F05%2F16%2F81238293%2F</url>
    <content type="text"><![CDATA[题目描述：链接：https://www.nowcoder.com/acm/contest/140/A来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述White Cloud is exercising in the playground.White Cloud can walk 1 meters or run k meters per second.Since White Cloud is tired,it can’t run for two or more continuous seconds.White Cloud will move L to R meters. It wants to know how many different ways there are to achieve its goal.Two ways are different if and only if they move different meters or spend different seconds or in one second, one of them walks and the other runs.输入描述:The first line of input contains 2 integers Q and k.Q is the number of queries.(Q&lt;=100000,2&lt;=k&lt;=100000)For the next Q lines,each line contains two integers L and R.(1&lt;=L&lt;=R&lt;=100000)输出描述:For each query,print a line which contains an integer,denoting the answer of the query modulo 1000000007. 示例1输入3 33 31 41 5输出2711#include &lt;iostream&gt;#include &lt;stdio.h&gt;#define MOD 1000000007using namespace std;int main(){ long long a[100005],b[100005]; int q,k,l,r; cin&gt;&gt;q&gt;&gt;k; b[0]=0; for(int i=1;i&lt;k;i++) { a[i]=1; b[i]=b[i-1]+a[i]; } a[k]=2;b[k]=b[k-1]+a[k]; a[k+1]=3;b[k+1]=b[k]+a[k+1]; for(int i=k+2;i&lt;100005;i++) { a[i]=(a[i-1]+a[i-k-1])%MOD; b[i]=(b[i-1]+a[i])%MOD; } for(int i=0;i&lt;q;i++) { cin&gt;&gt;l&gt;&gt;r; printf(“%lld\n”,(MOD+b[r]-b[l-1])%MOD); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态规划（dp)----hdu1024 Max Sum Plus Plus]]></title>
    <url>%2F2019%2F05%2F16%2F81232855%2F</url>
    <content type="text"><![CDATA[题目描述：Max Sum Plus PlusTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 36429 Accepted Submission(s): 12963Problem DescriptionNow I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem.Given a consecutive number sequence S1, S2, S3, S4 … Sx, … Sn (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ Sx ≤ 32767). We define a function sum(i, j) = Si + … + Sj (1 ≤ i ≤ j ≤ n).Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i1, j1) + sum(i2, j2) + sum(i3, j3) + … + sum(im, jm) maximal (ix ≤ iy ≤ jx or ix ≤ jy ≤ jx is not allowed).But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(ix, jx)(1 ≤ x ≤ m) instead. ^_^InputEach test case will begin with two integers m and n, followed by n integers S1, S2, S3 … Sn.Process to the end of file.OutputOutput the maximal summation described above in one line.Sample Input1 3 1 2 32 6 -1 4 -2 3 -2 3Sample Output68题目大意：先输入两个数m,n，n表示接下来输入一个含有n个元素的序列，m表示在序列中，找到m个连续子段，相互不相交不包含。输出m个子段和最大的子段的和。题目分析：dp解决就是将问题缩小，求n个元素的序列中m个子段，可以通过一种方式将问题转换为求m-1个子段，或者求n-1个元素的子段中m个子段。就会得到求n序列m子段就是求n-1序列中m-1子段与n-1序列总m子段的最大值，前者表示将在n-1序列中找到m-1子段的最大值再加上最后一个元素单独成一段就是n个元素中m个子段，后者表示在n-1序列中m个子段的最后一个段中加上第n个元素。两者加起来就是n序列m子段的全部情况了。实现：用一个二维数组进行模拟，i行表示分成i段，j列表示j个元素的序列。dp[i][j]表示包含第j个元素在内的j个元素序列分成i段的子段和。 假设我们要球的序列m=4，那么我们要求的就是左下图最下面那一行的最大值，然后我们删除没有用的元素得到右下图。 其实我们要求的元素就只有中间类似的几条对角线中的元素。并且求每行元素都只与其前面那行元素有联系，因此我们要保存的元素就只有两行。然后我们再通过t=1-t的变化滚动数组得到第一行，然后得到第二行… …直到得到第m行。 再计算过程中由于只要得到中间几个元素，因此要确定每一次计算的右边界。如下图得到第i行的边界n-m-i：代码如下：#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=1e6+10;int dp[2][MAXN],d[MAXN];int Max(int x,int y){return x&gt;y?x:y;}int main(){ ios::sync_with_stdio(false); int i,j,m,n,maxn,re,t=1; while(cin&gt;&gt;m&gt;&gt;n){ dp[0][0]=dp[1][0]=d[0]=0;//初始化 for(i=1;i&lt;=n;i++){ dp[0][i]=dp[1][i]=0;//初始化 cin&gt;&gt;d[i]; } for(i=1;i&lt;=m;i++){//左界 dp[t][i]=dp[1-t][i-1]+d[i]; maxn=dp[1-t][i-1]; for(j=i+1;j&lt;=n-m+i;j++){//右界 maxn=Max(maxn,dp[1-t][j-1]);//得到上一行j之前的最大值 dp[t][j]=Max(maxn,dp[t][j-1])+d[j]; } t=1-t;//滚动 } t=1-t; for(i=m+1,re=dp[t][m];i&lt;=n;i++) re=Max(re,dp[t][i]); cout&lt;&lt;re&lt;&lt;endl; } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[贪心算法----nyoj 14 会场安排]]></title>
    <url>%2F2019%2F05%2F16%2F81217739%2F</url>
    <content type="text"><![CDATA[题目详情：会场安排问题时间限制：3000 ms | 内存限制：65535 KB描述学校的小礼堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校小礼堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。输入第一行是一个整型数m(m&lt;100)表示共有m组测试数据。每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。随后的n行，每行有两个正整数Bi,Ei(0&lt;=Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;=Ei)输出对于每一组输入，输出最多能够安排的活动数量。每组的输出占一行样例输入221 1010 1131 1010 1111 20样例输出12解题思路：先将数据进行排序，根据时间段的结束时间从小到大安排，然后根据开始时间从大到小安排，最后从序列中找到第一个时间段，再将一天的开始时间设置为前面那段时间的结束时间，再找下面的时间段，知道所有的时间段都找完。#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int MAXN=1e4+10;struct Time{ int b,e;};bool operator&lt;(Time a,Time b){ if(a.e==b.e) return a.b&gt;=b.b; return a.e&lt;b.e;}int main(){ ios::sync_with_stdio(false);//关闭同步，节约时间 int m,n,i,count,first; cin&gt;&gt;m; while(m–){ cin&gt;&gt;n; vector&lt;Time&gt; t(n); for(i=0;i&lt;n;i++){ cin&gt;&gt;t[i].b&gt;&gt;t[i].e; } sort(t.begin(),t.end()); first=-1;i=0;count=0; while(i&lt;n){ if(t[i].b&gt;first){ count++; first=t[i].e; } i++; } cout&lt;&lt;count&lt;&lt;endl; } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[树状数组解决区间更新单点查询----hdu 1556 Color the ball]]></title>
    <url>%2F2019%2F05%2F16%2F81193439%2F</url>
    <content type="text"><![CDATA[题目详情： Color the ballTime Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 26931 Accepted Submission(s): 13049Problem DescriptionN个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？Input每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。当N = 0，输入结束。Output每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。Sample Input31 12 23 331 11 21 30Sample Output1 1 13 2 1 题目分析：其实这个题目根本不需要用到树状数组，完全可以用简单的技巧解出来。代码如下： #include “stdio.h”int main(){ int n,i,l,s,r; while(scanf(“%d”,&amp;n),n) { int c[100001]={0}; i=n; s=0; while(i–) { scanf(“%d %d”,&amp;l,&amp;r); c[l]++; c[r+1]–; } for(i=1;i&lt;n;i++) { s+=c[i]; printf(“%d “,s); } printf(“%d\n”,s+c[n]); } return 0;}虽然能这样解，但是下次遇到不是查询所有点而是查询，更新一次查询一次，并且查询不是连续的就不能直接这样了。树状数组是这样的，因为我们要求的是每一个点的和所以只要将更新区间的c[l]加上增量然后c[r+1]减去增量就可以了。如下图 为什么会有这样的效果呢，每一次更新都会将后面+=lowbit（）的下标更新,c[i]+add后面相应的位置都会+add，然后再c[j]-add,后面的相应位置都会-add。下面是树状数组的代码：#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=1e5+10;int s[MAXN];int n;int lowbit(int x){return x&amp;(-x);}int sum(int x){ int sum=0; while(x){ sum+=s[x]; x-=lowbit(x); } return sum;}void add(int x){ while(x&lt;=MAXN){ s[x]++; x+=lowbit(x); }}void sub(int x){ while(x&lt;=MAXN){ s[x]–; x+=lowbit(x); }}int main(){ int a,b; while(~scanf(“%d”,&amp;n)&amp;&amp;n!=0){ memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++){ scanf(“%d%d”,&amp;a,&amp;b); add(a);//在做端点加 sub(b+1);//在有端点后面一个位置减 } for(int i=1;i&lt;=n;i++){ printf(“%d”,sum(i)); if(i!=n)printf(“ “); } printf(“\n”); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[codeblocks调试问题--单步调试遇到breakpoint不停---不能单步调试--运行按钮是灰色但是没有dos窗口]]></title>
    <url>%2F2019%2F05%2F16%2F81192903%2F</url>
    <content type="text"><![CDATA[今天晚上调试的时候可能不小心改了设置，还是其它原因，codeblocks突然遇到breakpoint不停了，然后百度了一下，大部分是说project创建的问题，感觉和自己的问题不同，我的问题是所有的project都不能单步调试。然后在seting-&gt;debug设置中找了一会都没有找到相应的设置，然后我就到debug中找到了debug-&gt;active debuggers-&gt;gdb/cdb debugger:default,勾选之后发现可以调试了，然后决定用博客记录下来，希望能给遇到相似的问题的同学也能得到帮助。以前刚用codeblocks编写程序的时候发现也不能但不单步调试，单步调试的时候提示下面一样的信息，其实下面的信息就是解决方法，下面大概意思就是没有但不调试的软件。 点开setting-&gt;debugger 上面的红色框中就是你要选择调试器的路径，点开选择路径，如果codeblocks软件是安装在C:\Program Files (x86)下面的话就是下面图片中所示的路径了，然后选择gdb32.exe，点击ok保存就可以调试了。（对了，还要选择上图中的GDB选项） 有时候调试器出错了，虽然你看不到程序的运行窗口，但是程序其实是在运行的。并且你是不可以再点击运行按钮运行程序的，这个时候就可以打开任务管理器，关闭相应的任务了，一般关闭想下图所示的那样的图标一样的任务就可以了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[线段树 || 树状数组解决区间更新区间查询问题----poj 3468 百练 3439 A Simple Problem with Integers]]></title>
    <url>%2F2019%2F05%2F16%2F81173757%2F</url>
    <content type="text"><![CDATA[树状数组实现区间更新区间查询：要实现区间更新区间查询操作必须像这篇文章里面一样，引入一个数组a[]，区间加就只要在这个数组区间左加增量，区间右后一个位置减增量。下面公式org[]表示变化之前的数据。sum(x) = org[1] +… …+ org[x] + (a[1]) + (a[1]+a[2]) + … …+ (a[1]+… …a[x]) = org[1] +… …+ org[x] + x(a[1]) + (x-1)a[2] + … … + a[x] = org[1] +… …+ org[x] + (x+1)( a[1] +… …+a[x] ) - ( a[1] + 2a[2] +… …+ xa[x] )这其实就是三个数组org[i], a[i]和a[i]i的前缀和，org[i]的前缀和保持不变，事先就可以求出来，a[i]和a[i]i的前缀和是不断变化的，可以用两个树状数组来维护。线段树实现区间更新区间查询：需要引入一个add延迟变量，也就是每一次更新的时候我们只要将延迟变量作用到对应的区间而不要将增量作用到区间每一个元素，只有在查询的时候我们再将延迟变量向下作用产生； 题目描述：A Simple Problem with IntegersTime Limit: 5000MS Memory Limit: 131072K Total Submissions: 134669 Accepted: 41771 Case Time Limit: 2000MS DescriptionYou have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c“ means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b“ means querying the sum of Aa, Aa+1, … , Ab.OutputYou need to answer all Q commands in order. One answer in a line.Sample Input10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4Sample Output455915 题目大意：输入一点序列，输入几组测试数据，测试数据有更新和查询，更新Q i，j，表示查询[i,j]区间和，C i j a,表示更新区间[i,j]每个元素加a；树状数组实现代码：#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int MAXN=1e5+10;ll org[MAXN],a[MAXN],ai[MAXN];//org表示原数据，a表示增量，ai表示a[i]iint lowbit(int x){return x&amp;(-x);}ll add(ll d,int n,ll v){ while(n&lt;MAXN){ d[n]+=v; n+=lowbit(n); }}ll sum(ll d,int n){ ll s=0; while(n){ s+=d[n]; n-=lowbit(n); } return s;}int main(){ ios::sync_with_stdio(false); int i,N,Q,l,r,v; cin&gt;&gt;N&gt;&gt;Q; memset(a,0,sizeof(a)); memset(ai,0,sizeof(ai)); org[0]=0; for(i=1;i&lt;=N;i++){ cin&gt;&gt;org[i]; org[i]+=org[i-1]; } char op[2]; while(Q–){ cin&gt;&gt;op; if(op[0]==’Q’){ cin&gt;&gt;l&gt;&gt;r; ll sumr=org[r]+(r+1)sum(a,r)-sum(ai,r); ll suml=org[l-1]+(l)sum(a,l-1)-sum(ai,l-1); printf(“%lld\n”,sumr-suml); } else{ cin&gt;&gt;l&gt;&gt;r&gt;&gt;v; add(a,l,(ll)v); add(a,r+1,(ll)-v); add(ai,l,(ll)lv); add(ai,r+1,(ll)(r+1)(-v)); } } return 0;}线段树实现： #include&lt;iostream&gt;#include&lt;cstdio&gt;#define N1 200001#define ll long longusing namespace std;struct node{ ll left,right,value,lazy;}tree[4N1];//线段树int n,q;ll a[N1];void Sum(int i){//求子节点和 tree[i].value=tree[i&lt;&lt;1].value+tree[i&lt;&lt;1|1].value; return;}void BuildTree(int i,int L,int R){//建立一颗[L,R]的树 tree[i].left=L; tree[i].right=R; tree[i].lazy=0; if(L==R){ tree[i].value=a[L]; return ; } BuildTree(i&lt;&lt;1,L,(L+R)&gt;&gt;1); BuildTree(i&lt;&lt;1|1,((L+R)&gt;&gt;1)+1,R); Sum(i); return ;}void PushDown(int i){//判断延迟父节点的延迟变量，作用到子节点 if(tree[i].lazy){ tree[i&lt;&lt;1].value+=tree[i].lazy(tree[i&lt;&lt;1].right-tree[i&lt;&lt;1].left+1); tree[i&lt;&lt;1|1].value+=tree[i].lazy(tree[i&lt;&lt;1|1].right-tree[i&lt;&lt;1|1].left+1);//更新左右子节点的value tree[i&lt;&lt;1].lazy+=tree[i].lazy; tree[i&lt;&lt;1|1].lazy+=tree[i].lazy;//更新左右子节点的lazy tree[i].lazy=0;//将lazy传给子节点后字节归零 } return ;}void Update(int L,int R,ll s,int i){//更新[L,R]区间加s if(L&lt;=tree[i].left&amp;&amp;R&gt;=tree[i].right){ tree[i].value+=s(tree[i].right-tree[i].left+1);//如果区间更新包括i节点的区间，则更新value tree[i].lazy+=s;//将lazy加上更新量 return ; } PushDown(i);//否则，将i的延迟变化量作用到左右子节点上 if(L&lt;=tree[i&lt;&lt;1].right) Update(L,R,s,i&lt;&lt;1); if(R&gt;=tree[i&lt;&lt;1|1].left) Update(L,R,s,i&lt;&lt;1|1); Sum(i); return;}ll Query(int L,int R,int i){//查询[L,R]区间，从i开始查询 if(L&lt;=tree[i].left&amp;&amp;R&gt;=tree[i].right) return tree[i].value; PushDown(i); ll t=0; if(L&lt;=tree[i&lt;&lt;1].right) t+=Query(L,R,i&lt;&lt;1); if(R&gt;=tree[i&lt;&lt;1|1].left) t+=Query(L,R,i&lt;&lt;1|1); return t;}int main(){ int Q,N; ios::sync_with_stdio(false); cin&gt;&gt;Q&gt;&gt;N; for(int i=1;i&lt;=Q;i++)cin&gt;&gt;a[i]; BuildTree(1,1,Q); while(N–){ char op; int l,r; ll v; cin&gt;&gt;op; if(op==’Q’){ cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;Query(l,r,1)&lt;&lt;endl; } else{ cin&gt;&gt;l&gt;&gt;r&gt;&gt;v; Update(l,r,v,1); } } printf(“\n”); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[线段树+树状数组----hdoj 1166 敌兵布阵]]></title>
    <url>%2F2019%2F05%2F16%2F81162226%2F</url>
    <content type="text"><![CDATA[题目描述：敌兵布阵Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 117851 Accepted Submission(s): 49318Problem DescriptionC国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample OutputCase 1:63359题目分析：单点更新，求区间和，即可以用树状数组模板解决，也可以用线段树模板解决。树状数组：#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=50005;int d[maxn];//记录前缀和int lowbit(int x){return x&amp;(-x);}int Queries(int x,int y)//查询{ int sumx,sumy; sumx=sumy=0; while(x) { sumx+=d[x]; x-=lowbit(x); } while(y) { sumy+=d[y]; y-=lowbit(y); } return sumy-sumx;}void add(int x,int v)//更新{ while(x&lt;maxn) { d[x]+=v; x+=lowbit(x); }}int main(){ int T,i,x,y,v,n; char order[10]; scanf(“%d”,&amp;T); i=1; while(i&lt;=T) { memset(d,0,sizeof(d)); scanf(“%d”,&amp;n); for(int j=1;j&lt;=n;j++) { scanf(“%d”,&amp;v); add(j,v); } printf(“Case %d:\n”,i++); while(true) { scanf(“%s”,order); if(order[0]==’A’) { scanf(“%d%d”,&amp;x,&amp;v); add(x,v); } else if(order[0]==’S’) { scanf(“%d%d”,&amp;x,&amp;v); add(x,-v); } else if(order[0]==’Q’) { scanf(“%d%d”,&amp;x,&amp;y); printf(“%d\n”,Queries(x-1,y)); } else break; } } return 0;}线段树：#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;const int MAXNODE=1&lt;&lt;17;const int MAXN=50005;struct { int value,right,left;}node[MAXNODE];int father[MAXN];void BuildTree(int i,int left,int right){ node[i].left = left; node[i].right = right; node[i].value = 0; if(left==right){ father[left] = i; return ; } BuildTree(i&lt;&lt;1,left,(int) floor((right+left)/2.0)); BuildTree((i&lt;&lt;1)+1,(int) floor((right+left)/2.0+1),right);}void UpdateTree(int ni,int add){ node[ni].value+=add; if(ni==1) return ; UpdateTree(ni/2,add);}int Sum;void Query(int i,int left,int right){ if(node[i].left==left&amp;&amp;node[i].right==right){ Sum+=node[i].value; return ; } i=i&lt;&lt;1; if(left&lt;=node[i].right){ if(right&lt;=node[i].right)Query(i,left,right); else Query(i,left,node[i].right); } i++; if(right&gt;=node[i].left){ if(left&gt;=node[i].left)Query(i,left,right); else Query(i,node[i].left,right); }}int main(){ int T,n; scanf(“%d”,&amp;T); int i,j=1,d; while(j&lt;=T){ scanf(“%d”,&amp;n); BuildTree(1,1,n); for(i=1;i&lt;=n;i++){ scanf(“%d”,&amp;d); UpdateTree(father[i],d); } char par[6]; int a,b; printf(“Case %d:\n”,j++); while(~scanf(“%s”,par)&amp;&amp;par[0]!=’E’){ scanf(“%d%d”,&amp;a,&amp;b); if(par[0]==’Q’){ Sum=0; Query(1,a,b); printf(“%d\n”,Sum); } else if(par[0]==’A’){ UpdateTree(father[a],b); } else if(par[0]==’S’){ UpdateTree(father[a],-b); } } } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[线段树----hdoj 1754 I here it]]></title>
    <url>%2F2019%2F05%2F16%2F81161843%2F</url>
    <content type="text"><![CDATA[题目表述：I Hate ItTime Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 96882 Accepted Submission(s): 36592Problem Description很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。Output对于每一次询问操作，在一行里面输出最高成绩。Sample Input56 1 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5Sample Output5659题目分析： 因为学生的成绩的动态更新的，并且是区间查询，求区间的最大值。这是一个很明显的线段树的题目，线段树记录每一段区间的最大值。#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int MAXN = 2e6+10;//学生的最大个数const int MAXNODE = 1&lt;&lt;19;//线段树节点的最多个数//学生数量在最下层，我们可以根据满二叉树的性质计算所有节点的性质struct { int value,right,left;//value记录区间的最大值}node[MAXNODE];int father[MAXN];//记录节点在二叉树中的位置void BuildTree(int i,int left,int right){//建树，将树所有节点初始化为0，得到father的数据 node[i].left = left; node[i].right = right; node[i].value = 0; if(left==right){ father[left] = i; return ; } BuildTree(i&lt;&lt;1,left,(int) floor((right+left)/2.0));//建左数 BuildTree((i&lt;&lt;1)+1,(int) floor((right+left)/2.0+1),right);//建右树}void UpdateTree(int ni){//更新树 if(ni==1)return ; int fni=ni/2; int lv=node[fni&lt;&lt;1].value; int rv=node[(fni&lt;&lt;1)+1].value; node[fni].value=max(lv,rv);//得到左右孩子的最大值 UpdateTree(ni/2);//更新父亲}int Max;void Query(int i,int left,int right)//从i位置开始查询(left,right)区间的的最大值{ if(node[i].left==left&amp;&amp;node[i].right==right){//找到要查询的区间计算 Max = max(Max,node[i].value); return ; } i=i&lt;&lt;1; if(left&lt;=node[i].right){//对左孩子查询 if(right&lt;=node[i].right)Query(i,left,right); else Query(i,left,node[i].right); } i++; if(right&gt;=node[i].left)//对有孩子查询 { if(left&gt;=node[i].left)Query(i,left,right); else Query(i,node[i].left,right); }}int main(){ int n,m,i,g; while(~scanf(“%d%d”,&amp;n,&amp;m)){ BuildTree(1,1,n);//从1开始键树 for(i=1;i&lt;=n;i++){ scanf(“%d”,&amp;g); node[father[i]].value=g;//更新叶子节点 UpdateTree(father[i]);//向上更新父亲节点 } char par[2]; int a,b; while(m–){ scanf(“%s”,par); scanf(“%d%d”,&amp;a,&amp;b); if(par[0]==’Q’){ Max=0; Query(1,a,b);//查询 printf(“%d\n”,Max); } else{ node[father[a]].value=b;//更新a学生的成绩 UpdateTree(father[a]); } } } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[树状数组----poj 2352 stars]]></title>
    <url>%2F2019%2F05%2F16%2F81161549%2F</url>
    <content type="text"><![CDATA[题目描述：StarsTime Limit: 1000MS Memory Limit: 65536K Total Submissions: 53181 Accepted: 22886 DescriptionAstronomers often examine star maps where stars are represented by points on a plane and each star has Cartesian coordinates. Let the level of a star be an amount of the stars that are not higher and not to the right of the given star. Astronomers want to know the distribution of the levels of the stars. For example, look at the map shown on the figure above. Level of the star number 5 is equal to 3 (it’s formed by three stars with a numbers 1, 2 and 4). And the levels of the stars numbered by 2 and 4 are 1. At this map there are only one star of the level 0, two stars of the level 1, one star of the level 2, and one star of the level 3. You are to write a program that will count the amounts of the stars of each level on a given map.InputThe first line of the input file contains a number of stars N (1&lt;=N&lt;=15000). The following N lines describe coordinates of stars (two integers X and Y per line separated by a space, 0&lt;=X,Y&lt;=32000). There can be only one star at one point of the plane. Stars are listed in ascending order of Y coordinate. Stars with equal Y coordinates are listed in ascending order of X coordinate. OutputThe output should contain N lines, one number per line. The first line contains amount of stars of the level 0, the second does amount of stars of the level 1 and so on, the last line contains amount of stars of the level N-1.Sample Input51 15 17 13 35 5Sample Output12110题目大意：所有点在笛卡尔坐标内，先输入点的数量N，然后已y坐标从小到大的顺序输入点的x,y坐标，要求将这些坐标分层，x&lt;=x1&amp;&amp;y&lt;=y1,的(x,y)在（x1,y1)的下面，计算(x,y)下面坐标的个数该点的层次，输出每一层点的数量，从第一层开始。只有每一个点的坐标都是唯一的，没有重叠的点。题目分析：因为输入是按照y坐标的顺序输入，所以我们输入之后只要考虑x，计算小于x的元素的个数，我们可以用一个数组，记录c[x],每一次，查询就计算下标小于等于x的前面元素的和。这就可以用树状数组解决了，每一次输入进行更新。#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=32005;int level[maxn],cn[maxn];//level记录每层元素个数，cn树状数组，记录前缀和int sum(int n)//查询n下标前面元素个数和{ int sum=0; while(n&gt;0) { sum+=cn[n]; n-=n&amp;(-n); } return sum;}void add(int n)//更新树状数组n下标元素{ while(n&lt;=maxn) { cn[n]++; n+=n&amp;(-n); }}int main(){ int i,m,x,y; while(scanf(“%d”,&amp;m)!=EOF) { memset(level,0,sizeof(level)); memset(cn,0,sizeof(cn)); for(i=0;i&lt;m;i++) { scanf(“%d%d”,&amp;x,&amp;y); x++;//树状数组从1开始，因为笛卡尔坐标有0元素 level[sum(x)]++;//更新对应层元素个数 add(x); } for(i=0;i&lt;m;i++) printf(“%d\n”,level[i]); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[莫队算法]]></title>
    <url>%2F2019%2F05%2F16%2F81139579%2F</url>
    <content type="text"><![CDATA[莫队算法是一种解决区间问题的算法，是一种很优的暴力算法。莫队算法的基本思想是，知道一个区间[l,r]的一些信息，就可以在很短的时间内求出它的扩展区间的一些信息。算法讲解挺详细的链接点击跳转到百度文库pdf文档题目描述Given a sequence of integers a1, a2, …, an and q pairs of integers (l1, r1), (l2, r2), …, (lq, rq), find count(l1, r1), count(l2, r2), …, count(lq, rq) where count(i, j) is the number of different integers among a1, a2, …, ai, aj, aj + 1, …, an.输入描述:The input consists of several test cases and is terminated by end-of-file.The first line of each test cases contains two integers n and q.The second line contains n integers a1, a2, …, an.The i-th of the following q lines contains two integers li and ri.输出描述:For each test case, print q integers which denote the result. 示例1输入复制3 21 2 11 21 34 11 2 3 41 3输出复制213备注: 1 ≤ n, q ≤ 105 1 ≤ ai ≤ n 1 ≤ li, ri ≤ n The number of test cases does not exceed 10.题目意思是给定一个序列，输入下标（i，j)计算序列不包括区间（i，j）之后的不同数字的个数。首先用暴力求解：直接对于每一个样例进行去掉中间区间再进行遍历#include&lt;iostream&gt;using namespace std;const int maxn=100005;int q,m;int s[maxn],rec[maxn],Ans[manx];struct Par{int lef,rig}par[maxn];int main(){ int i,j; while(scanf(“%d%d”,&amp;q,&amp;m)!=EOF) { memset(Ans,0,sizeof(Ans)); for(i=0;i&lt;q;i++) { scanf(“%d”,&amp;s[i]); } for(i=0;i&lt;m;i++) { scanf(“%d%d”,&amp;par[i].lef,&amp;par[i].rig); } for(i=0;i&lt;m;i++) { memset(rec,0,sizoef(rec)); for(j=0;j&lt;par[i].lef;j++) { if(rec[j]==0) Ans[i]++; rec[j]=1; } for(j=par[i].rig;j++) { if(rec[j]==0) Ans[i]++; rec[j]=1; } } for(j=0;j&lt;m;j++) printf(“%d\n”,Ans[j]); } return 0;}提交的结果是运行超时。莫队算法，同样是暴力但是它是根据知道了区间O(1)的时间去求它旁边的区间。其算法思路是这样的，先将n个元素的序列分成sqrt（n）组，然后对查询区间先根据左端点所在的组排序，然后再根据右端点排序，再进行查询，每一次查询都使用前面得到的查询结果进行更新。下面代码的思路是：先对整个序列进项查询，记录不同数组的总数，然后减去莫队算法得到的中间区间的总数，但是提交还是超时的，不过可以看出时间复杂度要比之前的暴力要更少。#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int q,m;int s[maxn],rec[maxn],md[maxn],Ans[maxn];struct Par{int lef,rig,id;}par[maxn];bool cmp(Par a,Par b){ if(md[a.lef]!=md[b.lef])return a.lef&lt;b.lef; return a.rig&lt;b.rig;}void solve(){ int i,lef=1,rig=1,ans=0; for(i=1;i&lt;=m;i++) { while(lef&lt;par[i].lef) if(–rec[s[lef++]]==0) ans–; while(lef&gt;par[i].lef) if(rec[s[–lef]]++==0) ans++; while(rig&lt;par[i].rig) if(rec[s[++rig]]++==0) ans++; while(rig&gt;par[i].rig) if(–rec[s[rig–]]==0) ans–; Ans[par[i].id]=ans; } return ;}int main(){ int i,temp,total; while(scanf(“%d%d”,&amp;q,&amp;m)!=EOF) { memset(rec,0,sizeof(rec)); temp=sqrt(q); total=0; for(i=1;i&lt;=q;i++) { scanf(“%d”,&amp;s[i]); md[i]=(i-1)/temp+1; if(rec[s[i]]==0) { total++; rec[s[i]]=1; } } for(i=1;i&lt;=m;i++) { scanf(“%d%d”,&amp;par[i].lef,&amp;par[i].rig); par[i].lef++; par[i].rig–; par[i].id=i; } sort(par+1,par+m+1,cmp); memset(rec,0,sizeof(rec)); solve(); for(i=1;i&lt;=m;i++)printf(“%d\n”,total-Ans[i]); } return 0;} 下面的代码是优化后的莫队排序，通过直接计算两边区间的总数得到答案。提交时通过的，但是运行的时间和时间限制很接近，所以莫队算法并不是解这道题的最优算法。#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int q,m;int s[maxn],rec[maxn],md[maxn],Ans[maxn];struct Par{int lef,rig,id;}par[maxn];bool cmp(Par a,Par b){ if(md[a.lef]!=md[b.lef])return a.lef&lt;b.lef; return a.rig&lt;b.rig;}void solve(){ int i,lef=0,rig=q+1,ans=0; for(i=1;i&lt;=m;i++) { while(rig&lt;par[i].rig) { rec[s[rig]]–; if(rec[s[rig]]==0) ans–; rig++; } while(rig&gt;par[i].rig) { rig–; if(rec[s[rig]]==0) ans++; rec[s[rig]]++; } while(lef&lt;par[i].lef) { lef++; if(rec[s[lef]]==0) ans++; rec[s[lef]]++; } while(lef&gt;par[i].lef) { rec[s[lef]]–; if(rec[s[lef]]==0) ans–; lef–; } Ans[par[i].id]=ans; } return ;}int main(){ int i,temp; while(scanf(“%d%d”,&amp;q,&amp;m)!=EOF) { memset(rec,0,sizeof(rec)); memset(Ans,0,sizeof(Ans)); temp=sqrt(q); for(i=1;i&lt;=q;i++) { scanf(“%d”,&amp;s[i]); md[i]=(i-1)/temp+1; } for(i=1;i&lt;=m;i++) { scanf(“%d%d”,&amp;par[i].lef,&amp;par[i].rig); par[i].id=i; } sort(par+1,par+m+1,cmp); solve(); for(i=1;i&lt;=m;i++)printf(“%d\n”,Ans[i]); } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[枚举+深搜----poj 3279 Fliptile]]></title>
    <url>%2F2019%2F05%2F16%2F81105176%2F</url>
    <content type="text"><![CDATA[题目描述：FliptileTime Limit: 2000MS Memory Limit: 65536K Total Submissions: 15598 Accepted: 5712 DescriptionFarmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M × N grid (1 ≤ M ≤ 15; 1 ≤ N ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word “IMPOSSIBLE”.InputLine 1: Two space-separated integers: M and N Lines 2..M+1: Line i+1 describes the colors (left to right) of row i of the grid with N space-separated integers which are 1 for black and 0 for whiteOutputLines 1..M: Each line contains N space-separated integers, each specifying how many times to flip that particular location.Sample Input4 41 0 0 10 1 1 00 1 1 01 0 0 1Sample Output0 0 0 01 0 0 11 0 0 10 0 0 0题目大意：奶牛翻转地板，地板有两面，一面白色一面黑色，每翻转一块地板，与该地板有公共边的地板都会随着翻转，地板是正方形。我们要求的是，给出一块地面上面铺上了地板，地板黑白面给出，要求奶牛翻转地板最少多少次能将地面全部变成白色，输出翻转数组，如果不能全部变成白色输出”IMPOSSIBLE”，如果能输出翻转数组，每一块地板用一个数据表示，翻转为1，不翻转为0，输出翻转次数最少，并且翻转数组字典序最小的数组。题目分析：要求到这个题目的解，可以将所有地板是否翻转的情况全部列举出来，但是全部列举出来的话有2的nm次方种情况，并且要将每一种情况遍历完，所需要复杂度会很庞大的。必须先将情况减少，如果先将第一行确定的话，改变第一行的状态的就只有第二行的翻转了，因此第二行的翻转情况也被固定了，第二行翻转完成之后，……依次类推，当最后一行因为倒数第二行而翻转之后，如果最后一行全部变成了白色的话那么就翻转成功了。因此我们只要把第一行的情况全部考虑一遍，后面的情况基本上是固定了的。我开始用的是递归遍历，将第一行遍历，每一次的出来的情况再推导出之后所有行的情况。代码#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef struct{ int d[16]; int total;}Vis;bool operator&gt;(Vis v1,Vis v2)//vis的判断{ if(v1.total&gt;v2.total) return true; else if(v1.total==v2.total) { for(int i=0;i&lt;16;i++) if(v1.d[i]&gt;v2.d[i]) return true; else if(v1.d[i]&lt;v2.d[i]) return false; else continue; return true; } else return false;}Vis vis,vismin;int bit[16];int titles[16];int titles1[16];bool flag;int m,n;void dfs(int j){ if(j&gt;=m) { int i,k; memset(titles1,0,sizeof(titles1)); for(i=0;i&lt;m;i++)titles1[i]=titles[i];//将title备份 vis.total=0; for(k=0;k&lt;n;k++)//将vis第一行中的情况体现在title1中 if(vis.d[0]&amp;bit[k]) { vis.total++;//记录第一行翻转的次数 if(k-1&gt;=0)titles1[0]^=bit[k-1]; titles1[0]^=bit[k]; if(k+1&lt;n)titles1[0]^=bit[k+1]; titles1[1]^=bit[k]; } for(i=1;i&lt;m;i++)//翻转第一行之后的所有行 for(k=0;k&lt;n;k++) { if(titles1[i-1]&amp;bit[k]) { vis.total++;//记录第一行之后要翻转次数 vis.d[i]|=bit[k]; titles1[i-1]^=bit[k]; if(k-1&gt;=0)titles1[i]^=bit[k-1]; titles1[i]^=bit[k]; if(k+1&lt;n)titles1[i]^=bit[k+1]; if(i&lt;m-1)titles1[i+1]^=bit[k]; } } if(!titles1[m-1])//判断最后一行是否全部为0 { flag=true;//为0则有解 if(vismin&gt;vis)//判断是否比vismin更优 vismin=vis; } for(i=1;i&lt;m;i++)//退出来的时候要将vis.d第一行后面的都置零 vis.d[i]=0; return ; } vis.d[0]&amp;=~bit[j];//不翻转的情况 dfs(j+1); vis.d[0]|=bit[j];//翻转的情况 dfs(j+1);}int main(){ int i,j,nu; for(i=0;i&lt;16;i++)//定义bit位运算 bit[i]=1&lt;&lt;i; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;(m!=0||n!=0)) { flag=false; memset(titles,0,sizeof(titles)); memset(vis.d,0,sizeof(titles)); vis.total=0; for(i=0;i&lt;m;i++)//输入，初始化title for(j=0;j&lt;n;j++) { scanf(“%d”,&amp;nu); if(nu) titles[i]|=bit[j]; } for(i=0;i&lt;m;i++)//初始化vismin vismin.d[i]=~0; vismin.total=mn; dfs(0);//对第一行从第一个元素开始深搜 if(flag) for(i=0;i&lt;m;i++) { for(j=0;j&lt;n;j++) if(vismin.d[i]&amp;bit[j]) printf(“1 “); else printf(“0 “); printf(“\n”); } else printf(“IMPOSSIBLE\n”); } return 0;}上面的代码中因为考虑在递归栈中保存状态的时候会使用很大的内存，因此我用的是一个整型的以为数组存储二维状态，每一个整型数据中每一个二进制位都表示一块地板的状态和翻转的状态。上面代码的时间复杂度和空间消耗是：Memory: 180K Time: 188MS 优化：其实在遍历第一行的所有情况的时候并不需要用递归，枚举是完全有优势的，因为枚举出来的情况是2的nm次方，而从0开始到2的nm次方的所有数据的二进制形式就是第一行翻转的所有情况情况，所以只要将这个数据复制给vis[0]就确定了第一行的情况了。后面的翻转的时候只i-1行的地板状态就是i行翻转的情况，然后翻转的时候就是将i与对应的地方抑或就可以实现翻转了。优化后的代码：#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int bit[16],tit[16],n,m,flag;typedef struct{ int d[16],t;}Vis;Vis vismin,vis;bool operator&gt;(Vis v1,Vis v2){ if(v1.t&gt;v2.t)return true; else if(v1.t==v2.t) { for(int i=0;i&lt;16;i++) if(v1.d[i]&gt;v2.d[i])return true; else if(v1.d[i]&lt;v2.d[i])return false; return true; } else return false;}void dfs(int tmp){ int tit1[16],i,j; memcpy(tit1,tit,sizeof(tit)); vis.t=0; vis.d[0]=tmp; for(i=0;i&lt;m;i++) { if(i&gt;0){ vis.d[i]=tit1[i-1]; tit1[i-1]=0; } tit1[i]^=(vis.d[i]&lt;&lt;1)^(vis.d[i])^(vis.d[i]&gt;&gt;1); if(i!=m-1)tit1[i+1]^=vis.d[i]; tit1[i]&amp;=(1&lt;&lt;n)-1; } if(!tit1[m-1]) { flag=1; for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) if(vis.d[i]&amp;bit[j]) vis.t++; if(vismin&gt;vis) vismin=vis; }}int main(){ int i,j,tmp; for(i=0;i&lt;16;i++) bit[i]=1&lt;&lt;i; scanf(“%d%d”,&amp;m,&amp;n); flag=0; vismin.t=16*16; memset(tit,0,sizeof(tit)); for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) if(scanf(“%d”,&amp;tmp)&amp;&amp;tmp) tit[i]|=bit[j]; tmp=1&lt;&lt;n; for(i=0;i&lt;tmp;i++)dfs(i); if(flag) { for(i=0;i&lt;m;i++){ for(j=0;j&lt;n;j++){ if(vismin.d[i]&amp;bit[j])printf(“1”); else printf(“0”); if(j!=n-1)printf(“ “); } printf(“\n”); } } else printf(“IMPOSSIBLE\n”); return 0;}优化后的时间空间消耗是：Memory: 92K Time: 0MS]]></content>
  </entry>
  <entry>
    <title><![CDATA[bfs+dfs分析----poj 3278 Catch That Cow]]></title>
    <url>%2F2019%2F05%2F16%2F81066389%2F</url>
    <content type="text"><![CDATA[题目详情Catch That CowTime Limit: 2000MS Memory Limit: 65536K Total Submissions: 115430 Accepted: 36066 DescriptionFarmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute.If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?InputLine 1: Two space-separated integers: N and KOutputLine 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.Sample Input5 17Sample Output4HintThe fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes. 解题思路：刚开始看这个题目的时候我首先想到的是dfs，可能因为dfs递归比较好用，而且发现倒过来从牛到人要好弄，因为是奇数还是偶数，会影响搜索路口。奇数的话一定是从加减过来的，而偶数如果要加减的话，就要一次执行两次加减才能再次除二，而且如果执行两次减再除和执行一次除再减一次效果一样后者更加优，加也一样。另外还有一种就是连加减两次以上和先除一次可能会出现歧义，所以增加了一次判断每次执行除2都与n-k相比较。我们将边界设置为n&gt;=k，因为当n&gt;k时，我们执行除法和减法都会越来越远，就只能连加n-k次；当n==k时，也就是catch的时候了。所以我就写了下面的代码，下面的代码是不行的。#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int dfs(int n,int k){ if(n&gt;=k) return n-k; if(k%2==0) return min(k-n,dfs(n,k/2)+1); else return min(dfs(n,k+1),dfs(n,k-1))+1;}int main(){ int n,k,result=0; scanf(“%d%d”,&amp;n,&amp;k); printf(“%d\n”,result+dfs(n,k)); return 0;}找了好久，都没有找到错误的，都找不到re的原因，后来我放弃了dfs。dicuss里面都是用的bfs。bfs很简单，就是一个队列记录走的坐标和走的步数，然后进行层次遍历，当找到牛所在的地方就结束，这样就不会出现dfs那中没有尽头的路，或者总很长才发现不是最短的那条路，在一些特殊情况面前就要更加节约时间。#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n,k;struct{ int n; int level;}du[100005];//辅助dfs的队列，n表示人走到的坐标，level表示已经走的步数int vis[100005];//标记数组，避免重复走相同的坐标int front,rear;int bfs(int n){ int level; memset(vis,0,sizeof(vis)); vis[n]=1; front=rear=-1; rear++;//入队操作，将第一个坐标入队 du[rear].n=n; du[rear].level=0; while(rear!=front) { front++;//出队操作 n=du[front].n; level=du[front].level; int m; for(int i=0;i&lt;3;i++)//向三个方向走 { switch(i) { case 0:m=n+1;break; case 1:m=n-1;break; case 2:m=n*2;break; } if(m&gt;0&amp;&amp;m&lt;100005&amp;&amp;!vis[m]) { rear++;//入队操作 du[rear].n=m; du[rear].level=level+1; vis[m]=1; if(m==k)return level+1;//判断是否能catch } } } return 0;}int main(){ cin&gt;&gt;n&gt;&gt;k; if(n&gt;=k) cout&lt;&lt;n-k&lt;&lt;endl;//判断n&gt;k，大于则直接减法走完 else cout&lt;&lt;bfs(n)&lt;&lt;endl; return 0;}后来我翻看discuss中发现有人说0的情况，然后我试了一下，我前面那个dfs的方法是真的不行，于是我开始模拟0的情况，我发现0时dfs就是那种没有尽头的情况。原来其它任何元素都是有多个方法走到的，但是0，却只能通过1减过来，但是在我们第二个return的时候我们判断k+1和k-1的时候dfs会把两种情况都走完才能得到return值，因此k+1时永远也走不到0的，于是我改了一下代码，就过了。#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int dfs(int n,int k){ if(n&gt;=k) return n-k; if(k%2==0) return min(k-n,dfs(n,k/2)+1); else return min(dfs(n,k+1),dfs(n,k-1))+1;}int main(){ int n,k,result=0; scanf(“%d%d”,&amp;n,&amp;k); if(n==0) n=result=1; printf(“%d\n”,result+dfs(n,k)); return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[广度优先搜索----poj 2251 Dungeon Master]]></title>
    <url>%2F2019%2F05%2F16%2F81054715%2F</url>
    <content type="text"><![CDATA[题目描述：Dungeon MasterTime Limit: 1000MS Memory Limit: 65536K Total Submissions: 46622 Accepted: 17566 DescriptionYou are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. Is an escape possible? If yes, how long will it take? InputThe input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size). L is the number of levels making up the dungeon. R and C are the number of rows and columns making up the plan of each level. Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C.OutputEach maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s).where x is replaced by the shortest time it takes to escape. If it is not possible to escape, print the line Trapped!Sample Input3 4 5S…..###..##..###.#############.####…###########.#######E1 3 3S###E####0 0 0Sample OutputEscaped in 11 minute(s).Trapped!Description - 题目描述[NWUACM] 你被困在一个三维的空间中,现在要寻找最短路径逃生！空间由立方体单位构成你每次向上下前后左右移动一个单位需要一分钟你不能对角线移动并且四周封闭是否存在逃出生天的可能性？如果存在，则需要多少时间？Input - 输入 输入第一行是一个数表示空间的数量。 每个空间的描述的第一行为L，R和C（皆不超过30）。 L表示空间的高度。 R和C分别表示每层空间的行与列的大小。 随后L层地牢，每层R行，每行C个字符。 每个字符表示空间的一个单元。’#’表示不可通过单元，’.’表示空白单元。你的起始位置在’S’，出口为’E’。 每层空间后都有一个空行。L，R和C均为0时输入结束。Output - 输出 每个空间对应一行输出。 如果可以逃生，则输出如下 Escaped in x minute(s). x为最短脱离时间。 如果无法逃生，则输出如下 Trapped!解题思路：这个题目一看就是一个广度优先搜索的题目，就像迷宫求解那样搜索，只是这个题目从迷宫的二维变成了三维，搜索的方向就从以前的四个变成了六个，方法还是一样的。我写了两个函数，path是通过搜索将数据纪录在队列数组中，然后result函数向前面跳，跳到入口位置就是最短路径了。其实也可以通过在队列数组中放一个记步变量，直接获取最短路径长度。#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef struct{ int pre;//指向它的上一个元素，路径上的前驱 int l,r,c;} que;int front,rear;int r,c,l;int li,ri,ci;//入口数据char dungeon[32][32][32];que qu[303030];//队列数组int path(int li,int ri,int ci){ int i,j,k,di; front=rear=-1; rear++; qu[rear].l=li;qu[rear].r=ri; qu[rear].c=ci;qu[rear].pre=-1; while(front!=rear) { front++; i=qu[front].l;j=qu[front].r; k=qu[front].c; for(di=0;di&lt;6;di++)//分别向六个方向搜索 { switch(di) { case 0:i=qu[front].l-1;j=qu[front].r;k=qu[front].c;break; case 1:i=qu[front].l+1;j=qu[front].r;k=qu[front].c;break; case 2:i=qu[front].l;j=qu[front].r-1;k=qu[front].c;break; case 3:i=qu[front].l;j=qu[front].r+1;k=qu[front].c;break; case 4:i=qu[front].l;j=qu[front].r;k=qu[front].c-1;break; case 5:i=qu[front].l;j=qu[front].r;k=qu[front].c+1;break; } if(dungeon[i][j][k]==’E’)//如果是出口，将出口入队（便于计算步数），返回true { rear++; qu[rear].l=i;qu[rear].r=j; qu[rear].c=k;qu[rear].pre=front; return true; } if(dungeon[i][j][k]==’.’)//如果走的通就入队 { rear++; qu[rear].l=i;qu[rear].r=j; qu[rear].c=k;qu[rear].pre=front; dungeon[i][j][k]=’#’; } } } return false;}int result()//得到路径{ int i=qu[rear].pre,res=0; while(i!=-1) { res++; i=qu[i].pre; } return res;}int main(){ int i,j,k; while(cin&gt;&gt;l&gt;&gt;r&gt;&gt;c&amp;&amp;(r||l||c)) { for(i=0;i&lt;l;i++) for(j=0;j&lt;r;j++) for(k=0;k&lt;c;k++) { cin&gt;&gt;dungeon[i][j][k]; if(dungeon[i][j][k]==’S’)//找到入口，纪录入口位置 { li=i;ri=j;ci=k; } } if(path(li,ri,ci)) cout&lt;&lt;”Escaped in “&lt;&lt;result()&lt;&lt;” minute(s).”&lt;&lt;endl; else cout&lt;&lt;”Trapped!”&lt;&lt;endl; } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[深度优先搜索----poj 1321棋盘问题]]></title>
    <url>%2F2019%2F05%2F16%2F81053100%2F</url>
    <content type="text"><![CDATA[题目描述棋盘问题Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 63237 Accepted: 30234 Description在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。Input输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n 当为-1 -1时表示输入结束。 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。Sample Input2 1#..#4 4…#..#..#..#…-1 -1Sample Output21Source解题思路：从问题出发，可以看出是一个搜索问题，棋盘是不规则的，而且棋子也不一定是排满的。需要对每一个位置进行可不可以下棋搜索，如果可以下，要考虑是否安排下棋。考虑到一行或者一列不能下两个棋子，对没行进行搜索，搜索到可以下的行需要考虑是否将棋子下入改行。最后考虑边界，停止搜索的边界有两个：一棋盘的边界n、二棋子下完的边界k。#include&lt;iostream&gt;using namespace std;int way,result;//way表示已排多少棋子，result表示结果int n,k;int temp[10];//标记列是否已有棋子char ch[10][10];void dps(int l)//深度优先搜索函数{ if(way==k)//棋子排满边界 { result++; return ; } if(l&gt;=n)//设置数组边界 { return ; } for(int i=0;i&lt;n;i++)//考虑第l列的情况 { if(ch[l][i]==’#’&amp;&amp;temp[i]==0) { temp[i]=1; way++; dps(l+1);//将搜索的节点计算入内的情况 temp[i]=0;//不将节点计算入内的情况 way–; } } dps(l+1);//不考虑第l列的情况}int main(){ int i,j; while(cin&gt;&gt;n&gt;&gt;k&amp;&amp;(n!=-1||k!=-1)) { //初始化 way=0;result=0; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) cin&gt;&gt;ch[i][j]; //从第0行开始深度优先搜索 dps(0); cout&lt;&lt;result&lt;&lt;endl; } return 0;}]]></content>
  </entry>
  <entry>
    <title><![CDATA[GetModuleFileName函数]]></title>
    <url>%2F2019%2F05%2F16%2F80933368%2F</url>
    <content type="text"><![CDATA[GetModuleFileName函数检索指定模块的完全限定路径。要指定包含模块的进程，请使用GetModuleFileNameEx函数。DWORD GetModuleFileName( HMODULE hModule, // handle to module LPTSTR lpFilename, // path buffer DWORD nSize // size of buffer);参数hModule:[in]请求路径的模块的句柄。如果该参数为空，GetModuleFileName将检索当前模块的路径。lpFilename:[out]指向缓冲区的指针，该缓冲区接收模块的完全限定路径。如果字符串的长度超过了nSize参数指定的大小，则该字符串将被截断。&lt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[RegQueryValueEx函数]]></title>
    <url>%2F2019%2F05%2F16%2F80930883%2F</url>
    <content type="text"><![CDATA[RegQueryValueEx函数检索与开放注册表键关联的指定值名称的类型和数据。LONG RegQueryValueEx( HKEY hKey, // handle to key LPCTSTR lpValueName, // value name LPDWORD lpReserved, // reserved LPDWORD lpType, // type buffer LPBYTE lpData, // data buffer LPDWORD lpcbData // size of data buffer);参数hKey：当前打开的密钥或以下预定义密钥之一的句柄:HKEY_CLASSES_ROOTHKEY_CURRENT_CONFIGHKEY_CURRENT_USERHKEY_LOCAL_MACHINEHKEY_USERSWindows NT/2000/XP: HKEY_PERFORMANCE_DATA Windows XP: HKEY_PERFORMANCE_TEXT HKEY_PERFORMANCE_NLSTEXT Windows 95/98/Me: HKEY_DYN_DATAlpValueName：指向一个以null结尾的字符串的指针，该字符串包含要查询的值的名称。如果lpValueName是NULL或空字符串“”，函数将检索键的未命名或默认值(如果有的话)的类型和数据。Windows 95/98/Me:每个键都有一个默认值，最初不包含数据。在Windows 95上，默认值类型总是REG_SZ。在Windows 98上，键的默认值的类型最初是REG_SZ，但是RegSetValueEx可以指定具有不同类型的默认值。Windows NT/2000/XP:键不自动具有未命名或默认值。未命名值可以是任何类型。lpReserved：保留;必须为NULL。lpType：指向一个变量的指针，该变量接收指示存储在指定值中的数据类型的代码。有关可能的类型代码的列表，请参见注册表值类型。如果不需要类型代码，则lpType参数可以为NULL。lpData：指向接收该值数据的缓冲区的指针。如果不需要数据，此参数可以为空。lpcbData：指向一个变量的指针，该变量指定lpData参数指向的缓冲区的大小(以字节为单位)。当函数返回时，该变量包含复制到lpData的数据的大小。&lt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[RegOpenKeyEx函数]]></title>
    <url>%2F2019%2F05%2F16%2F80930685%2F</url>
    <content type="text"><![CDATA[RegOpenKeyEx函数打开指定的注册表项。LONG RegOpenKeyEx( HKEY hKey, // handle to open key LPCTSTR lpSubKey, // subkey name DWORD ulOptions, // reserved REGSAM samDesired, // security access mask PHKEY phkResult // handle to open key);参数hkey：当前打开的密钥或以下预定义密钥之一的句柄HKEY_CLASSES_ROOTHKEY_CURRENT_CONFIGHKEY_CURRENT_USERHKEY_LOCAL_MACHINEHKEY_USERSWindows NT/2000/XP: HKEY_PERFORMANCE_DATA Windows 95/98/Me: HKEY_DYN_DATAlpSubKey：指向一个空终止字符串的指针，该字符串包含要打开的子键的名称。如果该参数为NULL或指向空字符串的指针，则函数将为由hKey参数标识的键打开一个新句柄。在这种情况下，函数将不会关闭先前打开的句柄。ulOptions：保留;必须是零。samDesired：一个访问掩码，它指定对密钥的期望访问权限。这个参数可以是以下值的组合。KEY_CREATE_LINK、KEY_CREATE_SUB_KEY、KEY_ENUMERATE_SUB_KEYS、KEY_EXECUTE、KEY_NOTIFY、KEY_QUERY_VALUE、KEY_SET_VALUE、KEY_ALL_ACCESS、KEY_READ、KEY_WOW64_64KEY、KEY_WOW64_32KEY、KEY_WRITE。phkResult：指向变量的指针，该变量接收打开的键的句柄。当您不再需要返回的句柄时，请调用RegCloseKey函数来关闭它。返回值&lt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[RegSetValueEx函数]]></title>
    <url>%2F2019%2F05%2F16%2F80930423%2F</url>
    <content type="text"><![CDATA[RegSetValueEx函数在注册表项下设置指定值的数据和类型。LONG RegSetValueEx( HKEY hKey, // handle to key LPCTSTR lpValueName, // value name DWORD Reserved, // reserved DWORD dwType, // value type CONST BYTE *lpData, // value data DWORD cbData // size of value data);参数hkey： 当前打开的密钥或以下预定义密钥之一的句柄: HKEY_CLASSES_ROOTHKEY_CURRENT_CONFIGHKEY_CURRENT_USERHKEY_LOCAL_MACHINEHKEY_USERSWindows NT/2000/XP: HKEY_PERFORMANCE_DATA Windows 95/98/Me: HKEY_DYN_DATAlpValueName：指向一个字符串的指针，该字符串包含要设置的值的名称。如果键中不存在这个名称的值，函数将其添加到键中。如果lpValueName是NULL或空字符串””，函数将为键的未命名或默认值设置类型和数据。Reserved：保留;必须是零。dwType：指定由lpData参数指向的数据类型的代码。有关可能类型代码的列表，请参见注册表值类型。Ipdata：指向一个缓冲区的指针，该缓冲区包含以指定值名存储的数据。对于基于字符串的数据类型，如REG_SZ，字符串必须为空终止。对于REG_MULTI_SZ数据类型，字符串必须以双null结尾。cbData：指定lpData参数指向的信息的大小(以字节为单位)。如果数据类型为REG_SZ、REG_EXPAND_SZ或REG_MULTI_SZ，则cbData必须包括终止null字符或字符的大小。返回值&lt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[RegCreateKeyEx函数]]></title>
    <url>%2F2019%2F05%2F16%2F80928693%2F</url>
    <content type="text"><![CDATA[RegCreateKeyEx函数：创建指定的注册表项。如果键已经存在，函数将打开它。LONG RegCreateKeyEx( HKEY hKey, // handle to open key LPCTSTR lpSubKey, // subkey name DWORD Reserved, // reserved LPTSTR lpClass, // class string DWORD dwOptions, // special options REGSAM samDesired, // desired security access LPSECURITY_ATTRIBUTES lpSecurityAttributes, // inheritance PHKEY phkResult, // key handle LPDWORD lpdwDisposition // disposition value buffer);参数hkey：当前打开的密钥或以下预定义密钥之一的句柄:&lt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[RegConnectRegistry函数]]></title>
    <url>%2F2019%2F05%2F16%2F80928426%2F</url>
    <content type="text"><![CDATA[RegConnectRegistry函数在另一台计算机上建立到预定义注册表键的连接。LONG RegConnectRegistry( LPCTSTR lpMachineName, // 计算机名称 HKEY hKey, // 预定义的注册表处理 PHKEY phkResult // 用于远程关键句柄的缓冲区。);参数lpMachineName：指向指定远程计算机名称的空终止字符串的指针。如果该参数为空，则使用本地计算机名。h]]></content>
  </entry>
  <entry>
    <title><![CDATA[RegCloseKey函数]]></title>
    <url>%2F2019%2F05%2F16%2F80928198%2F</url>
    <content type="text"><![CDATA[RegCloseKey函数是释放一个对指定注册表项的句柄。LONG RegCloseKey( HKEY hKey // 处理键关闭。);Parameters hKey 对打开键的句柄关闭。返回值&lt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[注册表函数]]></title>
    <url>%2F2019%2F05%2F16%2F80927615%2F</url>
    <content type="text"><![CDATA[RegCloseKey：释放对指定注册表项的句柄。点击跳转到函数RegConnectRegistry：在另一台计算机上建立到预定义注册表句柄的连接。点击跳转到函数RegCreateKeyEx：创建指定的注册表项。点击跳转到函数RegDeleteKey：删除注册表子项。RegDeleteValue：从指定的注册表项中删除键值。RegDisablePredefinedCache：为指定的进程禁用HKEY_CURRENT_USER的预定义注册表句柄表。RegEnumKeyEx：枚举指定的打开注册表项的子键。RegEnumValue：枚举指定的打开注册表项的键值。RegFlushKey：将指定的打开注册表键的所有属性写入注册表。RegGetKeySecurity：检索保护指定开放注册表项的安全描述符的副本。RegLoadKey：在HKEY_USERS或HKEY_LOCAL_MACHINE下创建一个子键，并将指定文件中的注册信息存储到该子键中。RegNotifyChangeKeyValue：通知调用方对指定注册表项的属性或内容的更改。RegOpenCurrentUser：检索当前线程模拟的用户的HKEY_CURRENT_USER密钥的句柄。RegOpenKeyEx：打开指定的注册表键。点击跳转到函数RegOpenUserClassesRoot：检索指定用户的HKEY_CLASSES_ROOT密钥的句柄。RegOverridePredefKey：检索与开放注册表键关联的指定值名称的类型和数据。RegQueryInfoKey：检索有关指定注册表项的信息。RegQueryMultipleValues：检索与开放注册表项相关联的值名称列表的类型和数据。RegQueryValueEx：检索与开放注册表键关联的指定值名称的类型和数据。点击跳转到函数RegReplaceKey：用另一个文件替换支持注册表键及其所有子键的文件。RegRestoreKey：读取指定文件中的注册表信息，并将其复制到指定的键上。RegSaveKey：将指定的键及其所有子键和值保存到新文件中。RegSetKeySecurity：设置开放注册表项的安全性。RegSetValueEx：在注册表项下设置指定值的数据和类型。点击跳转到函数RegUnLoadKey：从注册表中卸载指定的注册表项及其子键。]]></content>
  </entry>
  <entry>
    <title><![CDATA[WSASocket函数未定义和重定义错误]]></title>
    <url>%2F2019%2F05%2F16%2F80902628%2F</url>
    <content type="text"><![CDATA[报错error C2065: ‘WSASocket’ : undeclared identifier意思是WSASocket函数没有声明定义WSASocket()是：创建一个与指定传送服务提供者捆绑的套接口，可选地创建和/或加入一个套接口组。此函数为socket（）的扩展版本，其功能都是创建一个原始套接字。使用时需要包含winsock2.h 头文件和链接ws2_32.lib库。刚开始我的情况是再cpp文件中包含了windows.h的头文件，也链接了ws2_32.lib库，然后出现没有定义的错误，后来我通过百度查到其需要包含winsock2.h的头文件然后我再windows.h后面又包含了winsock2.h的头文件，但是出现的报错就更多了，报错如下：c:\program files\microsoft visual studio\vc98\include\winsock2.h(99) : error C2011: ‘fd_set’ : ‘struct’ type redefinitionc:\program files\microsoft visual studio\vc98\include\winsock2.h(134) : warning C4005: ‘FD_SET’ : macro redefinition c:\program files\microsoft visual studio\vc98\include\winsock.h(84) : see previous definition of ‘FD_SET’。。。。。。。。（还有好多）然后我将winsock2.h的头文件删了，又到百度找答案，然后查到一篇博文说他误打误撞在winsock.h的头文件中包含stdafx.h头文件，我也试了一下，但是还是不行，可能是我的文件不同吧，因为编译之后我说stdafx.h没有定义，我找一下放头文件的文件夹是没有这个文件，我不至于这样就到网上找找一个包含进去吧，然后我打开我引入的头文件windows.h看了一下，里面包含了winsock.h，然后我到MSDN Library 找才知道winsock2.h是winsock.h的升级版，不能放在一起用，所以我就将winsock2.和定义到windows.h文件的前面，然后就可以了。最后我打开winsock2.h和winsock.h两个文件，发现他们的宏定义是这样的winsock2.h中定义了winsock.h的宏，说明如果先引入了winsock2.h同文件再引入winsock.h头文件，编译器是不会去编译winsock.h头文件的，如果倒过来就不同，并且会出现很多错误，是因为winsock.h和winsock2.h存在很多相同的定义或者其它。其实在winsock2.h文件中就能找到答案，下图“阻止包含windows.h中的winsock.h”。]]></content>
  </entry>
  <entry>
    <title><![CDATA[windows xp蓝屏英文翻译]]></title>
    <url>%2F2019%2F05%2F16%2F80896692%2F</url>
    <content type="text"><![CDATA[a problem has been detected and windows has been shut down to prevent damage to you computer.if this is the first time you`ve seen this stop error screen,restart your computer. if this screen appears again,follow these steps:check to be sure you have adequate disk space .if a driver is identified in the stop message,disable the driver or check with the manufacturer for driver updates. try changing video adapters.check with your hardware vendor for any bios updates.disavle bios memory options such as caching or shadowing.if you need to use safe mode to remove or disable componnents,restart your computer,press F8 to select advanced startup options,and then select safe mode.Technical information: ** stop:0x0000008E(0xC0000005,0x8057CC62,0xB2CBC9D4,0x00000000) 已检测到一个问题，windows已被关闭，以防止损坏您的计算机。如果这是您第一次看到停止错误屏幕，请重新启动计算机。如果此屏幕再次出现，请遵循以下步骤:检查是否有足够的磁盘空间。如果停止消息中标识了一个驱动程序，请禁用该驱动程序或与制造商检查驱动程序更新。试着改变视频适配器。请与您的硬件供应商检查任何bios更新。取消bios内存选项，如缓存或隐藏。如果需要使用安全模式删除或禁用组件，请重新启动计算机，按F8选择高级启动选项，然后选择安全模式。技术信息: 站:0 x0000008e(0 xc0000005,0 x8057cc62 0 xb2cbc9d4 0 x00000000) 第一次重启没有成功，第二次我本来想通过高级启动进入安全模式的但是重启之后没有来得及按F8就启动了，输入密码直接开机了，问题也就没有了。下次如果再遇到类似的问题就可以多重启几次，如果实在不行再进入安全模式，每个电脑进入安全模式的方式是不同的，百度一下，有些事ctrl、F8、等]]></content>
  </entry>
  <entry>
    <title><![CDATA[海明校验码]]></title>
    <url>%2F2019%2F05%2F16%2F80828286%2F</url>
    <content type="text"><![CDATA[基本思想：将有效信息位按某种规律分成若干组，每组安排一个校验位进行奇偶测试。在一个数据位组中加入几个校验位，增大数据代码间的码距，当某一位发生变化时会引起校验结果发生变化，不同代码微商的凑无会得到不同的校验结果。校验码的位数：设位数为N位，其中有效信息为k位，校验位为r位，分成r组奇偶校验，能产生r位验错信息，这r位信息就构成了一个二进制数的指误字，能指出2∧r-1位错误。所以N=k+r&lt;=2∧r-1有效信息分组规律：若海明校验码有m位，最高为第m位，最低为第1位，即H[m]、H[m-1]… … H[2]、H[1],其中中括号里面的数为位号数，位号数等于2的次方的那些位（即1（2^0）、2(2^1)、4(2^2)、… …2^(r-1)位），作为奇偶校验位，并记为P1、P2……Pr，余下的位则为有效信息位。校验位与有效信息位之和为m。每一位海明码由某些校验位所校验：即第i位由校验位位号之和等于i的那些校验位所校验。如下表： 海明校验 占用校 备注码位号 验位号1 1 1=12 2 2=23 1，2 3=1+24 4 4=45 1，4 5=1+46 2，4 6=2+47 1，2，4 7=1+2+4 海明码的编码、查找、纠错原理： 设有4位有效信息b1、b2、b3、b4和3位校验码P1、P2、P3海明校验码序号 1 2 3 4 5 6 7 出错位含义 P1 P2 b1 P2 b2 b3 b4 指误字 无错误 1 2 3 4 5 6 7第一组 G1 0 1 0 1 0 1 0 1第二组 G2 0 0 1 1 0 0 1 1 第三组 G3 0 0 0 0 1 1 1 1编码原理 ： 若有效信息b1、b2、b3、b4=1011，则先将它分别填入第3、5、6、7位，再分组进行奇偶统计，分别将值填入校验位P1、P2、P3。这里分组采用偶校验，因此要确保三组校验位的取值都满足偶校验规则。例如第一组有P1b1b2b4，已含有偶数个1，因此P1应为0，以确保第一组为偶性。由此可得P1 P2 b1 P2 b2 b3 b4=0110011。差错和纠错原理 ：计算G1=P1⊕b1⊕b2⊕b4;G2=P2⊕b1⊕b3⊕b4;G3=P2⊕b2⊕b3⊕b4;得到的G1G2G3的值就是出错位的二进制码序号，如G1G2G2=001，说明出错位的码序号是1。]]></content>
  </entry>
  <entry>
    <title><![CDATA[stl学习总结]]></title>
    <url>%2F2019%2F05%2F16%2F80759494%2F</url>
    <content type="text"><![CDATA[文档下载路径（内含源码）点击打开链接目录stl总结… 2迭代器… 2输出迭代器：… 2输入迭代器… 2向前迭代器… 2双向迭代器… 2随机访问迭代器… 2插入迭代器… 2流迭代器… 2常量迭代器和可变迭代器… 2迭代器的分类… 2类属算法… 3STL基本算法组织… 3非可变序列算法：… 3可变序列算法… 3排序相关的算法… 5通用数值算法… 6序列容器… 7向量… 7 stl总结迭代器输出迭代器：！=，++，first（只实现输出）操作。OutputIterator输入迭代器：first（实现输入），++。InputIterator向前迭代器：包括输出、输出迭代器的所有操作，有类似指针的++操作。ForwardIterator双向迭代器：包括前向迭代器的操作，有类似指针的—操作。随机访问迭代器：包括双向迭代器的操作，然后还满足下列操作对整数的加减法，以r+n，n+r和r-n表示。使用表达式r[n]访问第n个元素，其含义为(r+n)。双向“跳转”，以r+=n和r-=n表示。迭代器减法，以r-s表示，其结果为整数值。比较，以r&lt;s、r&gt;s、r&lt;=s、r&gt;=s表示，其结果为布尔值。插入迭代器：插入迭代器可将类书算法转入到“插入模式”，意味着表达式i=…的意义将不在是将i处的对象改写，而是在该位置执行插入操作，这种操作是通过容器的某个插入成员数实现的。STL提供了3种类型的插入迭代器：back_insert_iterator&lt;Container&gt; 使用了Container的push_back成员函数。Front_insert_iterator&lt;Container&gt; 使用了Container的push_front成员函数。Insert_iterator&lt;Container&gt; 使用了Container的insert成员函数。copy(deque1.begin(),deque1.end(),vector1.begin());//ERROR(vector1())=(deque1.begin())//会产生运行错误copy(deque1.begin(),deque1.end(),back_insert_iteraror&lt;vector&lt;int&gt;&gt;(vector1))//AC附：template&lt;typename Container&gt;inline back_insert_iterator&lt;Container&gt;back_inserter(Container&amp;x){return back_insert_iterator&lt;Container&gt;(x);}这样就可以：copy(deque1.begin(),deque1.end(),back_inserter(vector1));流迭代器：istream_iterator类提供输入迭代去，ostream_iterator类提供输出迭代器。常量迭代器和可变迭代器：根据运算符返回的结果是指针还是常量指针分别。如果是指针就可以对vector1执行vector=…操作，如果是常量就不能。例：vector&lt;int&gt;：：const_iterator; 迭代器的分类： 容器 迭代器 迭代器分类 dT a[n] Vector&lt;T&gt; deque&lt;T&gt; list&lt;T&gt; set&lt;T&gt; multiset&lt;T&gt; map&lt;Key,T&gt; multimap&lt;Key,T&gt; T vector&lt;T&gt;::iterator deque&lt;T&gt;::iterator list&lt;T&gt;::iterator set&lt;T&gt;::iterator multiset&lt;T&gt;::iterator map&lt;Key,T&gt;::iterator multimap&lt;Key,T&gt;::iterator 随机访问 随机访问 随机访问 双向访问 双向访问 双向访问 双向访问 双向访问 附：const_iterator就成为常量某某访问。 类属算法STL基本算法组织原地形式和复制形式：原地形式：sort(&amp;a[0],a[1000]);复制形式：reverse_sort(&amp;a[0],&amp;a[1000],&amp;b[0]);具有函数参数的算法：sort(&amp;a[0],&amp;a[1000],greater&lt;int&gt;());利用了模板参数greater的默认构造函数创建一个函数对象greater&lt;int&gt;(),并把它作为二元判断函数传给类属算法sort，一边对数组按升序排序find(InputIterator first,InputIterator last,constT&amp;value);find_if(InputIterator first,InputIterator last,Predicatepred);非可变序列算法：find:线性时间复杂度class GreaterThan50{public:bool operator()(intx)const{return x&gt;50;}};vector&lt;int&gt;::iterator wherefind_if(vector1.begin(),vector1.end(),GreaterThan50());adjacent_find:线性时间复杂度在序列中查找相邻且相等的两个元素，找到时返回只想两个元素中第一个迭代器。deque&lt;string&gt; play[5];…deque&lt;string&gt;::iteratori;i=adjacent_find(play.begin(),play.end());count:线性时间复杂度在序列中查找等于某个给定值的元素的个数。int final_count=count(&amp;a[0],&amp;a[9],1);final_count=count_if(&amp;a[0],&amp;a[9],bind2nd(not_equal_to&lt;int&gt;(),1);通过二元判断函数not_equal_to&lt;int&gt;和1作为参数传递给函数适配器band2nd,创建count_if一元判断函数。not_…和ban…定义在functional中。for_each:线性时间复杂度对序列中的每一个元素施加由函数f指定的操作。void print_list(string s){cout&lt;&lt;s&lt;&lt;endl;}list&lt;string&gt; dlist;….for_each(dlist.begin(),dlise.end(),print_list);mismatch&amp;equal:线性时间复杂度比较容器中两个区间内元素。equal如果相等返回true，反之返回false。mismatch的返回值是两个迭代器first1+i和first2+i组成的一个pair，表示第一个不想等元素的位置。如果相等返回last1和first2+(last1-first1).equal(deq.begin(),deq.end(),list1.begin());pair&lt;deque&lt;string&gt;::iterator,list&lt;string&gt;::iterator&gt;pair=mismatch(deq.begin(),deq.end(),list1.begin());search:时间复杂度O(n+m)给定两个迭代器区间，将后一个迭代器区间内的对象作为子序列，并在前一个区间内查找出现该子序列的第1个位置。Vector&lt;int&gt;::iterator K=search(vector1.begin(),vector1.end(),deque1.begin(),deque1.end()); 可变序列算法copy&amp;copy_backward:作用是将容器中的内容从一个区间复制到另一个区间。copy(first1,last1,first2);将[first1,last1-1]中的内容复制到[first2,last2]中，并返回last2。该算法是向前处理即不改变原来的顺序，copy_backward算法则相反。fill&amp;fill_n:具有线性时间复杂度。fill将某个值复制到某一区间的所有位置中,fill_n则是将某个值复制到某一区间的前n个位置中。fill(first,last,value);fill_n(first,n,value);generate：具有线性时间复杂度。连续调用gen函数last-first次，并用该函数的返回值来填充[first,last]。Template&lt;typename T&gt; class calc_square{TI;public:calc_square():i(0){} T operator()(){++I;return ii;}};generate(vector1.begin(),vector1.end(),calc_square&lt;int&gt;());partition&amp;stable_partition:具有时间复杂度。partition对于给定区间[first,last]和一个一元判断函数pred，它可以对该区间重新排序，以使所有满足判断函数pred的元素排在所有不满足pred的元素前面。stable_partition类似partition功能，并且可以使分类后的两部分保持原来的相对位置。Bool above40(int n){return(n&gt;40);}intsplit=partition(&amp;array1[0],&amp;array1[N],above40);split=stable_partition(&amp;array1[0],&amp;array1[N],above40);random_shuffle:具有线性时间复杂度。利用能够产生伪随机数的函数，对区间[first,last]中的元素混洗顺序后重新排列。random_shuffle(vector1.begin(),vector1.end());另外还有一种形式有三个参数，第三个参数是一个函数，这个函数提供不同的随机数发生器。remove:具有线性时间复杂度。从一个区间中删除所有等于某个特定值的元素，并且删除后其它元素的相对位置保持不变。vector&lt;int&gt;::iterator new_end=move(vector.begin(),vector.end(),0);replace:具有线性时间复杂度。把一个区间中所有等于某一特定值的元素用另一个值替换。replace(vector1.begin(),vector1.end(),’R’,’S’);reverse:具有线性时间复杂度。倒转区间元素的排列顺序。rotate:具有线性时间复杂度。对区间内的元素进行循环移动操作。rotate(first,middle,last);作用是将[first,last]区间内的元素循环左移middle-first个位置。函数返回后，原来[middle,last]中的元素将出现在区间[first,first+k]中，k=last-middle;而原来在[first,middle]中的元素将出现在区间[first+k,last]中，rotate算法的参数必须是双向迭代器。swap:具有常量时间复杂度。对两个值进行交换。swap(vector1,vector2);swap_ranges:具有线性时间复杂度。交换两个区间中的值，两个区间可以在不同的容器中。swap_ranges(first1,last1,first2);表示将[first1,last1]与[first2,first2-(last1-first1)]替换，规定两个区间不可以重叠。transform:具有线性时间复杂度。将某个函数作用到某一区间内的每一个元素上，并将该函数返回的结果保存到另一个区间中。该算法有两种形式：一种采用的是一元函数，作用到区间中的每个元素上；另一种是二元函数，同时作用到两个区间中相互对应的元素上。int sum(int val1,int val2){return val2+val1;}ostream_iterator&lt;int&gt; out(cout,” “);transform(&amp;array1[0],&amp;array[5],&amp;array2[0],out,sum);unique:具有线性时间复杂度。从输入序列中去掉所有有相邻的重复元素，对序列受那个的若干个相邻且相等的元素中只保留第一个元素。并且不改变容器内原来的元素相对位置和大小，变小后的区间将返回该区间的末尾迭代器。vector&lt;int&gt;::iteratornew_end=unique(vector1.begin(),vector1.end()); 排序相关的算法sort&amp;stable_sort&amp;partial_sort三种算法都是对随机访问序列排序，排序后的结果仍然保存在他们操作的容器中。sort需要对数的额外储存空间，partial_sort需要常量额外储存空间，stable需要线性额外储存空间。sort对长度为N的序列排序所用的平均比较次数为O(NlogN),但允许最坏O(NN)。partial_sort可以确保时间复杂度为O(NlogN).stable_sort时间复杂度也为O(NlogN)，最坏的情况下O(N(logN)(logN))。sort和partial_sort都不要求保持相等元素的相对位置。stable_sort则可以保持。nth_element:时间复杂度是线性的，最坏的情况下将减少到二次。实现分割，使分割后左边的元素小于或等于右边的元素。nth_element(v.begin(),v.begin()+N,v.end());binary_search&amp;lower_bound&amp;upper_bound&amp;equal_range:对于给定的区间[first,last]和元素x,如果存在x，对于binary_search返回真，lower_bound,upper_bound则返回一个迭代器i,分别指向x的第一个位置和最后一个位置的后一个位置。equal_range则是结合了lower_bound和upper_bound返回两个迭代器。Pair&lt;vector&lt;int&gt;::iterator,vector&lt;int&gt;::iterator&gt;pi=equal_range(v.begin(),v.end(),7);merge:具有线性四件复杂度合并两个有序区间，并把结果保存到另一个和两个输入区间均不重叠的区间。Inplace_merge则是将合并后的序列代替两个区间原来的序列，它的时间复杂度依赖可用的额外存储空间，如果没有额外的储存空间则时间复杂度是O(NlogN)。merge(vector1.begin(),vector1.end(),vector2.begin(),vector2.end(),vector3.begin());集合操作和有序结构Includes&amp;set_union&amp;set_intersection&amp;set_difference&amp;set_symmetric_difference:Includes检测区间[first1,last1]中的元素是否全部包含在另一个区间中[first2,last2]并返回一个真值。boolresult=includes(vector1.begin(),vector1.end(),vector2.begin(),vector2.end());set_union对两个区间的并集保存在区间[result,last]中，并返回last。Vector&lt;char&gt; setUnion;set_union(vector1.begin(),vector1.end(),vector2.begin(),vector2.end(),back_inserter(setUnion));set_difference得到一个集合这个集合中的元素属于第一个区间但是不属于第二个区间。set_intersection得到两个输入序列的交集。set_symmetric_difference该集合仅属于两个集合中的一个，而不包含交集。和set_union算法一样将结果保存在result集合中。堆操作堆：first所指向的元素是区间中的最大元素。可以通过pop操作删除first指向的元素，push操作向序列中插入元素，两种操作时间复杂度是对数，返回值仍然是一个堆。make_heap&amp;pop_heap&amp;push_heap&amp;sort_heap:make_heap利用[first,last]中的元素构造一个堆，并保存在原区间中。算法的时间复杂度是线性的，最多需要3N次比较。push_heap假定[first,last-1]中已经包含了一个堆，该算法是把[first,last]重新整理为一个堆（从而把last-1位置上的元素压入堆中）。pop_heap假定[first,last]中已经包含了一个堆，该算法作用就是将first位置上的值和last-1位置上的值交换，然后把[first,last-1]整理为一个堆。pop和push时间复杂度都是O(NlogN)。sort_heap作用是堆储存在堆中的元素进行排序。算法的时间复杂度是O(NlogN)。 最小值和最大值min&amp;max&amp;min_element&amp;max_elementmin和max分别以两个元素作为参数，返回相应的值。min_element和max_element返回指向输入序列中最小和最大的迭代器。vectord&lt;int&gt;::iterator k=max_element(vector1.begin(),vector1.end());词典序比较如果e1&lt;e1返回true,否则返回false.bool result=lexicographical_compare(vector1.begin(),vector1.end(),vector2.begin(),vector2.end());排列生成器：next_permutation按字典序将序列变换为下一个排列；prev_permutation变换为前一个排序。 通用数值算法accumulate计算给定区间中值的累加和。累加：int result=accumulate(&amp;x[0],&amp;x[20],0);累积：result=accumulate(&amp;x[0],&amp;x[5],1,multiplies&lt;int&gt;());partial_sum计算和前t项和的序列保存在原序列中，也可以保存在另一序列中。partial_sum(&amp;x1[0],&amp;x1[N],&amp;x1[0]);partial_sum(&amp;x1[0],&amp;x1[N],&amp;x2[0]);adjacent_differencej计算n项与n-1项只差。inner_product计算输入序列的内积。12+23+34…int result=inner_product(&amp;x1[0],&amp;x1[N],&amp;x2[0],0);(1+2)(2+3)…intresult=inner_product(&amp;x1[0],&amp;x1[N],&amp;x2[0],1,multiplies&lt;int&gt;(),plus&lt;int&gt;()); 序列容器向量构造序列vector&lt;T&gt; ();//vector&lt;T&gt; vector1;vector&lt;T&gt;(n,value);//vector&lt;T&gt;vector1(n,value);vector&lt;T&gt;(n);//vector&lt;T&gt; vector1(n); 拷贝构造函数vector&lt;T&gt; vector1(3);//其实是调用拷贝构造函数三次。char name[]=”abc”;vector&lt;char&gt;George(name,name+2);//使用拷贝构造函数，向其它向量中的任意区间拷贝数据。 插入vector&lt;char&gt;::iteratori=vector1.begin();vector2.push_back(i);//使用push_back成员在序列尾端插入元素。vector2.insert(vector2.begin();*i);//在vectoe2.begin()位置插入。两者都具有常数时间复杂度。Insert成员函数还可以向序列中插入元素的n个拷贝，或者另外一个序列的某个区间vector1.insert(position,n,x);vector1.insert(position,first,last);insert成员函数的时间复杂度是线性的。 插入操作在内存重新分配的操作vector1.capaciry();//返回当前所分配的内存快的大小。vector1.reserve(n)//重新为vector1分配大于n的内存块。 删除cout&lt;&lt;vectotor1.back();vector1.pop_back();//执行的操作先显示最后元素然后删除。vector1.erase(vector1.begin());vector&lt;char&gt;::iteratorj;vector1.erase(j–);vector1.erase(j,j+2);//erase成员函数的几种形式。//erase函数将使所有删除点之后的迭代去失效，但是删除点上和删除点之前的迭代去则没有影响。//vector1.erase(j++);将无法工作。 访问器iterator begin() 返回指向向量起始点的迭代器。iteratorend() 返回指向向量末尾的迭代器。iteratorrebgin() 返回指向向量起始点的反向迭代器，用来对向量进行反响遍历。Iteratorrend() 返回指向向量末尾的反向迭代器，用来对向量进行反向遍历。size_typesize()const 返回向量中的元素个数。size_typemax_size()const 返回向量最多可以保存的元素的个数。size_typecapacity()const 返回向量中可以保存的元素的个数。boolempty()const 如果向量中没有元素，则返回真，否则返回假。referencefront() 返回向量中的第一个元素的引用。referenceback() 返回向量中的最后一个元素的引用。referenceoperator 返回向量中第n个元素的引用。referenceat(size_type n) 如果n在向量区间之内，则返回第n个元素的引用。 相等和小于的关系等于==：两个容器中的序列必须大小相等。根据定义在元素类型上的==操作，对应位置上的元素必须相等。//a==b的定义为：a.size()=b.size()&amp;&amp;equal(a.begin(),a.end(),b.begin());小于&lt;:对于任意两个相等类型的容器a和b，如果其元素类型是T，而且&lt;是定义在T上的严格弱序关系，则定义a&lt;b为：lexicographical_cimpaare(a.begin(),a.end(),b.begin(),b.end());其它的关系操作(&gt;,&lt;=,&gt;=)都是根据&lt;定义的。 赋值STL对所有容器都定义了赋值运算符=。赋值后x==y成立。操作的时间复杂度是O(N),N=max(x.size(),y.size())。模板成员函数assign: template&lt;typenameInputIterator&gt;voidassign(InputIterator first,InputIterator last);功能上，该函数和下面的语句是等价的：erase(begin(),end());insert(begin(),first,last); swap成员函数用来交换两个容器的内容。vector1.swap(vector2)的作用是互换vector1和vector2中的值。具有常数的时间复杂度。双端队列双端队列的操作和向量的操作大部分是类似的。区别主要体现在一下两点：第一点是性能在非末端的删除插入操作都优于向量，insert操作的时间复杂度是哈如点到最近的序列断点的距离成正比。还有还提供了push_front和pop_front成员，时间复杂度是常数。第二点是插入操作没有reserve，capacity成员函数，插入操作可能使迭代器永久失效。第三点是没有访问器capacity。链表链表和前面两个容器有一定的区别：其任意位置插入删除操作时间复杂度都是常数。插入操作不会使任何迭代器失效，删除操作只会使被删除元素的迭代器失效。倒转操作：reverse类属算法仍然可以用，但是时间开销就比较大。因此它提供了反向链接链表操作list1.reverse();插入操作：push_back和push_front和insert。删除操作：erase并且erase(j++)是成立的。拼接操作：spllice无论涉及多少元素它的时间复杂度都是常数。list1.splice(i1,list2),其中i1是list1的一个有效迭代器。该函数的作用是把list2的内容插入到i1前面，在插入完成后list2为空链表。list1和list2不可以是相同的链表。list1.splice(i1,list2,i2)，其中i1是list1的一个有效迭代器，i2是list2的一个可引用的有效迭代器。该函数的作用是删除i2所引用的元素，并把该元素插入到list1中的i1前面。list1和list2可以是相同的链表。list1.splic（i1，list2，i2，j2），其中i1是list1的一个有效迭代器，[i2,j2]是list2中的一个有效区间。该函数的作用是删除i2和i1中间的元素，并把这些元素插入到list1中的i1前面。list1和list2可以是相同的链表。其中前面两种形式的splice函数的时间复杂度是常数。如果list1和list2是相同的链表，则第三种形式的时间复杂度是常数，否则其时间复杂度为线性。排序相关的算法：类属算法sort需要随机访问迭代器，因此该算法不能用于链表。但是我们可以利用链表的sort成员函数来对链表进行排序。list1.sort();另外还有一种删除链表中相邻重复元素的成员函数。list.unique();sort成员函数还有一种形式，可以使用给定的比较函数进行排序：template&lt;typenameCompare&gt;voidsort(Compare comp);unique成员函数也有一种形式，可以用给定的二元判决函数对相邻元素进行比较。这些成员函数与类属算法的不同之处在于采用了重新链接的方式而不是赋值的方式进行template&lt;typenameBinaryPredicate&gt;voidunique(BinaryPredicate comp); merge:将当前链表与另一个链表合并，其中假定两个链表都是有序的。void merge(constlist&lt;T&gt;&amp;otherList);template&lt;typenameCompare&gt;void merge(constlist&lt;T&gt;&amp;otherList,Compare comp);清除：remove：作用是删除链表中等于某个给定值或满足某个判决函数的所有元素。voidremove(const T&amp;value);template&lt;typenamePredicate&gt;voidremove_if(Predicate pred);与其它序列类属算法不同，链表的remove成员函数会减小链表的大小，其减小的数量等于删除元素的个数。访问器：除了capacity、operator[]和at，链表类提供了所有向量类所提供的容器访问器。相等和小于关系：和向量一样。赋值：也有相同的定义，复杂度也相同。]]></content>
  </entry>
  <entry>
    <title><![CDATA[word纠错设置]]></title>
    <url>%2F2019%2F05%2F16%2F80759403%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[设置windows10 的默认应用]]></title>
    <url>%2F2019%2F05%2F16%2F80759323%2F</url>
    <content type="text"><![CDATA[先按win键]]></content>
  </entry>
  <entry>
    <title><![CDATA[window10设置文件的默认打开方式]]></title>
    <url>%2F2019%2F05%2F16%2F80759300%2F</url>
    <content type="text"><![CDATA[//以下是设置图片管理器的默认文件打开方式左键点击“保存”然后退出。]]></content>
  </entry>
  <entry>
    <title><![CDATA[设置windows10相应文件格式的打开方式]]></title>
    <url>%2F2019%2F05%2F16%2F80759166%2F</url>
    <content type="text"><![CDATA[上一篇我们讲到了卸载自带软件的方法，其原因就是打开方式不能根据自己想要的方式打开。而这里正是解决这个问题的更加符合要求的方式。设置某格式打开方式是如下：//该经验是设置将图片管理器设置可以打开.gif后缀文件，其它文件格式可以依次类推首先我们按win+r键打开运行窗口如下：然后我们打开注册表编辑器，在运行窗口中输入regedit点击确认，具体操作如上图找到目录计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsPhoto Viewer\Capabilities\FileAssociations如下：将新值设置为.gif后在右键点击文件然后左键点击“修改”然后退出注册表，再右键.gif后缀的文件选择打开方式就会有图片管理器选项了。 附：如果你想要使用Windows照片查看器查看.png后缀的文件，那么数值名称写为.png，数值数据还是为PhotoViewer.FileAssoc.Tiff。换句话说，只要你想更改任何格式的图片文件打开方式，那么数值名称就是.格式名称，数值数据一直为PhotoViewer.FileAssoc.Tiff。]]></content>
  </entry>
  <entry>
    <title><![CDATA[windows10卸载自带软件的方法]]></title>
    <url>%2F2019%2F05%2F16%2F80759066%2F</url>
    <content type="text"><![CDATA[大部分手机用户可能因为手机自带软件对我们没有用想卸载，但是手机在没有刷机的情况下是不能卸载的。而电脑不同，但是我们想卸载的原因可能和我们想卸载手机软件是不同的，就比如说我，我当时是因为电脑自带软件打开太慢，而当时又想用自己设置的软件默认打开，但是window10的设置我设置了多次都没有用，所以就产生了想卸载它的想法。卸载自带软件的步骤如下：首先我们按window键然后在所有程序列表中找到Windows powershell文件夹打开，找到第一个Windows power shell程序，右键以管理员运行，如下图运行结果如下比如我们要卸载3d画图软件我们在命令行输入Get-AppxPackage Paint3D |Remove-AppxPackage其它的自带软件卸载命令如下：OneNote：Get-AppxPackageOneNote | Remove-AppxPackage3D：Get-AppxPackage3d | Remove-AppxPackageCamera相机：Get-AppxPackagecamera | Remove-AppxPackage邮件和日历：Get-AppxPackagecommuni | Remove-AppxPackage新闻订阅：Get-AppxPackagebing | Remove-AppxPackageGroove音乐、电影与电视：Get-AppxPackagezune | Remove-AppxPackage人脉：Get-AppxPackagepeople | Remove-AppxPackage手机伴侣（Phone Companion）：Get-AppxPackagephone | Remove-AppxPackage照片：Get-AppxPackagephoto | Remove-AppxPackage纸牌游戏：Get-AppxPackagesolit | Remove-AppxPackage录音机：Get-AppxPackagesoundrec | Remove-AppxPackageXbox：Get-AppxPackagexbox | Remove-AppxPackage]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu与windows10双系统安装]]></title>
    <url>%2F2019%2F05%2F16%2F80748423%2F</url>
    <content type="text"><![CDATA[第一步将ubuntu写入u盘安装ultralso软件，选择继续使用软件（安装系统只要制作一次，没有必要买）进入软件界面，再上面的菜单栏中选择，文件-&gt;打开进入如下界面，然后进入你要写入u盘的ios文件所在的文件夹选择你要写入的ios文件然后点击打开再点击菜单栏的启动选项-&gt;写入硬盘映像在磁盘驱动器中选择你要写入ios文件的U盘（如果不要找打开我的电脑，查看u盘的盘符）在写入方式中选择usb-hdd+然后点击便捷启动-&gt;写入新硬盘主引导纪录(MBR)-&gt;usb-hdd+弹出提示窗口，选择是，再弹出提示窗口，选择确认再在出现的提示窗口选择是。进入如下界面，等待一段时间。刻录完成点击返回。第二步安装系统u盘插到电脑上重启电脑//进入bios会根据电脑牌子的不同有不同的进入方式，可以百度。一般是f10或者f2，笔记本的话有fn键就fn+f10或fn+f2，以前我笔记本老是进不去我直接戳复位键进入的。进入u盘的bios系统，设置电脑的第一启动项为u盘，再重启电脑进入u盘系统如下图点击桌面的install然后出现语言选择，找到汉语，点击下一步（continue）再选择键盘布局，选择汉语或者English都可以也可以选择下面的测试键盘来测试你的键盘然后选择继续，接下来真正进入安装系统的重要设置了如果不是安装双系统可以不要更改，如果是安装双系统就按照上图选择点击继续这是分区设置界面，给系统设置分区系统结构，选自空闲，然后点击+号会出现如下弹窗一般的用户没有对系统有过高要求的可以按照我的方式设置分区我的是设置一个/分区15G，/swap分区1.5G，/boot分区500m，/home分区把剩下的都分给它；其它都是默认选项，然后ok。在选择主分区和逻辑分区的时候我百度了一下，然后我选择了逻辑分区。分区格式是ext4。设置好分区后就可以点击选在安装了写后感，其实以前就有装过很多次双系统的经历，而且以前在安装双系统的时候由于不是ubuntu系统还会遇到很多的安装问题，而且英文界面看不同，但是其实是大同小异的，先是制作U盘然后再安装系统，安装系统的时候做一些语言时间用户地点的简单设置，还有磁盘分区设置网络设置的一些稍微复杂一点的设置等。以前映像比较深刻的一次是centos在选择分区的时候，它不像ubuntu那样有图形界面的选择，他是通过命令行设置，而且是英文界面又看不懂，如果遇到那样的问题网上也是能找到的设置方法的。其实不能忘记的是安装windows10和centos7双系统的时候，真的是把我的意志给消磨尽了，它不仅出现了各种各样的问题卡住安装的进程，而且在安装成功后居然不能找到window10的引导了，导致安装完成后只能进入centos7系统，如果遇到这种情况也不要急，因为windows中的所有文件是没有丢失的，只要centos7系统文件格式化就可以了。但是后来我在网上找类似的经验的时候，看到一些成功的例子，虽然后来我去测试过那些解决办法，但是最后我还是没有测试成功，因为在安装的时候我又遇到了好多问题让我难以前进。这一次我写这个也有一些是因为它的失败吧。把失败或者成功的经历写下来，以后看到就能更加清晰的回忆起来当时的教训与体会。]]></content>
  </entry>
  <entry>
    <title><![CDATA[磁盘使用率达到100%]]></title>
    <url>%2F2019%2F05%2F16%2F80736472%2F</url>
    <content type="text"><![CDATA[磁盘使用率达到100%问题描述：电脑开机后电脑磁盘使用率100%且居高不下，通过在网上搜索办法，关闭服务家庭组、superfetch服务没有多大效果，开始关掉super fetch后发现有了效果，后来打开电脑后又出现了。我开始以为是电脑自启了服务然后我又点开设置发现关闭的服务没有启用，所以不是服务的问题。解决办法：我再次去网上搜索后有一条贴说它将分区太多的分区删除后发现问题解决了，然后将注意了转移到磁盘文件调用这一块来，我回忆一下好像自从我将一些文件安装在e盘之后电脑就开始出现运行不顺畅的情况，然后我就开始找删以前安装在e盘的软件，在删的同时我打开任务管理器发现删到最后一个在外分区的软件的时候还是没有降下来，我看了一下使用磁盘的服务和软件后发现有一款叫Tiwork的程序占用占用非常大，然后我又在网上搜索这款软件，发现这款软件是在电脑装其他软件和卸载其他软件的时候才会出现，所以我就等到电脑卸载最后的软件的时候再打开任务管理器的，这个是时候磁盘占用也已经降到20%一下。因此这个问题才真正圆满解决。]]></content>
  </entry>
  <entry>
    <title><![CDATA[汇编语言基础]]></title>
    <url>%2F2019%2F05%2F16%2F80705550%2F</url>
    <content type="text"><![CDATA[标志寄存器FLAGS 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF AF PF CF 标志寄存器FLAGSCF：进位标志 PF：奇偶标志 AF：调整标志ZF：零标志 SF：符号标志 OF：溢出标志DF：方向标志 IF：中断允许标志 TF：陷阱标志 r8/r16 任意一个8/16位通用寄存器 reg 代表r8或r16 seg 段寄存器 m8/m16 一个8/16位存储器操作数单元（包括所有主存寻址方式） mem 代表m8或m16 i8/i16 一个8/16位立即数 imm 代表i8或i16 dest 目的操作数 src 源操作数 操作数代号一、通用数据传送指令1. MOVmov reg/mem,imm //注意不允许立即数传至段寄存器mov reg/mem/seg,reg //不能同时为存储单元mov reg/seg,mem //IP不能为目的操作数mov reg/mem,seg //不能直接改变CS的值，会引起程序执行混乱2. XCHG:交换指令xchg reg,reg/mem //不能为CS，CS不能更改，不能同时为段寄存器xchg reg/mem,reg //不能同时为存储器3. XLAT:换码指令用于将BX指定的缓存区中，al指定的位移处的数据取出赋值给alxlat labelxlat ;al&lt;-ds:[bx+al] 二、堆栈操作指令1. PUSH:进栈指令 push r16/m16/seg ;SP&lt;-SP-2,SS:[SP]&lt;-r16/m16/seg //低字节放低地址2. POP:出栈指令 popr16/m16/seg三、标志传送指令(1)标志寄存器传送1. LAHF ;AH&lt;-FLAGS的低字节2. SAHF ;FLAGS的低字节&lt;-AH3. PUSHF ;SP&lt;-SP-2,SS:[SP]&lt;-FLAGS4. POPF ;FLAGS&lt;-SS:[SP],SP&lt;-SP+2(2)标志位操作 clc CF&lt;-0 stc CF&lt;-1 cmc CF&lt;-∽CF cld DF&lt;-0 std DF&lt;-1 cli IF&lt;-0 sti IF&lt;-1 四、地址传送指令1.LEA有效地址传送指令 LEAr16,mem ;r16&lt;-mem的有效地址EA2.指针传送指令 LDSr16,mem ;r16&lt;-mem,DS&lt;-mem+2 LESr16,mem ;r16&lt;-mem,ES&lt;-mem+2五、算数运算符指令 （1）加法指令 1.ADD addreg,imm/reg/mem addmem,imm/reg 2.ADC:带进位加法（同上） 3.INC增量指令 increg/mem （2）减法指令 1.SUB（似ADD） 2.SBB（似ADC） 3.DEC（似INC） 4.NEG：求补指令（取反） negreg/mem ;reg/mem&lt;-0-reg/mem 5.CMP:将目的操作数减去源操作数，但结果不送回目的操作数。引向标志。 cmpreg,imm/reg/mem ;reg-imm/reg/mem cmpmem,imm/reg ;mem-imm/reg （3）乘法指令 1.MUL:无符号数乘法指令 mulr8/m8 ;无符号字节乘：AX&lt;-ALr8/m8 mulr16/m16 ;无符号字乘：DX.AX&lt;-AXr16/m16 2.IMUL:有符号数乘法指令 imulr8/m8 ;有符号字节乘 imulr16/m16 ;有符号字乘 (4)除法指令 1.DIV无符号除法 divr8/m8 ;无符号除法：AL&lt;-AX÷r8/m8的商 ;AH&lt;-AX÷r8/m8的余数 divr16/m16 ;无符号除法：AX&lt;-DX.AX÷r16/m16的商 ;DX&lt;-DX.AX÷r16/m16 2.IDIV有符号除法 idivr8/m8 idivr16/m16 (5)符号扩展指令 1.cbw ;AL符号扩展成AX 2.cwb ;AX符号扩展为DX.AX (6)十进制调整指令 1.压缩BCD码调整指令 daa ;AL&lt;-将AL中的加和调整为BCD码 ;在ADD/ADC AL,X ;语句之后对AL调整 das ;AL&lt;-将AL中的减差调整为压缩BCD码 DAA和DAS指令对OF标志没有定义，按结果影响其他标志 2.非压缩BCD码指令 aaa ；AL&lt;-将AL中的加和调整为非压缩BCD码 aas ；AL&lt;-将AL中的减差调整为非压缩BCD码 aam ；AX&lt;-将AX中的乘积调整为非压缩BCD码 aad ；AX&lt;-将AX中的非压缩码扩展为二进制数 ；即：AL&lt;-10*AH+AL,AH&lt;-0三、位运算类操作 (1)逻辑运算指令 1.逻辑与指令AND anddest，src ；dest&lt;-dest^src,将两个操作数执行按位的逻辑与运算 2.逻辑或指令OR ordest，src ；dest&lt;-destVsrc 3.逻辑抑或指令XOR xordest，src ；dest&lt;-dest⊕src 4.逻辑非指令NOT notreg，mem ；reg&lt;-∽reg/mem 5.测试指令TEST testdest，src ；dest^src,对两个操作数执行按位与运算，但结果不回；到目的数 (2)位移指令 1.逻辑左移shl reg/mem,1/CL ;补0 2.逻辑右移shr reg/mem,1/CL ;补0 3.算术左移sal reg/mem,1/CL ;补0 4.算数术右移sar reg/mem,1/CL ;最高位不变 (3)循环移位指令 1.不带进位 rolreg/mem，1/CL ;左移 rcrreg/mem，1/CL 2.带进位 rclreg/mem，1/CL ;右移 rcrreg/mem，1/CL]]></content>
  </entry>
  <entry>
    <title><![CDATA[查找算法]]></title>
    <url>%2F2019%2F05%2F16%2F80682180%2F</url>
    <content type="text"><![CDATA[静态查找表//顺序表查找的数据类型#define MAXL 100typedef int KeyTypetypedef struct{ KeyType key; InfoType data;}NodeType;typedef NodeType SeqList[MAXL]; 顺序查找：它是一种最简单的查找方法。基本思路是：从表的一段开始顺序扫描现行表，依次将扫描到的关键字和给定k相比较。 有序表查找之折半查找：折半查找是一种效率较高的查找方法。它要求线性表是有序的。它的时间复杂度是O(n log2n).设R[low…high]是当前查找的区间，首先确定该区间的中点位置mid=(low+high)/2,然后待查找的k值与R[mid].key比较，若相等查找成功，若&gt;将区间确定为R[mid…high]继续查找，若&lt;将区间确定为R[low…mid]继续查找。int Binsearch(SeqList R,int n,KeyType k){ int low=0,high=n-1,mid; while(low&lt;=high) { mid=(low+high)/2; if(R[mid].key==k)return mid+1; if(R[mid].key&gt;k)high=mid-1; else low=mid+1; } ruturn 0;} 三分查找算法int BinSearch(SeqList R,int n,KeyType k){ int low=0,high=n-1,mid,mid1; while(low&lt;=high) { mid=(high-low)/3+low; mid1=(high-low)*2/3+low; if(R[mid].key==k) return mid+1; if(R[mid].key&gt;k) high=mid-1; else { low=mid+1; if(R[mid1].key==k) return mid1+1; if(R[mid1].key&gt;k) high=mid1-1; else low=mid1+1; } } return 0;} 索引顺序表的查找//索引表的数据类型如下#define MAXI&lt;索引表的最大长度&gt;typedef struct{ KeyType key; int link;}IdxType;typedef IdxType IDX[MAXI];采用折半查找索引表的平均查找长度为：ASLb=ASLbn+ASLs=log2(b+1)-1+(s+1)/2 静态树表的查找动态查找表 二叉排序树 二叉平衡树 B-树和B+树 键树哈希表]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序算法比较]]></title>
    <url>%2F2019%2F05%2F16%2F80681731%2F</url>
    <content type="text"><![CDATA[排序算法的时间效率： 平均情况 最好情况 最坏情况 基数排序 归并排序 快速排序 希尔排序 插入排序 选择排序 O(n) O(nlogn) O(nlogn) O(n^1.5) O(n^2) O(n^2) O(n) O(nlogn) O(nlogn) O(n) O(n) O(n^2) O(n) O(nlogn) O(n^2) O(n^1.5)或O(n^2) O(n^2) O(n^2) 函数的增长率函数： n nlogn n^1.5 n^2 10 33 32 10^2 10^2 664 10^3 10^4 10^3 9966 31623 10^6 10^4 132877 10^6 10^8 10^5 1660964 31662777 10^10 10^6 19931569 10^9 10^12 排序效率分析 ：当n为小一点的数时效率O(n^2)的排序算法还行，当n较大时，就不能使用了。当n为100时希尔排序在平均情况下几乎和快速排序一样快，但当n为10^6时，平均情况快排快的多。如果元素个数相对较少，或者接近有序，则插入排序时一种不错的选择。否则快排通常更可取。归并排序很适合用于元素太多无法全部放进内存而存放在外部文件中的情形。排序的类型：插入排序 直接插入排序 二路插入排序 希尔排序快速排序选择排序 简单选择排序（直接选择排序） 树形选择排序 堆排序归并排序基数排序 多关键字排序 链式基数排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[eclipse编辑的代码在dos下运行的问题]]></title>
    <url>%2F2019%2F05%2F16%2F80644716%2F</url>
    <content type="text"><![CDATA[dos下也不能编译eclipse以前编辑的文件。因为eclipse文件里面有package**语句。如果非要在dos下编译那就需要将程序里面的package语句注释掉，在前面加两条反斜杠\package另外在eclipse下编译出来的.class文件，就我的的编译器而言是不可以的，可能是jdk不同的问题，具体我也不清楚，以后有时间再研究。]]></content>
  </entry>
  <entry>
    <title><![CDATA[eclipse的@override报错问题]]></title>
    <url>%2F2019%2F05%2F16%2F80473252%2F</url>
    <content type="text"><![CDATA[要解决报错就要知道报错的原因。在继承java父类的时候我们通过自动生成的时候会给我们自动加上@override。@Override是Java5的元数据，自动加上去的一个标志，告诉你说下面这个方法是从父类/接口 继承过来的，需要你重写一次，这样就可以方便你阅读，也不怕会忘记@Override是伪代码,表示重写(当然不写也可以),不过写上有如下好处: 1&gt;可以当注释用,方便阅读 2&gt;编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错 比如你如果没写@Override而你下面的方法名又写错了,这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)使用该标记是为了增强程序在编译时候的检查，如果该方法并不是一个覆盖父类的方法，在编译时编译器就会报告错误。在父类生成这个的时候报错我将“@override”删去就就可以了。但是当实现接口的时候，发现删掉还是会报错会报错。 把@override不能从根本上解决问题这是jdk的问题，@Override是JDK5就已经有了，但是不支持对接口的实现，认为这不是Override而报错。JDK6修正了这个Bug，无论是对父类的方法覆盖还是对接口的实现都可以加上@Override。 要解决该问题，首先要确保机器上安装了jdk 1.6，然后，选择eclipse菜单Windows-&gt;Preferences–&gt;java-&gt;Compiler–&gt;compiler compliance level选择 1.6，刷新工程，重新编译。如果问题还没解决，就在报错的工程上，鼠标右键选择 Properties–&gt;Java Compiler–&gt;compiler compliance level 中选择 1.6,刷新工程，重新编译。]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树的宽度]]></title>
    <url>%2F2019%2F05%2F16%2F76855889%2F</url>
    <content type="text"><![CDATA[二叉树的宽度就是每一层的宽度的最大值要求二叉树的宽度，不许先求出每一层的宽度，求每一层的宽度必须知道每一层的元素作为初学的我，看到树本来就是从括号表示来的，所以我在这里借助里开始时候的树的括号表示的字符串，对每一个元素都在字符串中查找并进进行括号匹配返回留下有括号的个数就是树的节点的层次。其实，我的最外面的一层循环就是层次查找，所以每一次都是将同一层的元素放在一块。int WidthBT(BTNode b,char str[]){ BTNode St[MaxSize],*p; int front,rear,tier,tier1=0; int s=1,max=0; char ch; front=rear=-1; if(b!=NULL) { rear++; St[rear]=b; while(front!=rear) { p=St[front]; ch=str[0]; int j=0; char ch1[MaxSize]; int top=-1; front=(front+1)%MaxSize; tier=0; while(str[j]!=p-&gt;date) { if(str[j]==’(‘) ch1[++top]=’(‘; else if(str[j]==’)’) top–; j++; } tier=top+1; if(tier1==tier) s++; else { max=s&gt;max?s:max; s=1; } tier1=tier; if(p-&gt;lchild!=NULL) { rear=(rear+1)%MaxSize; St[rear]=p-&gt;lchild; } if(p-&gt;rchild!=NULL) { rear=(rear+1)%MaxSize; St[rear]=p-&gt;rchild; } } } return max;}初学数据结构，不太懂，希望看到的大神能够多多指教。]]></content>
  </entry>
  <entry>
    <title><![CDATA[c语言字符串处理函数]]></title>
    <url>%2F2019%2F05%2F16%2F76208942%2F</url>
    <content type="text"><![CDATA[函数名: strcpy 功 能: 拷贝一个字符串到另一个 用 法: char stpcpy(char destin, char source); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string[10]; char str1 = “abcdefghi”; stpcpy(string, str1); printf(“%sn”, string); return 0; } 函数名: strcat 功 能: 字符串拼接函数 用 法: char strcat(char destin, char source); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char destination[25]; char blank = “ “, c = “C++”, Borland = “Borland”; strcpy(destination, Borland); strcat(destination, blank); strcat(destination, c); printf(“%sn”, destination); return 0; } 函数名: strchr 功 能: 在一个串中查找给定字符的第一个匹配之处 用 法: char strchr(char str, char c); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char string[15]; char ptr, c = ‘r’; strcpy(string, “This is a string”); ptr = strchr(string, c); if (ptr) printf(“The character %c is at position: %dn”, c, ptr-string); else printf(“The character was not foundn”); return 0; } 函数名: strcmp 功 能: 串比较 用 法: int strcmp(char str1, char str2); 看Asic码，str1&gt;str2，返回值 &gt; 0；两串相等，返回0程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “aaa”, buf2 = “bbb”, buf3 = “ccc”; int ptr; ptr = strcmp(buf2, buf1); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); else printf(“buffer 2 is less than buffer 1n”); ptr = strcmp(buf2, buf3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 3n”); else printf(“buffer 2 is less than buffer 3n”); return 0; } 函数名: strncmpi 功 能: 将一个串中的一部分与另一个串比较, 不管大小写 用 法: int strncmpi(char str1, char str2, unsigned maxlen); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBB”, buf2 = “bbb”; int ptr; ptr = strcmpi(buf2, buf1); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strcpy 功 能: 串拷贝 用 法: char strcpy(char str1, char str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string[10]; char str1 = “abcdefghi”; strcpy(string, str1); printf(“%sn”, string); return 0; } 函数名: strcspn 功 能: 在串中查找第一个给定字符集内容的段 用 法: int strcspn(char str1, char str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;alloc.h&gt; int main(void) { char string1 = “1234567890”; char string2 = “747DC8”; int length; length = strcspn(string1, string2); printf(“Character where strings intersect is at position %dn”, length); return 0; } 函数名: strdup 功 能: 将串拷贝到新建的位置处 用 法: char strdup(char str); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;alloc.h&gt; int main(void) { char dup_str, string = “abcde”; dup_str = strdup(string); printf(“%sn”, dup_str); free(dup_str); return 0; } 函数名: strcmp 功 能: 比较字符串str1和str2。用 法: int strcmp(char str1, char str2); 说 明: 当s1&lt;s2时，返回值&lt;0 当s1=s2时，返回值=0 当s1&gt;s2时，返回值&gt;0 即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇’\0’为止。程序例: #include&lt;stdio.h&gt; #include&lt;string.h&gt; void main() { char string[20]; char str[3][20]; int i; for(i=0;i&lt;3;i++) gets(str[i]); if(strcmp(str[0],str[1])&gt;0) strcpy(string,str[0]); else strcpy(string,str[1]); if(strcmp(str[2],string)&gt;0) strcpy(string,str[2]); printf(“\nThe largest string is %s\n”,string); } 函数名: stricmp 功 能: 以大小写不敏感方式比较两个串 用 法: int stricmp(char str1, char str2); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBB”, buf2 = “bbb”; int ptr; ptr = stricmp(buf2, buf1); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strerror 功 能: 返回指向错误信息字符串的指针 用 法: char strerror(int errnum); 程序例: #include &lt;stdio.h&gt; #include &lt;errno.h&gt; int main(void) { char buffer; buffer = strerror(errno); printf(“Error: %sn”, buffer); return 0; } 函数名: strcmpi 功 能: 将一个串与另一个比较, 不管大小写 用 法: int strcmpi(char str1, char str2); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBB”, buf2 = “bbb”; int ptr; ptr = strcmpi(buf2, buf1); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strncmp 功 能: 串比较 用 法: int strncmp(char str1, char str2, int maxlen); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “aaabbb”, buf2 = “bbbccc”, buf3 = “ccc”; int ptr; ptr = strncmp(buf2,buf1,3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); else printf(“buffer 2 is less than buffer 1n”); ptr = strncmp(buf2,buf3,3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 3n”); else printf(“buffer 2 is less than buffer 3n”); return(0); } 函数名: strncmpi 功 能: 把串中的一部分与另一串中的一部分比较, 不管大小写 用 法: int strncmpi(char str1, char str2); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBBccc”, buf2 = “bbbccc”; int ptr; ptr = strncmpi(buf2,buf1,3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strncpy 功 能: 串拷贝 用 法: char strncpy(char destin, char source, int maxlen); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string[10]; char str1 = “abcdefghi”; strncpy(string, str1, 3); string[3] = ‘’; printf(“%sn”, string); return 0; } 函数名: strnicmp 功 能: 不注重大小写地比较两个串 用 法: int strnicmp(char str1, char str2, unsigned maxlen); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBBccc”, buf2 = “bbbccc”; int ptr; ptr = strnicmp(buf2, buf1, 3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strnset 功 能: 将一个串中的所有字符都设为指定字符 用 法: char strnset(char str, char ch, unsigned n); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string = “abcdefghijklmnopqrstuvwxyz”; char letter = ‘x’; printf(“string before strnset: %sn”, string); strnset(string, letter, 13); printf(“string after strnset: %sn”, string); return 0; } 函数名: strpbrk 功 能: 在串中查找给定字符集中的字符 用 法: char strpbrk(char str1, char str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string1 = “abcdefghijklmnopqrstuvwxyz”; char string2 = “onm”; char ptr; ptr = strpbrk(string1, string2); if (ptr) printf(“strpbrk found first character: %cn”, ptr); else printf(“strpbrk didn’t find character in setn”); return 0; } 函数名: strrchr 功 能: 在串中查找指定字符的最后一个出现 用 法: char strrchr(char str, char c); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char string[15]; char ptr, c = ‘r’; strcpy(string, “This is a string”); ptr = strrchr(string, c); if (ptr) printf(“The character %c is at position: %dn”, c, ptr-string); else printf(“The character was not foundn”); return 0; } 函数名: strrev 功 能: 串倒转 用 法: char strrev(char str); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char forward = “string”; printf(“Before strrev(): %sn”, forward); strrev(forward); printf(“After strrev(): %sn”, forward); return 0; } 函数名: strset 功 能: 将一个串中的所有字符都设为指定字符 用 法: char strset(char str, char c); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string[10] = “123456789”; char symbol = ‘c’; printf(“Before strset(): %sn”, string); strset(string, symbol); printf(“After strset(): %sn”, string); return 0; } 函数名: strspn 功 能: 在串中查找指定字符集的子集的第一次出现 用 法: int strspn(char str1, char str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;alloc.h&gt; int main(void) { char string1 = “1234567890”; char string2 = “123DC8”; int length; length = strspn(string1, string2); printf(“Character where strings differ is at position %dn”, length); return 0; } 函数名: strstr 功 能: 在串中查找指定字符串的第一次出现 用 法: char strstr(char str1, char str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char str1 = “Borland International”, str2 = “nation”, ptr; ptr = strstr(str1, str2); printf(“The substring is: %sn”, ptr); return 0; } 函数名: strtod 功 能: 将字符串转换为double型值 用 法: double strtod(char str, char endptr); 程序例: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { char input[80], endptr; double value; printf(“Enter a floating point number:”); gets(input); value = strtod(input, &amp;endptr); printf(“The string is %s the number is %lfn”, input, value); return 0; } 函数名: strsep功 能: 分解字符串为一组字符串。从str1指向的位置起向后扫描，遇到delim指向位置的字符后，将此字符替换为NULL，返回str1指向的地址。用 法: char strtok(char str1, const char delim); 程序例: int main() { int len, nel; char query[] =”user_command=appleboy&amp;test=1&amp;test2=2”; char q, name, value; / Parse into individualassignments / q = query; fprintf(stderr, “CGI[query string] : %s\n”,query); len = strlen(query); nel = 1; while (strsep(&amp;q, “&amp;”)) nel++; fprintf(stderr, “CGI[nel string] : %d\n”, nel); for (q = query; q&lt; (query + len);) { value = name = q; / Skip to next assignment / fprintf(stderr, “CGI[string] :%s\n”, q); fprintf(stderr, “CGI[stringlen] : %d\n”, strlen(q)); fprintf(stderr, “CGI[address] :%x\n”, q); for (q += strlen(q); q &lt; (query +len) &amp;&amp; !q; q++); / Assign variable / name = strsep(&amp;value,”=”); fprintf(stderr, “CGI[name ] :%s\n”, name); fprintf(stderr, “CGI[value] :%s\n”, value); } return 0; } 函数名: strtok 功 能: 查找由在第二个串中指定的分界符分隔开的单词 用 法: char strtok(char str1, char str2); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char input[16] = “abc,d”; char p; / strtok places a NULL terminator in front of the token, if found / p = strtok(input, “,”); if (p) printf(“%sn”, p); / A second call to strtok using a NULL as the first parameter returns a pointer to the character following the token / p = strtok(NULL, “,”); if (p) printf(“%sn”, p); return 0; } 函数名: strtol 功 能: 将串转换为长整数 用 法: long strtol(char str, char *endptr, int base); 程序例: #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(void) { char string = “87654321”, endptr; long lnumber; / strtol converts string to long integer / lnumber = strtol(string, &amp;endptr, 10); printf(“string = %s long = %ldn”, string, lnumber); return 0; } 函数名: strupr 功 能: 将串中的小写字母转换为大写字母 用 法: char strupr(char str); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string = “abcdefghijklmnopqrstuvwxyz”, ptr; / converts string to upper case characters / ptr = strupr(string); printf(“%sn”, ptr); return 0; } 函数名: swab 功 能: 交换字节 用 法: void swab (char from, char *to, int nbytes); 程序例: #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; char source[15] = “rFna koBlrna d”; char target[15]; int main(void) { swab(source, target, strlen(source)); printf(“This is target: %sn”, target); return 0; }PS:isalpha()是字符函数，不是字符串函数，isalpha 原型：extern int isalpha(int c); 用法：#include &lt;ctype.h&gt; 功能：判断字符c是否为英文字母 说明：当c为英文字母a-z或A-Z时，返回非零值，否则返回零。 举例： // isalpha.c #include &lt;syslib.h&gt; #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; main() { int c; clrscr(); // clear screen printf(“Press a key”); for(;;) { c=getchar(); clrscr(); printf(“%c: %s letter”,c,isalpha(c)?”is”:”not”); } return 0; // just to avoid warnings by compiler }]]></content>
  </entry>
</search>
