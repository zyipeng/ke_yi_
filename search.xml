<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[networkx笔记1]]></title>
    <url>%2F2019%2F05%2F07%2Fnetworkx%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[edges通过设置不同的边显示不同的效果 nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)#首先将所有边全部设置 nx.draw_networkx_edges(G, pos, edgelist=[(0, 1), (1, 2), (2, 3), (3, 0)], width=8, alpha=0.5, edge_color=’r’)#再设置一部分边 nx.draw_networkx_edges(G, pos, edgelist=[(4, 5), (5, 6), (6, 7), (7, 4)], width=8, alpha=0.5, edge_color=’b’)#再设置另一部分边 #设置边颜色的深浅 nodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=’blue’) #获得边的对象列表 edges = nx.draw_networkx_edges(G, pos, node_size=node_sizes, arrowstyle=’-&gt;’, arrowsize=10, edge_color=edge_colors, edge_cmap=plt.cm.Blues, width=2) set alpha value for each edge设置每一条边的状态 for i in range(M): edges[i].set_alpha(edge_alphas[i]) pc = mpl.collections.PatchCollection(edges, cmap=plt.cm.Blues)#设置旁边比较条 pc.set_array(edge_colors) plt.colorbar(pc) #找到需设置边列表的技巧 elarge=[(u,v) for (u,v,d) in G.edges(data=True) if d[‘weight’] &gt;0.5] esmall=[(u,v) for (u,v,d) in G.edges(data=True) if d[‘weight’] &lt;=0.5] edges nx.draw_networkx_edges(G,pos,edgelist=elarge,width=6) nx.draw_networkx_edges(G,pos,edgelist=esmall,width=6,alpha=0.5,edge_color=’b’,style=’dashed’) labels nx.draw_networkx_labels(G,pos,font_size=20,font_family=’sans-serif’)]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础和networkx笔记]]></title>
    <url>%2F2019%2F05%2F07%2FPython%E5%9F%BA%E7%A1%80%E5%92%8Cnetworkx%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[pip freeze #查看已经安装的模块 pip install *** #如果为已安装模块就会显示安装目录 数学操作符 *[指数]、%、//[整除]、/、、-、+ 漂亮打印字典 pprint.pprint() pprint.pfromat() 字符串里面的isX函数 islower()、isupper（）、isalpha（）[只包含字母]、isalnum（）[只包含字母和数字]、isdecimal（）[只包含数字]、isspace（）[只包含空格、制表符、换行]、istitle（）[里面每一个单词都是大写字母开头其他都是小写字母] [所有这些都是非空] ‘a’.join([‘cats’,’rats’,’bats’]) ‘cats,rats,bats’.split(‘,’) pyperclip.paste()、pyperclip.copy()#剪贴板操作 ‘ hello word ‘.strip()、.lstrip()、.rstrip() ‘hello’.rjust(10)、.ljust(10)、.center(10) ‘hello world!’.startswith(‘hello’)、endswith(‘world!’) 正则表达式 匹配 1.用improt re导入正则表达式模块 2.用re.complie()函数创建一个Regex对象（记得使用原始字符串） 3.向Regex对象的search()方法传入想查找的字符串。返回Match对象 4.调用Match对象的group()方法，返回实际匹配文本的字符串 5.调用Match对象的findall()方法，返回所用实际匹配文本的字符串 6.re.complie()函数第二个参数re.IGNORECASE[忽略大小写]、re.DOTALL [让句点包含换行]、re.VERBOSE[编写注释] 符号 ?匹配零次或一次前面的分组 *匹配零次或多次前面的分组 +匹配一次或多次前面的分组 {n}匹配n次前面的分组 {n,}匹配n次或更多前面的分组 {,m}匹配零次到m次前面的分组 {n,m}匹配至少n次、至多m次前面的分组 {n,m}?或*？或+？对前面的分组进行非贪心匹配 ^spam意味着字符串必须以spam开始 spam$意味着字符串必须以spam结尾 . 匹配所有字符，除换行符外 \d、\w、\s 分别匹配 数字、单词、空格 \D、\W、\S 分别匹配 除数字、单词、空格外的所有字符 [abc] 匹配方括号内的任意字符 [^abc] 匹配不在方括号内的任意字符 文件操作基本操作os.path.join(‘usr’,’bin’,’spam’)os.getcwd()、os.chdir(‘C:\Windows\System32’)os.makedirs(‘C:\delicious\walnut\waffles’)os.path.abspath(‘.’)、os.path.isabs(‘.’)、os.path.relpath(porpusepath,startpath)os.path.dirname(path)、os.path.basename(path)、os.path.split(path)‘C:\Windows\System32\calc.exe’.split(os.path.sep)os.path.getsize(‘.\calc.exe’)、os.listdir(‘.’)os.path.exists(‘C:\Windows’)、os.path.isdir(‘C:\Windows’)、os.path.isfile(‘C:\Windows’)hellofile=open(‘C:\User\filename.txt’)#第二个参数w、a、r，返回一个File对象hellocontext=hellofile.read()hellocontext=hellofile.readlines()hellofile.write(‘hello world!\n’) shelve模块import shelveshelfFile=shelve.open(‘mydata’)cats=[‘Zophie’,’Pooka’]shelfFile[‘cats’]=catsshelfFile.close()shelfFile=shelve.open(‘mydata’)type(shelfFile)#检查数据是否正确存储shelfFile[‘cats’]list(shelfFile.keys())list(shelfFile.values())shelfFile.close() 用pprint.pformat()函数保存变量import pprintcats=[{‘name’:’Zophie’,’desc’:’chubby’}]fileObj=open(‘myCats.py’,’w’)fileObj.write(‘cats=’+pprint.pformat(cats)+’\n’)fileObj.close() Networkx无向图import networkx an nx #导入包重名为nximport matplotlib.pyplot as pltG=nx.Graph() #建立空的无向图G.add_node(1) #添加节点1G.add_edge(2,3) #添加边2-3（隐含添加2、3节点）print(G.nodes()) #输入全部节点print(G.edges()) #输出全部边print(G.number_of_edges()) #输出边数 pos=nx.spectral_layout(G) #定义一个布局nx.draw(G,pos,with_labels=False,node_size=30)#绘制#with_labels决定节点带不带标签，node_size决定节点直径plt.show() #显示图形 操作excel文件improt openpyxl #导入openpyxl模块wb=openpyxl.load_workbook(‘example.xlsx’)#打开一个excel文件wb.get_sheet_names() #获得工作簿中所有的表名的列表sheet=wb.get_sheet_by_name(‘Sheet3’)#获得工作表Sheet3的Worksheet对象sheet.title #返回工作表的名字anotherSheet=wb.get_active_sheet() #获得打开工作簿出现的工作表a1=sheet[‘A1’] #表示该工作表的一个单元格a1.value #单元格内保存的值print(‘Cell ‘+str(a.coordinate)+’, Row ‘+str(a1.row)+’,Column ‘+a1.lumn+’ is ‘+a1.value)#’Cell A1, Row 1, Column A is Apples’for i in range(1,8,2):print(i,sheet.cell(row=i,column=2).value)sheet.max_row #获取最大行sheet.max_colum #获取最大列from openpyxl.utils import get_column_letter,column_index_from_string#引入函数get_column_letter(1) #将数字装还成excel列的形式column_index_from_string(‘AA’) #将列的形式转换成数字（不区分大小写） #从列表中取得行和列 #一行一行显示for rowOfCellObjects in sheet[‘A1’:’C3’]:for cellobj in rowOfCellObjects:print(cellObj.coordinate,cellObj.value)#输出一行for cellObj in sheet.row[1]:print(cellObj.value)#输出一列for cellObj in sheet.columns[1]:print(cellObj.value) NumPyndarray数组数组创建函数：array： array([数据、列表、元组、数组和其他序列类型])#数据类型指定或自动、默认直接复制输入数据asarray: #如果输入不是ndarray就复制arange： #类似内置rangeones、ones_like: #创建一个全1adarray数组，ones(2,3)、ones_like([[1,2,3],[2,3,4]])zeros、zeros_like:#创建全0数组empty、empty_like:#创建空值数组eye、identity： #创建N x N单位矩阵（对角线全1，其它为0） NumPy的数据类型：intN、floatN、complexN、bool、object[Python对象类型]、string_[例如要创建一个长度为10的字符串、应使用S10]、unicode_例：arr=np.array([1,2,3]),dtype=np.float64)arr.dtype #显示类型arr1=arr.astype(np.int64) #显式类型转换 未完成。。。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言基础语法]]></title>
    <url>%2F2019%2F05%2F07%2FR%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、基础操作函数 source(‘~/.active-rstudio-document’) #列出workspace中所有对象 ls() #删除某个变量 rm（） #查看R保存文件的目录 getwd() #保存文件 save（yourname，file=’yourname.rda’） #提取保存的工作结果 load（’yourname.rda’) #安装扩展包 install.packages(‘fortunes’) #载入扩展包 library(fortunes) #卸载扩展包 detach(package:fortunes) #查看帮助 ？…… 二、基本数学函数 1、基本算符 +、-、*、/、^、%%[取模]、%/%[取整]、complex()[复数]、1.33e4[科学计算] 2、基本数学函数 abs（）、log(x,base=y)[y为底，x的对数，y默认为e]、exp(x)[x的自然指数]、sqrt(x)、factorial(x)[x的阶乘]、choose(x,y)[x个数选y个数的组合数]； 近似函数：round(123.123,digits=4)、round(4.5)、signif(123.123,4)[保留有效数]、floor(x)[最近整数]、trunc(x)[截取整数]； 三角函数：sin()、cos()、tan() Inf[无穷大]、NaN[无定义]、NA[缺失值] 值检测：is.finite()[是否有限]、is.infinite()、is.nan()、is.na()； 未完成。。。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2019%2F05%2F01%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[基数排序思想：先将序列按照个位装入十个组，然后从0到9将各组内数拿出来，按照十位装入是个组，最后以同样的方式按照百位装入，完成操作之后就已经排好序了。 排序图解： 排序代码： 12345678910111213 代码设计：首先将判断所有数字都是多少位，必须将高位为空补零，存为字符串，或者直接通过整数位数求余取整获得数据。然后使用循环从个位到最高位遍历所有数，分组。设置分组，每一个分组必须是一个动态数组。每一次取数，需要按照上一次装入的组从0组开始，取出一个数就装到对应的本次分组的组。取出的时候，每取空一个组就需要到下一个组取数，因此取数的时候要判断边界。如果减少代码的复杂度可以每次将组里面的数取出装入原来的数组，再做和第一次取数一样的循环。 时间复杂度：O(d*n)可以简单的看成是O(n)空间复杂度：动态数组的话空间会少一点，需要2n，如果是十个数组的话，就需要11*n。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F05%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[与前面归并排序不同的另一种分治策略—-快速排序 与归并排序不同的是：快排不要求分成相等的两半、归并主要是合并，快排主要是划分、归并有一个辅助数组，快排不要。 java类库中的快排：java.until中的Arrays使用快排对基本类型的数组按升序排序。方法: 123&gt; public static void sort(type[] a);public static void sort(type[] a,int first,int last);&gt; 快速排序的思想：先在序列中找到一个支点，使支点左边元素小于等于支点元素，右边元素大于等于支点元素（称为划分）。然后再对左右两部分执行同样的划分。 创建划分步骤：在选定支点之后，将它与最后一个元素相交换，使得再创建划分时支点不成为障碍。从第一个元素开始向后寻找第一个大于或等于支点的节点1，再从倒数第二个元素开始向前寻找第一个小于或等于支点的节点2，如果节点1小于节点2则交换节点1、2。继续做这样的寻找交换，直到最后一次完成，将最后一次不小于支点的元素与支点交换，划分完成。 快速排序图解：（图解1，使用的是选取第一个元素为支点） 支点的选择：最好的情况，支点就是序列的中值，致使划分后两部分近似相等。完全达到这种情况时浪费时间的，近似达到的方法是三者取中值支点法将数组中第一个元素和中间一个元素以及最后一个元素的中值作为支点（先排序三个元素，取第二个就是）。 调整划分算法：三者取中值法处理之后，第一个元素和最后一个元素，分别小于大于支点元素，因此不要对其执行划分，划分算法中先将中间元素与last-1处元素交换，从左右开始查找的步骤只需要分别从first+1、last-2处进行。因为有第一个元素小于支点，最后一个元素大于支点的限制，再寻找的过程中没有必要考虑数组越界的界限。 快速排序源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 public class Quick_Sort &#123; static int MIN_SIZE=3;//由于快排判断考虑的是多余三个元素的序列，必须大于等于3 private static&lt;T extends Comparable&lt;?super T&gt;&gt; void sortFirstMiddleLast(T[] a,int first,int mid,int last)&#123; order(a,first,mid); order(a,mid,last); order(a,first,mid); &#125; private static&lt;T extends Comparable&lt;?super T&gt;&gt; void order(T[] a,int i,int j)&#123; if(a[i].compareTo(a[j])&gt;0)&#123; swap(a,i,j); &#125; &#125; private static void swap(Object[] array,int i,int j)&#123; Object temp=array[i]; array[i]=array[j]; array[j]=temp; &#125; private static&lt;T extends Comparable&lt;?super T&gt;&gt; int partition(T[] a,int first,int last)&#123; int mid=(first+last)/2; sortFirstMiddleLast(a,first,mid,last); swap(a,mid,last-1); int pivotIndex=last-1; T pivot=a[pivotIndex]; int indexFromLeft=first+1; int indexFromRight=last-2; boolean done=false; while(!done)&#123; while(a[indexFromLeft].compareTo(pivot)&lt;0)&#123; indexFromLeft++; &#125; while(a[indexFromRight].compareTo(pivot)&gt;0)&#123; indexFromRight--; &#125; assert a[indexFromLeft].compareTo(pivot)&gt;=0&amp;&amp;a[indexFromRight].compareTo(pivot)&lt;=0; if(indexFromLeft&lt;indexFromRight)&#123; swap(a,indexFromLeft,indexFromRight); indexFromLeft++; indexFromRight--; &#125;else&#123; done=true; &#125; &#125; swap(a,pivotIndex,indexFromLeft); pivotIndex=indexFromLeft; return pivotIndex; &#125; public static&lt;T extends Comparable&lt;?super T&gt;&gt; void quickSort(T[] a,int first,int last)&#123; if(last-first+1&lt;MIN_SIZE)&#123;//此时执行插入排序 Insert_Sort.insertionSort(a,first,last); &#125;else&#123;//此时执行快速排序 int pivotIndex=partition(a,first,last); quickSort(a,first,pivotIndex-1); quickSort(a,pivotIndex+1,last); &#125; &#125;&#125; 时间复杂度：O(n*lgn)最坏是n^2 空间复杂度：O(n)]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序思想：将一个序列分成两半然后对两半分别排序，再将他们归并为一个有序序列。 归并排序图解： 归并排序的代码：(迭代版本代码由于写的急，没来的急优化，所以可读性不是很好） 123456789101112131415161718192021222324252627282930313233 //递归版本归并排序public class Recursion_MergeSort &#123; public static &lt;T extends Comparable&lt;? super T&gt;&gt; void merge_Sort(T[] a,int first,int last)&#123; T[] tempArray=(T[])new Comparable&lt;?&gt;[a.length]; mergeSort(a,tempArray,first,last); &#125; public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] a,T[] tempArray,int first,int last)&#123; if(first&lt;last)&#123; int mid=(first+last)/2; mergeSort(a,tempArray,first,mid); mergeSort(a,tempArray,mid+1,last); int i=first,j=first,k=mid+1; while(j&lt;=mid&amp;&amp;k&lt;=last)&#123; if(a[j].compareTo(a[k])&gt;0)&#123; tempArray[i++]=a[k++]; &#125;else&#123; tempArray[i++]=a[j++]; &#125; &#125; while(i&lt;=last&amp;&amp;j&lt;=mid)&#123; tempArray[i++]=a[j++]; &#125; while(i&lt;=last&amp;&amp;k&lt;=last)&#123; tempArray[i++]=a[k++]; &#125; for(i=0;i&lt;=last;i++)&#123; a[i]=tempArray[i]; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142 //迭代版本递归排序public class Interation_MergeSort &#123; /** * By ke_yi_ * @param a */ public static &lt;T extends Comparable&lt;? super T&gt;&gt; void merge_Sort(T[] a)&#123; int i,j; T[] tempArray=(T[]) new Comparable&lt;?&gt;[a.length]; for(i=2;i&lt;a.length;i=i&lt;&lt;1)&#123; for(j=0;j*i&lt;a.length;j++)&#123; mergeSort(a,tempArray,i*j,i*(j+1)); &#125; &#125; mergeSort(a,tempArray,0,i); &#125; public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mergeSort(T[] a, T[] tempArray, int first, int last) &#123; int i=first,j=first,mid=(first+last)/2; int k=mid; mid=mid&gt;a.length?a.length:mid; last=last&gt;a.length?a.length:last; while(j&lt;mid&amp;&amp;k&lt;last)&#123; if(a[j].compareTo(a[k])&gt;0)&#123; tempArray[i++]=a[k++]; &#125;else&#123; tempArray[i++]=a[j++]; &#125; &#125; while(j&lt;mid)&#123; tempArray[i++]=a[j++]; &#125; while(k&lt;last)&#123; tempArray[i++]=a[k++]; &#125; for(i=first;i&lt;last;i++)&#123; a[i]=tempArray[i]; &#125; &#125;&#125; 时间复杂度：O(n*lgn)最好、最坏、平均都是空间复杂度：O(n)需要使用2n的空间]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找算法]]></title>
    <url>%2F2019%2F04%2F28%2F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[静态查找表 123456789 //顺序表查找的数据类型#define MAXL 100typedef int KeyTypetypedef struct&#123; KeyType key; InfoType data;&#125;NodeType;typedef NodeType SeqList[MAXL]; 顺序查找：它是一种最简单的查找方法。基本思路是：从表的一段开始顺序扫描现行表，依次将扫描到的关键字和给定k相比较。 有序表查找之折半查找：折半查找是一种效率较高的查找方法。它要求线性表是有序的。它的时间复杂度是O(n log2n). 设R[low…high]是当前查找的区间，首先确定该区间的中点位置mid=(low+high)/2,然后待查找的k值与R[mid].key比较，若相等查找成功，若&gt;将区间确定为R[mid…high]继续查找，若&lt;将区间确定为R[low…mid]继续查找。 123456789101112 int Binsearch(SeqList R,int n,KeyType k)&#123; int low=0,high=n-1,mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(R[mid].key==k)return mid+1; if(R[mid].key&gt;k)high=mid-1; else low=mid+1; &#125; ruturn 0;&#125; 三分查找算法 123456789101112131415161718192021222324 int BinSearch(SeqList R,int n,KeyType k)&#123; int low=0,high=n-1,mid,mid1; while(low&lt;=high) &#123; mid=(high-low)/3+low; mid1=(high-low)*2/3+low; if(R[mid].key==k) return mid+1; if(R[mid].key&gt;k) high=mid-1; else &#123; low=mid+1; if(R[mid1].key==k) return mid1+1; if(R[mid1].key&gt;k) high=mid1-1; else low=mid1+1; &#125; &#125; return 0;&#125; 索引顺序表的查找 12345678 //索引表的数据类型如下#define MAXI&lt;索引表的最大长度&gt;typedef struct&#123; KeyType key; int link;&#125;IdxType;typedef IdxType IDX[MAXI]; 采用折半查找索引表的平均查找长度为： ASLb=ASLbn+ASLs=log2(b+1)-1+(s+1)/2 静态树表的查找 动态查找表 二叉排序树 二叉平衡树 B-树和B+树 键树 哈希表]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册表函数]]></title>
    <url>%2F2019%2F04%2F28%2F%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[RegCloseKey：释放对指定注册表项的句柄。点击跳转到函数 RegConnectRegistry：在另一台计算机上建立到预定义注册表句柄的连接。点击跳转到函数 RegCreateKeyEx：创建指定的注册表项。点击跳转到函数 RegDeleteKey：删除注册表子项。 RegDeleteValue：从指定的注册表项中删除键值。 RegDisablePredefinedCache：为指定的进程禁用HKEY_CURRENT_USER的预定义注册表句柄表。 RegEnumKeyEx：枚举指定的打开注册表项的子键。 RegEnumValue：枚举指定的打开注册表项的键值。 RegFlushKey：将指定的打开注册表键的所有属性写入注册表。 RegGetKeySecurity：检索保护指定开放注册表项的安全描述符的副本。 RegLoadKey：在HKEY_USERS或HKEY_LOCAL_MACHINE下创建一个子键，并将指定文件中的注册信息存储到该子键中。 RegNotifyChangeKeyValue：通知调用方对指定注册表项的属性或内容的更改。 RegOpenCurrentUser：检索当前线程模拟的用户的HKEY_CURRENT_USER密钥的句柄。 RegOpenKeyEx：打开指定的注册表键。点击跳转到函数 RegOpenUserClassesRoot：检索指定用户的HKEY_CLASSES_ROOT密钥的句柄。 RegOverridePredefKey：检索与开放注册表键关联的指定值名称的类型和数据。 RegQueryInfoKey：检索有关指定注册表项的信息。 RegQueryMultipleValues：检索与开放注册表项相关联的值名称列表的类型和数据。 RegQueryValueEx：检索与开放注册表键关联的指定值名称的类型和数据。点击跳转到函数 RegReplaceKey：用另一个文件替换支持注册表键及其所有子键的文件。 RegRestoreKey：**读取指定文件中的注册表信息，并将其复制到指定的键上。** RegSaveKey：将指定的键及其所有子键和值保存到新文件中。 RegSetKeySecurity：设置开放注册表项的安全性。 RegSetValueEx：在注册表项下设置指定值的数据和类型。点击跳转到函数 RegUnLoadKey：从注册表中卸载指定的注册表项及其子键。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql的like模糊查找常用标识符]]></title>
    <url>%2F2019%2F04%2F28%2Fmysql%E7%9A%84like%E6%A8%A1%E7%B3%8A%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E6%A0%87%E8%AF%86%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[下面列举常用的几种标识含义； 1:% 表示零个或多个字符的任意字符串： LIKE’Mi%’ 将搜索以字母 Mi开头的所有字符串（如 Michael）。 LIKE’%er’ 将搜索以字母 er 结尾的所有字符串（如 Worker、Reader）。 LIKE’%en%’ 将搜索在任何位置包含字母 en 的所有字符串（如 When、Green）。 2:_（下划线）表示任何单个字符： LIKE’_heryl’ 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。 3：[ ] 表示指定范围 ([a-f]) 或集合 ([abcdef]) 中的任何单个字符： LIKE’[CK]ars[eo]n’ 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。LIKE’[M-Z]inger’ 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。D：[^] 不属于指定范围 ([a-f]) 或集合 ([abcdef]) 的任何单个字符： LIKE’M[^c]%’ 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。 4：* 它同于DOS命令中的通配符，代表多个字符： c*c代表cc,cBc,cbc,cabdfec等多个字符。 5：？同于DOS命令中的？通配符，代表单个字符 : b?b代表brb,bFb等。 6：# 大致同上，不同的是代只能代表单个数字。 k#k代表k1k,k8k,k0k 。 7：[!] 排除 它只代表单个字符。举例：例1，查询name字段中包含有“明”字的。select * from table1 where name like ‘%明%’ 例2，查询name字段中以“李”字开头。select from table1 where name like ‘李‘ 例3，查询name字段中含有数字的。select * from table1 where name like ‘%[0-9]%’ 例4，查询name字段中含有小写字母的。select * from table1 where name like ‘%[a-z]%’ 例5，查询name字段中不含有数字的。select * from table1 where name like ‘%[!0-9]%’ 以上例子能列出什么值来显而易见。但在这里，我们着重要说明的是通配符“*”与“%”的区别。 很多朋友会问，为什么我在以上查询时有个别的表示所有字符的时候用”%”而不用“”？先看看下面的例子能分别出现什么结果：select from table1 where name like ‘明‘select * from table1 where name like ‘%明%’ 大家会看到，前一条语句列出来的是所有的记录，而后一条记录列出来的是name字段中含有“明”的记录，所以说，当我们作字符型字段包含一个子串的查询时最好采用“%”而不用“”,用“”的时候只在开头或者只在结尾时，而不能两端全由“*”代替任意字符的情况下。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软考中级之软件设计师心得]]></title>
    <url>%2F2019%2F04%2F28%2F%E8%BD%AF%E8%80%83%E4%B8%AD%E7%BA%A7%E4%B9%8B%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[软件设计师考试差不多过去半年了，证书是前不久下来的，记录一下心得，讲讲我当时的一些疑惑。 首先说说为什么报吧，和大多人一样，我报软考纯粹抱着试一试的态度，因为看到有几个认识的学长报了，然后感觉自己大学什么东西也没有就去考个证来证明一下自己大学是没有和其他人一样在寝室打游戏。 然后当时报之前 我是对软考的性质进行了一下了解，比如软考是怎样考啊，软考有什么科目，软考有用吗等等。这些资料是需要在报考前搜集好的，我是这么做的。主要途径就是百度，还有软考官网，如果有学长可以指导那就更好咯。软考，分为低级、中级、高级。低级和中级是只有上午和下午两场笔试，高级还加一个论文，具体可以去软考官网了解。软考官网还可以查到报考点和考点。对于软考有用吗？其实当时我也是查了，但是所有类似这样的问题，有用吗，难吗等都是没有标准答案的，只有靠自己去了解。我当时就是在百度文库下了一些真题了解了它的难度，然后还找了考纲，了解它大概考什么。 报名之后，我基本上是用空余时间看教程，视频，真题。视频我是在逼站上找的，直接搜索软件设计师就有很多。真题我是在百度文库和希赛，然后还有一个专门做题的软件，也是在网上找的，但是好像软件商城没有。 说说考试内容的一些心得吧！其实考试的题目涵盖的范围是有点多的，但是题目百分之八九十都是挺简单的，上午的选择题基本上都不难，但是会考一些你可能没有见过的题目，不过也没事因为占比不大，我当时是有六七个题目是自己没有见过的，然后后面的英文题目我也是没有把握的，但是考试75分，题目1分一个，减去20个题目题目都还有55分。下午的题目也是不难的，但是需要一些做题的技巧。前面两个题目是软件工程和数据库那一块的题目，开始我做的时候也确实摸不着头脑。但是我想了一下，这么大的一个项目怎么可能要你一场考试就给思考清楚，肯定是不要弄懂也能做出来的不。虽然这么说，但是也不能完全依靠技巧，因为毕竟是考证书，学也是挺重要的不。后面的程序题，也是有技巧的，但是我当时没有去网上找这方面的技巧，因为毕竟自己也是一个acmer。然而我当时考试的时候有一个算法我确实是没有看懂，但是我感觉我是做出来了的。因为上下文确实能看出一些规律技巧，只要自己仔细。 考完之后，一直到成绩出来那段时间都还是没底的，因为上午那几个没有见过的题目确实给我下了一跳，然后下午那个程序题着实给了我一记重锤。开始那几天我是这样想的：唉！时间还是应该多花点在上午点选择题的知识点上。唉！还是应该多花点时间做题目的。唉！还是应该多学点英语的。；到成绩出来我们学校去报的有70%拿到了证书，其实我有点不太理解，可能我底子确实要好一点。所以之后别人问我难吗？我基本上是说，内容确实有点广，但是难不难我确实没法告诉你，你可以去做一套真题试试。 现在已经过去有一点时间了，对于软考吧，确实学到了很多，思维也是上升了很多。并且现在大三（计算机科学与技术专业）上的一些课基本上讲也只讲到我掌握的那个程度。软件设计师，主要还是在于软件如何设计？软件设计要注意哪些内容？软件设计需要哪些？；从上面三个问题来看，其实隐约的锻炼了个人的设计能力，虽然我现在主要还是一个人写代码，但是我写代码的时候看到了不一样的东西。 这个是我当时学习过程中搜集的资料]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序思想：插入排序的一种变体。由于插入排序对于特别乱的序列排序会很糟。而它就是先将序列变成接近有序的序列。 排序步骤： 举例：10、16、11、4、15、3、9、6、1、17、8、12、7 （1）分组：将上面序列分为6组，按照每一组按照相隔多少取一个数，比如第一组取0号、6号、12号。如下： （2）分组排序：对每一组进行插入排序，得到数组的状态为7、1、4、8、3、9、16、11、17、15、12、10；如下： （3）缩小分格距离（一般缩小为上一次分组的一般），继续分组，排序，知道分组距离为1。 排序图解： 希尔排序代码： 1234567891011121314151617181920212223242526272829303132 public class Sheel_Sort &#123; //对a序列中的第first组进行排序， //这个组是从first元素开始间距为 //space的位置的所有元素 private static &lt;T extends Comparable&lt;? super T&gt;&gt; void incrementalInsertionSort(T[] a,int first,int last,int space)&#123; int unsorted,i; for(unsorted=first+space;unsorted&lt;=last;unsorted=unsorted+space)&#123; T firstUnsorted=a[unsorted]; for(i=unsorted-space;(i&gt;=first)&amp;&amp;(firstUnsorted.compareTo(a[i])&lt;0);i=i-space)&#123; a[i+space]=a[i]; &#125; a[i+space]=firstUnsorted; &#125; &#125; public static&lt;T extends Comparable&lt;? super T&gt;&gt; void shellSort(T[] a,int first,int last)&#123; int n=last-first+1; for(int space=n/2;space&gt;0;space=space/2)&#123; for(int begin=first;begin&lt;first+space;begin++)&#123; incrementalInsertionSort(a, begin, last, space); &#125; &#125; &#125; public static void main(String[] args) &#123; Integer[] a=&#123;9,8,7,6,5,4,3,2,1&#125;; Sheel_Sort.shellSort(a, 0, 8); for(Integer i:a)&#123; System.out.println(i); &#125; &#125;&#125; 时间复杂度：O(n^1.5) 平均情况是这样，最坏情况还是n^2，如果当space为偶数时进行优化的话，可以实现搜友都是n^2空间复杂度：O(n)]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven war解读]]></title>
    <url>%2F2019%2F04%2F28%2FMaven%20war%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[maven是干嘛的：maven其实是一个项目构建和管理的工具，主要就是提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。是可以方便的编译代码、进行依赖管理、管理二进制库等的。 maven war项目中的pom.xml文件：描述了maven项目的基本信息，比如groupId，artifactId，version等。也可以对maven项目的远程仓库，打包形式，资源依赖关系等进行配置。一个最简单的pom.xml文件至少需要包含四个元素：modelVersion, groupId, artiffactId和version。 创建Maven war项目：new-&gt;project-&gt;maven project-&gt;(勾选create a simple project)-&gt; Group Id和Artifact Id是为了保证项目唯一性而提出的； Group Id：可以简单理解为项目开发团队的统一标识，一般分为多个段；实际开发中一般使用两段，第一段代表域，类似org，com，cn等；第二段代表公司名称或者团队名称； ArtifactId：可以简单理解为实际的项目名称；在实际的开发过程中，创建包时包名最好以Group Id+Artifact Id开头；例如，在一个项目中设置了Group Id为com.zyipeng，Artifact Id为test，则Service层的包，完整的包名应该为com.zyipeng.test.service。 Maven war项目的web.xml文件中servlet标签内容： 重定向类：表示根据servlet-name定向到具体的java servlet类调用service方法，实现请求的操作和响应 重定向路径：表示访问相应的路径就可以调用配置的重定向类。 Maven war项目文件的架构简单简绍：]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序思想：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据； 插入排序图解： 插入排序代码： 123456789101112131415161718 //迭代版本public class Interation_InsertSort &#123; public static&lt;T extends Comparable&lt;? super T&gt;&gt; void I_insertionSort(T[] a,int first,int last)&#123; T firstUnsorted=null; for(int unsorted=first+1;unsorted&lt;last;unsorted++)&#123; firstUnsorted=a[unsorted]; insertInOrder(firstUnsorted,a,first,unsorted-1); &#125; &#125; private static&lt;T extends Comparable&lt;? super T&gt;&gt; void insertInOrder(T element,T[] a,int begin,int end)&#123; int index=end; while((index&gt;=begin)&amp;&amp;(element.compareTo(a[index])&lt;0))&#123; a[index+1]=a[index]; index--; &#125; a[index+1]=element; &#125;&#125; 1234567891011121314151617181920 //递归版本public class Recursion_InsertSort &#123; private static&lt;T extends Comparable&lt;? super T&gt;&gt; void R_insertionSort(T[] a,int first,int last)&#123; if(first&lt;last)&#123; R_insertionSort(a,first,last-1); insertInOrder(a[last],a,first,last-1); &#125; &#125; private static&lt;T extends Comparable&lt;? super T&gt;&gt; void insertInOrder(T element,T[] a,int begin,int end)&#123; if(!(element.compareTo(a[end])&lt;0))&#123; a[end+1]=element; &#125;else if(begin&lt;end)&#123; a[end+1]=a[end]; insertInOrder(element, a, begin, end-1); &#125;else&#123; a[end+1]=a[end]; a[end]=element; &#125; &#125;&#125; 时间复杂度：O(n^2) 空间复杂度：n]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2019%2F04%2F23%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序思想：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。 选择排序图解： 选择排序代码（java）： 1234567891011121314151617181920212223242526 package sort;public class SelectSort &#123; public static&lt;T extends Comparable&lt;? super T&gt;&gt; void sort(T[] a,int n)&#123; for(int i=0;i&lt;n-1;i++)&#123; int indexOfSmall=getIndexOfSmallest(a,i,n-1); swap(a,i,indexOfSmall); &#125; &#125; private static&lt;T extends Comparable&lt;? super T&gt;&gt; int getIndexOfSmallest(T[] a,int left,int right)&#123; T min=a[left]; int MinIndex=left; for(int i=left+1;i&lt;=right;i++)&#123; if(a[i].compareTo(min)&lt;0)&#123; min=a[i]; MinIndex=i; &#125; &#125; return MinIndex; &#125; private static void swap(Object[] a,int i,int j)&#123; Object temp=a[i]; a[i]=a[j]; a[j]=temp; &#125;&#125; 时间复杂度：O(n^2) 空间复杂度：O(n)]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯-审美课（二进制，加打表时间优化）]]></title>
    <url>%2F2019%2F03%2F20%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%AE%A1%E7%BE%8E%E8%AF%BE%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8A%A0%E6%89%93%E8%A1%A8%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[此题使用二进制取反简化判断，使用打表方法达到时间复杂度的优化，然后计算所有反下标标记的元素值的和就得到了答案的两倍。 算法训练 审美课 时间限制：1.0s 内存限制：256.0MB 问题描述 《审美的历程》课上有n位学生，帅老师展示了m幅画，其中有些是梵高的作品，另外的都出自五岁小朋友之手。老师请同学们分辨哪些画的作者是梵高，但是老师自己并没有答案，因为这些画看上去都像是小朋友画的……老师只想知道，有多少对同学给出的答案完全相反，这样他就可以用这个数据去揭穿披着皇帝新衣的抽象艺术了（支持帅老师^_^）。 答案完全相反是指对每一幅画的判断都相反。 输入格式 第一行两个数n和m，表示学生数和图画数； 接下来是一个n*m的01矩阵A： 如果aij=0，表示学生i觉得第j幅画是小朋友画的； 如果aij=1，表示学生i觉得第j幅画是梵高画的。 输出格式 输出一个数ans：表示有多少对同学的答案完全相反。 样例输入 3 2 1 0 0 1 1 0 样例输出 2 样例说明 同学1和同学2的答案完全相反； 同学2和同学3的答案完全相反； 所以答案是2。 数据规模和约定 对于50%的数据：n&lt;=1000； 对于80%的数据：n&lt;=10000； 对于100%的数据：n&lt;=50000，m&lt;=20。 时间是1s，数据规模也不小，空间256。眼瞎，明显是一道空间换时间的题目了。 首先暴力做法（没过）直接两个循环输入，三个循环判断。 然后加入二进制抑或运算，一直想加入先计算相同元素的个数然后再计算相反对数，但是没有。两个循环输入，两个循环计算结果，时间复杂度似乎要少很多，但是没过。 123456789101112131415161718192021222324252627282930 #include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int d[50000];int main()&#123; int n,m,t; while(cin&gt;&gt;n&gt;&gt;m)&#123; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;t; d[i]=t; for(int j=1;j&lt;m;j++)&#123; cin&gt;&gt;t; d[i]&lt;&lt;=1; d[i]+=t; &#125; &#125; int res=0; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if((d[i]^d[j])==((1&lt;&lt;m)-1))&#123; res++; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125; 最后，正确答案，用大表法将相同元素放一块，然后通过与(1&lt;&lt;m)-1相抑或取反得到想法的打表数组下标。 12345678910111213141516171819202122232425262728293031 #include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int d[50000];int su[1048578];int main()&#123; int n,m,t; while(cin&gt;&gt;n&gt;&gt;m)&#123; memset(su,0,sizeof(su)); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;t; d[i]=t; for(int j=1;j&lt;m;j++)&#123; cin&gt;&gt;t; d[i]&lt;&lt;=1; d[i]+=t; &#125; su[d[i]]++; &#125; int res=0; int temp=(1&lt;&lt;m)-1; for(int i=0;i&lt;n;i++)&#123; int tem=d[i]^temp; res+=su[tem]; &#125; cout&lt;&lt;res/2&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql引擎]]></title>
    <url>%2F2019%2F03%2F14%2Fmysql%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[创建表时指定表的引擎和字符集 create table t1(id int) engine=myisam/innodb charset=utf8/gbk; 引擎：引擎是用来将查询语句转化为对数据库的操作。比如你输入SQL的数据库查询语句，那它的引擎，就将SQL语句转化为对数据库的操作在数据库中查寻某项，它是实现了对用户的一个接口。不同的语言用不同的引擎 。如：JAVA 的JDBC（Java Database Connectivity），ODBC，JET等… … 数据库的引擎：数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。通俗的解释：比如web开发一般喜欢用myisam，因为myisam具有快速读取操作。而InnoDB就有灵活的特性，因此可以使用它来早就灵活性技术的MYSQL+API等等。所以数据库的引擎通俗的讲就像我们的发动机，汽车用大的发动机，摩托车用小的各取所长。 MyISAM适合：（1）做很多count 的计算；（2）插入不频繁，查询非常频繁；（3）没有事务。InnoDB适合：（1）可靠性要求比较高，或者要求事务；（2）表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定数据引擎的创建 数据库的引擎包括：MySQL数据库引擎取决于MySQL在安装的时候是如何被编译的。要添加一个新的引擎，就必须重新编译MYSQL。在缺省情况下，MYSQL支持三个引擎：ISAM、MYISAM和HEAP。另外两种类型INNODB和BERKLEY（BDB），也常常可以使用。如果技术高超，还可以使用MySQL+API自己做一个引擎。 引擎查用sql语句： 1.查看表的引擎：show create table t; 2.修改表的引擎：alter table t engine=innodb; 3.查看可以提供哪些引擎：show engines; 4.查看当前默认的存储引擎：show variables like ‘%storage_engine%’; 各个引擎介绍：ISAM：ISAM是一个定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到 数据库被查询的次数要远大于更新的次数。因此，ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM的两个主要不足之处在于，它不 支持事务处理，也不能够容错：如果你的硬盘崩溃了，那么数据文件就无法恢复了。如果你正在把ISAM用在关键任务应用程序里，那就必须经常备份你所有的实 时数据，通过其复制特性，MYSQL能够支持这样的备份应用程序。MyISAM：MyISAM是MySQL的ISAM扩展格式和缺省的数据库引擎。除了提供ISAM里所没有的索引和字段管理的大量功能，MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMCHK工具和用来恢复浪费空间的 MyISAMPACK工具。MYISAM强调了快速读取操作，这可能就是为什么MySQL受到了WEB开发如此青睐的主要原因：在WEB开发中你所进行的大量数据操作都是读取操作。所以，大多数虚拟主机提供商和INTERNET平台提供商只允许使用MYISAM格式。MyISAM格式的一个重要缺陷就是不能在表损坏后恢复数据。HEAP：HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，但是它所管理的数据是不稳定的，而且如果在关机之前没有进行保存，那么所有的数据都会丢失。在数据行被删除的时候，HEAP也不会浪费大量的空间。HEAP表格在你需要使用SELECT表达式来选择和操控数据的时候非常有用。要记住，在用完表格之后就删除表格。InnoDB：InnoDB数据库引擎都是造就MySQL灵活性的技术的直接产品，这项技术就是MYSQL+API。在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MyISAM数据库引擎不支持事务处理（transaction process）也不支持外来键。尽管要比ISAM和 MyISAM引擎慢很多，但是InnoDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。如前所述，如果你的设计需要这些特性中的一者 或者两者，那你就要被迫使用后两个引擎中的一个了。 *如果感觉自己的确技术高超，你还能够使用MySQL+API来创建自己的数据库引擎。这个API为你提供了操作字段、记录、表格、数据库、连接、安全帐号的功能，以及建立诸如MySQL这样DBMS所需要的所有其他无数功能。深入讲解API已经超出了本文的范围，但是你需要了解MySQL+API的存在及其可交换引擎背后的技术，这一点是很重要的。估计这个插件式数据库引擎的模型甚至能够被用来为MySQL创建本地的XML提供器（XML provider）。（任何读到本文的MySQL+API开发人员可以把这一点当作是个要求。） MyISAM与InnoDB的区别（收集于网上） InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。 以下是一些细节和具体实现的差别： 1.InnoDB不支持FULLTEXT类型的索引。 2.InnoDB 中不保存表的具体行数，也就是说，执行select count（） fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count（）语句包含where条件时，两种表的操作是一样的。 3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。 4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。 5.LOAD TABLE FROMMASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的表不适用。 另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如updatetable set num=1 where name like “a%” 两种类型最主要的差别就是Innodb支持事务处理与外键和行级锁。而MyISAM不支持。所以MyISAM往往就容易被人认为只适合在小项目中使用。 我作为使用MySQL的用户角度出发，Innodb和MyISAM都是比较喜欢的，但是从我目前运维的数据库平台要达到需求：99.9%的稳定性，方便的扩展性和高可用性来说的话，MyISAM绝对是我的首选。 原因如下： 1、首先我目前平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。 2、MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。 3、从平台角度来说，经常隔1，2个月就会发生应用开发人员不小心update一个表where写的范围不对，导致这个表没法正常用了，这个时候MyISAM的优越性就体现出来了，随便从当天拷贝的压缩包取出对应表的文件，随便放到一个数据库目录下，然后dump成sql再导回到主库，并把对应的binlog补上。如果是Innodb，恐怕不可能有这么快速度，别和我说让Innodb定期用导出xxx.sql机制备份，因为我平台上最小的一个数据库实例的数据量基本都是几十G大小。 4、从我接触的应用逻辑来说，select count（*） 和order by是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。 5、还有就是经常有很多应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的frm.MYD，MYI的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出xxx.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。 6、如果和MyISAM比insert写操作的话，Innodb还达不到MyISAM的写性能，如果是针对基于索引的update操作，虽然MyISAM可能会逊色Innodb，但是那么高并发的写，从库能否追的上也是一个问题，还不如通过多实例分库分表架构来解决。 7、如果是用MyISAM的话，merge引擎可以大大加快应用部门的开发速度，他们只要对这个merge表做一些selectcount（*）操作，非常适合大项目总量约几亿的rows某一类型（如日志，调查统计）的业务表。 当然Innodb也不是绝对不用，用事务的项目如模拟炒股项目，我就是用Innodb的，活跃用户20多万时候，也是很轻松应付了，因此我个人也是很喜欢Innodb的，只是如果从数据库平台应用出发，我还是会首MyISAM。 另外，可能有人会说你MyISAM无法抗太多写操作，但是我可以通过架构来弥补，说个我现有用的数据库平台容量：主从数据总量在几百T以上，每天十多亿pv的动态页面，还有几个大项目是通过数据接口方式调用未算进pv总数，（其中包括一个大项目因为初期memcached没部署，导致单台数据库每天处理9千万的查询）。而我的整体数据库服务器平均负载都在0.5-1左右。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每次打开mysql服务不要像上一篇文章那样复杂，将bin加到path]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%AF%8F%E6%AC%A1%E6%89%93%E5%BC%80mysql%E6%9C%8D%E5%8A%A1%E4%B8%8D%E8%A6%81%E5%83%8F%E4%B8%8A%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E9%82%A3%E6%A0%B7%E5%A4%8D%E6%9D%82%EF%BC%8C%E5%B0%86bin%E5%8A%A0%E5%88%B0path%2F</url>
    <content type="text"><![CDATA[找到自己的mysql安装目录，将bin目录路径复制 例如我的 然后右键我的电脑—-&gt;点击属性—-&gt;点击高级 系统设置—-&gt;点击环境变量 编辑系统变量的path,粘贴自己的bin路径，保存 以后打开服务就只要管理员身份运行cmd，然后mysqld install。或者其他的一些与mysql相关的命令也直接输入就好了，不要再cd到目录了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打开mysqld服务]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%89%93%E5%BC%80mysqld%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[首先找到你mysql的安装目录 （例如我的） 然后将路径复制，例如我的（D:\Program Files\MySQL\MySQL Server 5.5\bin） （没有加到path的方法） 然后右键cmd管理员身份运行，首先cd到bin目录下 （例如我的，因为我的是在d盘符下所以我首先切换到d盘符，然后我再，cd +bin路径） 然后再运行mysqld install命令(例如我的）]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3.7.2卸载不了和正确卸载方式]]></title>
    <url>%2F2019%2F03%2F05%2FPython3.7.2%E5%8D%B8%E8%BD%BD%E4%B8%8D%E4%BA%86%E5%92%8C%E6%AD%A3%E7%A1%AE%E5%8D%B8%E8%BD%BD%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[python3.7.2卸载顺序错了，然后导致卸载不完全，不能再此安装程序 打开控制面板—-&gt;点开卸载程序—-&gt;找到python3.7.2 右键选择更改—-&gt;点击修复 等待修复完成再回到控制面板的卸载程序页面，右键python3.7.2，点击卸载。 不要卸载其他有python英文的程序，卸载其他就卸载不了python3.7.2了，或者在系统里面有很多卸载不干净的文件，电脑管家都卸载不了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[myeclipse激活工具闪退问题]]></title>
    <url>%2F2019%2F03%2F03%2Fmyeclipse%E6%BF%80%E6%B4%BB%E5%B7%A5%E5%85%B7%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装激活教程 注：安装myeclipse会自动安装java。 激活工具闪退，是由于没有运行的java环境，只要把java的bin文件夹加入环境变量，再重新激活就好了。 不知道java安装目录的查找方法： 首先：windows—-&gt;preferences 然后：java—-&gt;installed JREs 最后：打开箭头所示的路径，进入bin文件夹，将路径加入环境变量]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[office安装教程]]></title>
    <url>%2F2019%2F03%2F02%2Foffice%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.去官网下载office 的ios镜像 2.下载官网下载office部署工具 3.将ios镜像装载 4.运行部署工具 文件内容修改教程： 左边修改到右边 id表示的内容具体解释 修改文件名为config（随便一个短的就行） 5.运行cmd，cd到文件所在的文件夹（桌面）输入命令setup.exe /configure config.xml 等待一下就安装完成了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[txt文件在widnows下确确实实是一行字符串，但它实实在在是多行字符串构成]]></title>
    <url>%2F2019%2F01%2F20%2Ftxt%E6%96%87%E4%BB%B6%E5%9C%A8widnows%E4%B8%8B%E7%A1%AE%E7%A1%AE%E5%AE%9E%E5%AE%9E%E6%98%AF%E4%B8%80%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E4%BD%86%E5%AE%83%E5%AE%9E%E5%AE%9E%E5%9C%A8%E5%9C%A8%E6%98%AF%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[最近在学习python，在使用作者的实例数据的时候，用widnows下的nodepad打开看到的是完整的一行数据 但是用python读取文件的时候却读出了多个字符串 我使用notepad++打开以后显示的和理论上的是一样的，多行 其实因为windows使用的换行是\n而linux系统下是\r，所以那个txt文件里面的换行就是\r，但是nodepad也没有将转义字符\r显示出来，我猜测可能是这样的：\r在windows里面有另外的转义的含义，也有可能nodepad默认将\r这个转义字符忽略]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装networkx体验（win10+python37)]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%AE%89%E8%A3%85networkx%E4%BD%93%E9%AA%8C%EF%BC%88win10%2Bpython37)%2F</url>
    <content type="text"><![CDATA[开始百度了一下安装方式，需要下载networkx、pywin32、numpy、matplotlib一些软件。 根据百度的提示，手动下载，手动安装，完全没有成功，也不排除问题在我。安装失败 然后我通过pip下载，下载最新的python，使用自带pip，pip在python安装文件夹的scripts文件夹下面，将路径加入path（这样就不要在pip所在文件夹下运行pip命令），通过pip install ***（前面四个需要安装的模块都是可以这样安装的）。 #安装下载的whl文件也是可以用pip的，pip install ***（文件路径+文件全名），其实我也是因为看到whl文件可以用pip安装才想到用它去安装那些的 / xyx 安装成功后就可以开始调用这些东西了，去调用试试。，不行再回来接着写 下面是安装的全部过程，中间因为网速问题有几次中断 【当时使用的是管理院权限下的dos，因为我将python安装在敏感的地方，需要管理员权限才能更改】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241 Microsoft Windows [版本 10.0.17134.523](c) 2018 Microsoft Corporation。保留所有权利。C:\WINDOWS\system32&gt;pip install numpyCollecting numpy Using cached https://files.pythonhosted.org/packages/dd/3e/0d7a914ee6cceef588dd83b18e257dc474ac67028a8d340dfec644878128/numpy-1.16.0-cp37-cp37m-win_amd64.whlInstalling collected packages: numpySuccessfully installed numpy-1.16.0C:\WINDOWS\system32&gt;pip install matplotlibCollecting matplotlib Downloading https://files.pythonhosted.org/packages/5c/ee/efaf04efc763709f6840cd8d08865d194f7453f43e98d042c92755cdddec/matplotlib-3.0.2-cp37-cp37m-win_amd64.whl (8.9MB) 66% |█████████████████████▌ | 6.0MB 11kB/s eta 0:04:25Exception:Traceback (most recent call last): File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 331, in _error_catcher yield File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 413, in read data = self._fp.read(amt) File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\cachecontrol\filewrapper.py&quot;, line 62, in read data = self.__fp.read(amt) File &quot;c:\program files\python37\lib\http\client.py&quot;, line 447, in read n = self.readinto(b) File &quot;c:\program files\python37\lib\http\client.py&quot;, line 491, in readinto n = self.fp.readinto(b) File &quot;c:\program files\python37\lib\socket.py&quot;, line 589, in readinto return self._sock.recv_into(b) File &quot;c:\program files\python37\lib\ssl.py&quot;, line 1052, in recv_into return self.read(nbytes, buffer) File &quot;c:\program files\python37\lib\ssl.py&quot;, line 911, in read return self._sslobj.read(len, buffer)socket.timeout: The read operation timed outDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;c:\program files\python37\lib\site-packages\pip\_internal\cli\base_command.py&quot;, line 143, in main status = self.run(options, args) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\commands\install.py&quot;, line 318, in run resolver.resolve(requirement_set) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\resolve.py&quot;, line 102, in resolve self._resolve_one(requirement_set, req) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\resolve.py&quot;, line 256, in _resolve_one abstract_dist = self._get_abstract_dist_for(req_to_install) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\resolve.py&quot;, line 209, in _get_abstract_dist_for self.require_hashes File &quot;c:\program files\python37\lib\site-packages\pip\_internal\operations\prepare.py&quot;, line 283, in prepare_linked_requirement progress_bar=self.progress_bar File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 836, in unpack_url progress_bar=progress_bar File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 673, in unpack_http_url progress_bar) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 897, in _download_http_url _download_url(resp, link, content_file, hashes, progress_bar) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 617, in _download_url hashes.check_against_chunks(downloaded_chunks) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\utils\hashes.py&quot;, line 48, in check_against_chunks for chunk in chunks: File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 585, in written_chunks for chunk in chunks: File &quot;c:\program files\python37\lib\site-packages\pip\_internal\utils\ui.py&quot;, line 159, in iter for x in it: File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 574, in resp_read decode_content=False): File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 465, in stream data = self.read(amt=amt, decode_content=decode_content) File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 430, in read raise IncompleteRead(self._fp_bytes_read, self.length_remaining) File &quot;c:\program files\python37\lib\contextlib.py&quot;, line 130, in __exit__ self.gen.throw(type, value, traceback) File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 336, in _error_catcher raise ReadTimeoutError(self._pool, None, &apos;Read timed out.&apos;)pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=&apos;files.pythonhosted.org&apos;, port=443): Read timed out.C:\WINDOWS\system32&gt;pip install matplotlibCollecting matplotlib Downloading https://files.pythonhosted.org/packages/5c/ee/efaf04efc763709f6840cd8d08865d194f7453f43e98d042c92755cdddec/matplotlib-3.0.2-cp37-cp37m-win_amd64.whl (8.9MB) 100% |████████████████████████████████| 8.9MB 88kB/sCollecting python-dateutil&gt;=2.1 (from matplotlib) Downloading https://files.pythonhosted.org/packages/74/68/d87d9b36af36f44254a8d512cbfc48369103a3b9e474be9bdfe536abfc45/python_dateutil-2.7.5-py2.py3-none-any.whl (225kB) 100% |████████████████████████████████| 235kB 75kB/sRequirement already satisfied: numpy&gt;=1.10.0 in c:\program files\python37\lib\site-packages (from matplotlib) (1.16.0)Collecting pyparsing!=2.0.4,!=2.1.2,!=2.1.6,&gt;=2.0.1 (from matplotlib) Downloading https://files.pythonhosted.org/packages/de/0a/001be530836743d8be6c2d85069f46fecf84ac6c18c7f5fb8125ee11d854/pyparsing-2.3.1-py2.py3-none-any.whl (61kB) 100% |████████████████████████████████| 71kB 59kB/sCollecting kiwisolver&gt;=1.0.1 (from matplotlib) Downloading https://files.pythonhosted.org/packages/7c/be/7ae355b45699460e369ebf88d86058fca26827933974cc3f6b6b7800a324/kiwisolver-1.0.1-cp37-none-win_amd64.whl (57kB) 100% |████████████████████████████████| 61kB 86kB/sCollecting cycler&gt;=0.10 (from matplotlib) Downloading https://files.pythonhosted.org/packages/f7/d2/e07d3ebb2bd7af696440ce7e754c59dd546ffe1bbe732c8ab68b9c834e61/cycler-0.10.0-py2.py3-none-any.whlCollecting six&gt;=1.5 (from python-dateutil&gt;=2.1-&gt;matplotlib) Downloading https://files.pythonhosted.org/packages/73/fb/00a976f728d0d1fecfe898238ce23f502a721c0ac0ecfedb80e0d88c64e9/six-1.12.0-py2.py3-none-any.whlRequirement already satisfied: setuptools in c:\program files\python37\lib\site-packages (from kiwisolver&gt;=1.0.1-&gt;matplotlib) (40.6.2)Installing collected packages: six, python-dateutil, pyparsing, kiwisolver, cycler, matplotlibSuccessfully installed cycler-0.10.0 kiwisolver-1.0.1 matplotlib-3.0.2 pyparsing-2.3.1 python-dateutil-2.7.5 six-1.12.0C:\WINDOWS\system32&gt;pip install networkxCollecting networkx Downloading https://files.pythonhosted.org/packages/f3/f4/7e20ef40b118478191cec0b58c3192f822cace858c19505c7670961b76b2/networkx-2.2.zip (1.7MB) 17% |█████▌ | 296kB 7.7kB/s eta 0:03:03Exception:Traceback (most recent call last): File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 331, in _error_catcher yield File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 413, in read data = self._fp.read(amt) File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\cachecontrol\filewrapper.py&quot;, line 62, in read data = self.__fp.read(amt) File &quot;c:\program files\python37\lib\http\client.py&quot;, line 447, in read n = self.readinto(b) File &quot;c:\program files\python37\lib\http\client.py&quot;, line 491, in readinto n = self.fp.readinto(b) File &quot;c:\program files\python37\lib\socket.py&quot;, line 589, in readinto return self._sock.recv_into(b) File &quot;c:\program files\python37\lib\ssl.py&quot;, line 1052, in recv_into return self.read(nbytes, buffer) File &quot;c:\program files\python37\lib\ssl.py&quot;, line 911, in read return self._sslobj.read(len, buffer)socket.timeout: The read operation timed outDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;c:\program files\python37\lib\site-packages\pip\_internal\cli\base_command.py&quot;, line 143, in main status = self.run(options, args) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\commands\install.py&quot;, line 318, in run resolver.resolve(requirement_set) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\resolve.py&quot;, line 102, in resolve self._resolve_one(requirement_set, req) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\resolve.py&quot;, line 256, in _resolve_one abstract_dist = self._get_abstract_dist_for(req_to_install) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\resolve.py&quot;, line 209, in _get_abstract_dist_for self.require_hashes File &quot;c:\program files\python37\lib\site-packages\pip\_internal\operations\prepare.py&quot;, line 283, in prepare_linked_requirement progress_bar=self.progress_bar File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 836, in unpack_url progress_bar=progress_bar File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 673, in unpack_http_url progress_bar) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 897, in _download_http_url _download_url(resp, link, content_file, hashes, progress_bar) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 617, in _download_url hashes.check_against_chunks(downloaded_chunks) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\utils\hashes.py&quot;, line 48, in check_against_chunks for chunk in chunks: File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 585, in written_chunks for chunk in chunks: File &quot;c:\program files\python37\lib\site-packages\pip\_internal\utils\ui.py&quot;, line 159, in iter for x in it: File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 574, in resp_read decode_content=False): File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 465, in stream data = self.read(amt=amt, decode_content=decode_content) File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 430, in read raise IncompleteRead(self._fp_bytes_read, self.length_remaining) File &quot;c:\program files\python37\lib\contextlib.py&quot;, line 130, in __exit__ self.gen.throw(type, value, traceback) File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 336, in _error_catcher raise ReadTimeoutError(self._pool, None, &apos;Read timed out.&apos;)pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=&apos;files.pythonhosted.org&apos;, port=443): Read timed out.C:\WINDOWS\system32&gt;pip install networkxCollecting networkx Downloading https://files.pythonhosted.org/packages/f3/f4/7e20ef40b118478191cec0b58c3192f822cace858c19505c7670961b76b2/networkx-2.2.zip (1.7MB) 100% |████████████████████████████████| 1.7MB 187kB/sCollecting decorator&gt;=4.3.0 (from networkx) Downloading https://files.pythonhosted.org/packages/bc/bb/a24838832ba35baf52f32ab1a49b906b5f82fb7c76b2f6a7e35e140bac30/decorator-4.3.0-py2.py3-none-any.whlInstalling collected packages: decorator, networkx Running setup.py install for networkx ... doneSuccessfully installed decorator-4.3.0 networkx-2.2C:\WINDOWS\system32&gt;pip install pywin32Collecting pywin32 Downloading https://files.pythonhosted.org/packages/a3/8a/eada1e7990202cd27e58eca2a278c344fef190759bbdc8f8f0eb6abeca9c/pywin32-224-cp37-cp37m-win_amd64.whl (9.0MB) 47% |███████████████ | 4.3MB 7.0kB/s eta 0:11:20Exception:Traceback (most recent call last): File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 331, in _error_catcher yield File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 413, in read data = self._fp.read(amt) File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\cachecontrol\filewrapper.py&quot;, line 62, in read data = self.__fp.read(amt) File &quot;c:\program files\python37\lib\http\client.py&quot;, line 447, in read n = self.readinto(b) File &quot;c:\program files\python37\lib\http\client.py&quot;, line 491, in readinto n = self.fp.readinto(b) File &quot;c:\program files\python37\lib\socket.py&quot;, line 589, in readinto return self._sock.recv_into(b) File &quot;c:\program files\python37\lib\ssl.py&quot;, line 1052, in recv_into return self.read(nbytes, buffer) File &quot;c:\program files\python37\lib\ssl.py&quot;, line 911, in read return self._sslobj.read(len, buffer)socket.timeout: The read operation timed outDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;c:\program files\python37\lib\site-packages\pip\_internal\cli\base_command.py&quot;, line 143, in main status = self.run(options, args) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\commands\install.py&quot;, line 318, in run resolver.resolve(requirement_set) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\resolve.py&quot;, line 102, in resolve self._resolve_one(requirement_set, req) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\resolve.py&quot;, line 256, in _resolve_one abstract_dist = self._get_abstract_dist_for(req_to_install) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\resolve.py&quot;, line 209, in _get_abstract_dist_for self.require_hashes File &quot;c:\program files\python37\lib\site-packages\pip\_internal\operations\prepare.py&quot;, line 283, in prepare_linked_requirement progress_bar=self.progress_bar File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 836, in unpack_url progress_bar=progress_bar File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 673, in unpack_http_url progress_bar) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 897, in _download_http_url _download_url(resp, link, content_file, hashes, progress_bar) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 617, in _download_url hashes.check_against_chunks(downloaded_chunks) File &quot;c:\program files\python37\lib\site-packages\pip\_internal\utils\hashes.py&quot;, line 48, in check_against_chunks for chunk in chunks: File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 585, in written_chunks for chunk in chunks: File &quot;c:\program files\python37\lib\site-packages\pip\_internal\utils\ui.py&quot;, line 159, in iter for x in it: File &quot;c:\program files\python37\lib\site-packages\pip\_internal\download.py&quot;, line 574, in resp_read decode_content=False): File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 465, in stream data = self.read(amt=amt, decode_content=decode_content) File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 430, in read raise IncompleteRead(self._fp_bytes_read, self.length_remaining) File &quot;c:\program files\python37\lib\contextlib.py&quot;, line 130, in __exit__ self.gen.throw(type, value, traceback) File &quot;c:\program files\python37\lib\site-packages\pip\_vendor\urllib3\response.py&quot;, line 336, in _error_catcher raise ReadTimeoutError(self._pool, None, &apos;Read timed out.&apos;)pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=&apos;files.pythonhosted.org&apos;, port=443): Read timed out.C:\WINDOWS\system32&gt;pip install pywin32Collecting pywin32 Downloading https://files.pythonhosted.org/packages/a3/8a/eada1e7990202cd27e58eca2a278c344fef190759bbdc8f8f0eb6abeca9c/pywin32-224-cp37-cp37m-win_amd64.whl (9.0MB) 100% |████████████████████████████████| 9.1MB 6.3kB/sInstalling collected packages: pywin32Successfully installed pywin32-224C:\WINDOWS\system32&gt;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[protocol family unavailable]]></title>
    <url>%2F2019%2F01%2F11%2Fprotocol%20family%20unavailable%2F</url>
    <content type="text"><![CDATA[出项这种问题的原因可能很多，但是我的问题我是通过关闭防火墙解决的。开始出现这个问题我没有觉得关闭防火墙有用，因为我上一次不照样能运行吗！但是后来我新建了一个项目还是出现同样的问题，打开日记一看，有一个这样的错误： Cannot start internal HTTP server. Git integration, JavaScript debugger and LiveEdit may operate with errors. Please check your firewall settings and restart Android Studio 于是我将所有的防火墙都关闭，特别是那个红色标记的： 回想了一下，上一次运行的时候，确实没有，电脑也是正常睡眠，但是这一次开机我们充好电再开的，我想可能就是因为电脑没有电关机了，然后开机防火墙自动开启。我也不记得as是需要关闭防火墙去了，哎，新手嘛！]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows xp蓝屏英文翻译]]></title>
    <url>%2F2018%2F12%2F22%2Fwindows%20xp%E8%93%9D%E5%B1%8F%E8%8B%B1%E6%96%87%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[a problem has been detected and windows has been shut down to prevent damage to you computer. if this is the first time you`ve seen this stop error screen,restart your computer. if this screen appears again,follow these steps: check to be sure you have adequate disk space .if a driver is identified in the stop message,disable the driver or check with the manufacturer for driver updates. try changing video adapters. check with your hardware vendor for any bios updates.disavle bios memory options such as caching or shadowing.if you need to use safe mode to remove or disable componnents,restart your computer,press F8 to select advanced startup options,and then select safe mode. Technical information: *** stop:0x0000008E(0xC0000005,0x8057CC62,0xB2CBC9D4,0x00000000) 已检测到一个问题，windows已被关闭，以防止损坏您的计算机。 如果这是您第一次看到停止错误屏幕，请重新启动计算机。如果此屏幕再次出现，请遵循以下步骤: 检查是否有足够的磁盘空间。如果停止消息中标识了一个驱动程序，请禁用该驱动程序或与制造商检查驱动程序更新。试着改变视频适配器。 请与您的硬件供应商检查任何bios更新。取消bios内存选项，如缓存或隐藏。如果需要使用安全模式删除或禁用组件，请重新启动计算机，按F8选择高级启动选项，然后选择安全模式。 技术信息: *站:0 x0000008e(0 xc0000005,0 x8057cc62 0 xb2cbc9d4 0 x00000000) 第一次重启没有成功，第二次我本来想通过高级启动进入安全模式的但是重启之后没有来得及按F8就启动了，输入密码直接开机了，问题也就没有了。 下次如果再遇到类似的问题就可以多重启几次，如果实在不行再进入安全模式，每个电脑进入安全模式的方式是不同的，百度一下，有些事ctrl、F8、等]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dos查看文件md5值命令]]></title>
    <url>%2F2018%2F12%2F22%2Fdos%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6md5%E5%80%BC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[certutil -hashfile 路径+文件名 MD5]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux卸载软件]]></title>
    <url>%2F2018%2F12%2F22%2Flinux%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在终端里 apt-get安装的软件： 安装软件sudo apt-get install softname1 softname2softname3…… 卸载软件 sudo apt-get remove softname1 softname2 softname3…… 卸载并清除配置sudo apt-get remove –purgesoftname1 更新软件信息数据库 sudo apt-get update 进行系统升级sudo apt-get upgrade, sudo apt-get distupgrade 搜索软件包 sudo apt-cache search softname1 softname2 softname3…… 安装的deb包要用此方法： 安装deb软件包 dpkg -i xxx.deb 删除软件包 dpkg -r xxx.deb 连同配置文件一起删除 dpkg -r –purge xxx.deb 查看软件包信息 dpkg -info xxx.deb 查看文件拷贝详情 dpkg -L xxx.deb 查看系统中已安装软件包信息 dpkg -l 重新配置软件包 dpkg-reconfigure xxx 在“synaptic pakagemanager”里: 点搜索，输入软件名 在需要安装或卸载的软件上右击－点标记－最后点应用 现在还可以在 software center里面,直接卸载。 卸载源代码编译的的软件： cd 源代码目录 make clean ./configure （make） make uninstall rm -rf 目录 清理系统： sudo apt-get autoclean sudo apt-get clean sudo apt-get autoremove （或使用ubuntu-tweak清理）]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宠物顶顶顶]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%AE%A0%E7%89%A9%E9%A1%B6%E9%A1%B6%E9%A1%B6%2F</url>
    <content type="text"><![CDATA[复制粘贴到自定义栏目]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库复习笔记]]></title>
    <url>%2F2018%2F12%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据库复习笔记 第一章、绪论 1.数据库管理体统：是位于用户与操作系统之间的一层管理软件，是计算机基础软件。主要功能有，数据定义，数据组织、存储和管理，数据操纵，数据库事务管理、运行管理，数据库的建立与维护等。 2.数据库系统：是由数据库、数据库管理系统和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统。 3.数据结构化：数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的主要区别。所谓“整体”结构化是指数据库中的数据不再仅仅针对某一个应用，而是面向整个组织或企业；不仅数据内部结构化，而是整体，数据之间是有联系的。 4.数据独立性：包括物理独立性（是指用户的应用程序与数据库中数据的物理存储是相互独立的），逻辑独立性（是指用户的应用程序与数据库的逻辑结构是相互独立的，也就是逻辑结构改变，用户程序不变）。 5.数据由数据库管理系统统一管理和控制 1）数据的安全性保护：是指保护数据以防止不合法使用造成数据泄密和破坏。 2）数据的完整性检查：是指数据的正确性、有效性和相容性。 3）并发控制：多个用户同时操作数据，相互干扰产生错，因此必须对并发操作加以控制。 4）数据库恢复：计算机硬件、软件故障和操作员的失误以及故意破坏造成的影响进行恢复。 6.数据库：是长期存储在计算机内有组织、大量、共性数据的集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。 7.数据模型：是对现实数据的抽象，应满足三方面的要求：真实地模拟现实世界，容易为人理解，便于在计算机上实现。 两类数据模型： 1）概念模型：是按照用户地观点来对数据信息建模，主用于数据库设计。 2）逻辑模型和物理模型：逻辑模型主要包括层次、网状、关系、面向对象、关系对象、半结构化等数据模型。主用数据库管理系统地实现；物理模型是数据库系统的核心和基础。 8.概念模型： 1）码：唯一标识实体的属性集。 2）联系：指不同实体集之间的联系。一对一、一对多、多对多等。 9.数据模型的主要组成因素：数据结构、数据操作和数据的完整性约束。 1）数据结构：描述数据库组成对象以及对象之间的联系； 2）数据操作：指数据库中各种对象的实例运行执行操作的集合，包括操作规则。 3）数据的完整性约束：是一组完整性规则。 10.关系模型： 1）关系模型的数据结构：关系（一个关系通常是一张表）、元组（表中过的一行）、属性（表中的一列）、码（即码键，表中的一个属性组）、域（具有相同数据类型值的集合）、分量（元组中一个属性值）、关系模式（对关系的描述）。关系模型要求关系必须是规范化的，每一个分量是不可分的数据项。 2）关系模型数据操纵和完整性约束：操作对象和操作结果是关系；关系模型把存储路径向用户隐藏。 3）关系模型的优缺点：建立在严格的数学概念的基础上；概念单一；存储路径对用户透明，从而具有更高的数据独立性、安全保密性，简化了程序员的共组和数据库开发建立的工作。 11.数据库系统模式：是数据库中全体数据的逻辑结构和特征的描述。模式是相对稳定的而实体是相对变动的。 12.数据库的三级模式结构： 1）模式：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的藐视，是所有用户的公共数据视图。 2）外模式：也称子模式或用户模式，是数据库用户能够看见和使用的局部数据逻辑结构和特征的描述，是数据库用户的数据视图，是于某一应用有关的数据的逻辑表示。 3）内模式：也称存储模式，一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。 13.数据库的二级映像功能与数据独立性： 1）外模式/模式映像：当模式变化时由DBA对外模式/模式映像作相应改变，可以使模式保持不变，应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证数据与程序的逻辑独立性，简称数据的逻辑独立性 2）模式/内模式映像：当数据库的存储结构改变时，用DBA对模式/内模式映像作相应该百年，可以是模式保持不变，从而 应用程序也不必改变。保证里数据与程序的物理独立性，简称数据的物理独立性 14.数据管理员（DBA）职责： 1）决定数据库中的信息内容和结构。 2）决定数据库的存储结构和存储策略。 3）定义数据的安全性要求和完整性约束。 4）监控数据库的使用和运行。 5）数据库的改进和重组、重构。 15.用户：指最终用户，分为三类，偶然用户、简单用户、复杂用户（使用数据库语言访问数据库，能通过接口编制应用程序）。 第二章、关系数据库 1.关系：一组域的笛卡儿积的子集叫做这一组域上的关系。 笛卡儿积：D1 x D2 x … x Dn 关系：R(D1 x D2 x … x Dn) 2.候选码：某一属性组的值能唯一地标识一个元组，而其自己不能，则称该属性组为候选码。 一个关系有多个候选码，选定其中一个为主码。 候选码地诸属性成为主属性。 关系模式地所有属性是这个关系模式的候选码，称为全码。 3.关系可有有三种类型：基本关系（通常称基本表或基表）、查询表和视图表。 4.基本关系具有6条属性：1）列是同质的；2）不同的列可以出自同一个域； 3）列的顺序无所谓；4）任意两个元组的候选码不能取相同的值；5）行的顺序无所谓；6）分量必须取原子值； 5.关系数据库：关系数据库的型也称关系数据库的模式，是关系数据库的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。 6.基本操作：选择、投影、并、差、笛卡儿积是五种基本操作。 7.关系数据语言的分类：关系代数（对关系的运算来表达查询要求）、关系演算（用谓词来表达查询要求）。 结构化查询语言（SQL）：不仅具有丰富的查询功能，而且有数据定义和数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言于一体的关系数据语言。 8.实体完整性规则：若属性（指一个或一组属性）A是基本关系R的属性，则A不能取空值。所谓控制就是“不知道”或“不存在”或“无意义”的值。 9.参照完整性规则：若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每一个元组在F上的值不许：或者取空值（F的每一个属性值均为空值）；或者等于S中某个元组的主码值。 设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。 10.传统的集合运算 并： 差： 交： 笛卡儿积： 11.专门的关系运算：选择、投影、连接、除运算。 1）选择：又称为限制。它是关系R中先择满足给定条件的诸元素。记作： 。逻辑表达式F的基本形式： 2）投影:关系R上的投影是从R中选择出若干属性列组成新的关系。记作： ，其中A为R中的一个属性列。 3）连接：连接也称 连接。它是两个关系的笛卡尔积中选取属性间满足一定条件的元组，记作： 其中，A和B分别为R和S上列数相等且可比的属性组，θ是比较运算符。连接运算从R和S的笛卡儿积R×S中选取R关系在A属性组上的值与S关系在B属性上的值满足比较关系θ的元组。 θ为“=”的连接运算称为等值连接。 自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把同名的属性值去掉。 第三章、关系数据库标准语言SQL 1.SQL的特点 1）综合统一：集数据定义、数据操纵、数据控制语言的功能于一体。 2）高度非过程化：只要提出“做什么”，而无需指明“怎么做”。 3）面向集合的操作方式。 4）同一种语言结构提供多种使用方式：即是独立的语言，又是嵌入式语言。 5）语言简介，易学易用：完成核心功能只用了九个动词。 2.SQL的基本概念：]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R文件变红原因to按钮变色的优化]]></title>
    <url>%2F2018%2F12%2F15%2FR%E6%96%87%E4%BB%B6%E5%8F%98%E7%BA%A2%E5%8E%9F%E5%9B%A0to%E6%8C%89%E9%92%AE%E5%8F%98%E8%89%B2%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在编写大代码量项目的时候出现，R文件突然全红了。心态一下炸了，红了几天了今天终于解决了。 开始对r文件大概理解是它代表资源路径，但是当它报错的时候，开始对自己的认识产生怀疑了，看来还是上课没有认真。 R文件的含义：当 Android 应用程序被编译，会自动生成一个 R 类，其中包含了所有 res/ 目录下资源的 ID，如布局文件，资源文件，图片（values下所有文件）的ID等。在写java代码需要用这些资源的时候，你可以使用 R 类，通过子类+资源名或者直接使用资源 ID 来访问资源。 既然他是一个自动生成的类，只要我文件路径没有放错，然后调用没有调用错，那么它生成就一定是死的。所以它出现错误除了这两个原因就只有另外一个原因了，那就是编写的res下的文件出错了。于是我重新点了一下Sync Project with Gradle file,就是这个按钮（）。然后发现又报错，错误提示是（颜色错误）仔细思考一下我在选择器中item的drawable的值从原来的图片直接变成了颜色rgb值。 然后我重新改成图片，于是乎就可以了。果然还是这个原因。 这样实现就必须通过设置两张不同的图片，然后调用，作为一个程序员来说是多么恶心的事情，虽然我可以ps，但** 所以之后我做了轻微的更改 首先我还是将那个值变成颜色，但是这里的颜色是values文件夹下color.xml中的元素 也就是在values文件夹下的color.xml文件中加上了下面两条语句。 不过作为一个程序员来说还是有点不能忍受，但是**，哎算了，第一次写android项目而且这个又是设计方面的东西，感觉没有纠结算法那么有成就感，就暂且放下吧。。。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windos命令行设置网络]]></title>
    <url>%2F2018%2F10%2F26%2Fwindos%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[由于最近遇到一个问题，电脑更改IP保存的时候出先保存失败的问题 原因是由于权限不够，所导致的，由于时间问题也没有去追究为什么是这样的，以后有机会再找吧！ 首先通过打开dos（强调：管理员运行） 将ip和dns改成自动获取方式： 命令1：netsh interface ip set address name=”以太网” source=dhcp（作用：更改ip地址为自动获取，“以太网”是根据自己的电脑决定的） 命令2：netsh interface ip set dns name=”以太网” source=dhcp（作用：更改dns服务器地址） 将IP和dns设置手动方式： 命令1：netsh interface ip set address”以太网” static (这里输入ip）（这里输入子网掩码）（这里输入网关）auto （作用：设置静态ip） 命令2：netsh interface ip set dns”以太网” static （这里输入dns服务器地址） （作用：设置dns服务器地址） 删除ip地址和dns方式： 命令1：netsh interface ip set address name=”以太网” source=dhcp（作用：更改ip地址为自动获取，“以太网”是根据自己的电脑决定的） 命令2：netsh interface ip set dns name=”以太网” source=dhcp（作用：更改dns服务器地址）]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网-21天刷题计划-第2节 进阶-对称的二叉树]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%89%9B%E5%AE%A2%E7%BD%91-21%E5%A4%A9%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92-%E7%AC%AC2%E8%8A%82%20%E8%BF%9B%E9%98%B6-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[使用非递归的二叉树遍历实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 #include&lt;iostream&gt;using namespace std;const int maxn=10000;/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool isSymmetrical(TreeNode* pRoot) &#123; //头节点为空 if(pRoot==NULL)return true; //定义变量 int top=-1; TreeNode*pl[maxn],*pr[maxn],*p_l,*p_r; //初始化栈 top++;pl[top]=pr[top]=pRoot; //左右序遍历 while(top!=-1) &#123; //头节点出栈 p_l=pl[top];p_r=pr[top];top--; //判断是否对称 if(p_l-&gt;val!=p_r-&gt;val)return false; bool bpll=p_l-&gt;left==NULL,bplr=p_l-&gt;right==NULL; bool bprl=p_r-&gt;left==NULL,bprr=p_r-&gt;right==NULL; if((bpll^bprr)||(bplr^bprl))break; //将子节点入栈 if(p_l-&gt;left!=NULL) &#123; top++; pl[top]=p_l-&gt;left; pr[top]=p_r-&gt;right; &#125; if(p_l-&gt;right!=NULL) &#123; top++; pl[top]=p_l-&gt;right; pr[top]=p_r-&gt;left; &#125; &#125; return top==-1; &#125;&#125;; 经过数十次的提交最后终于过了 第一次找出没有考虑这个if(pRoot==NULL)return true; 提交多次，会想以前写过的遍历算法，递归和非递归都是一样的思路，没有什么漏洞 怀疑栈定义的问题，将maxn改为1000没有用，又改成1e6还是没有用 看了一眼老师和其它同学的提交记录都是使用递归的方法，开始就是怀疑栈溢出，但是使用了数组栈还是溢出应该不可能 整理了一下思路，有看是整理了一下代码 第二次找出判断出错 bool bpll=p_l-&gt;left==NULL,bplr=p_l-&gt;right==NULL; bool bprl=p_r-&gt;left==NULL,bprr=p_r-&gt;right==NULL; if((bpll^bprr)||(bplr^bprl))break; 还是不行，继续往下找，发现入栈时，判断是这样写的if(p_l!=NULL)and if(p_l!=NULL) 改了过来，过了10% 开始肯定了自己的逻辑，找了一下代码，没错 第三次找出题意的对称不仅仅是形状上的对称，数值上也要对称相等，加上了if(p_l-&gt;val!=p_r-&gt;val)return false; 然后就过了。 思路：形状上的对称只要，同时先序遍历后序遍历，如果同时存在相同的子节点就对称，数值就在判断子节点的时候，判断一下数值就行。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0型文法、1型文法、2型文法、3型文法对照]]></title>
    <url>%2F2018%2F10%2F19%2F0%E5%9E%8B%E6%96%87%E6%B3%95%E3%80%811%E5%9E%8B%E6%96%87%E6%B3%95%E3%80%812%E5%9E%8B%E6%96%87%E6%B3%95%E3%80%813%E5%9E%8B%E6%96%87%E6%B3%95%E5%AF%B9%E7%85%A7%2F</url>
    <content type="text"><![CDATA[最近刚刚学编译原理，把对那几种文法罗列一下！ 0型文法其中,至少含有一个非终结符，并且，表示终结符和非终结符的并集。 1型文法：又称为上下文有关文法， （1）：式子左边可以有多个字符，但必须有一个非终结符 （2）：式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符 （3）：左边长度必须小于右边（例外） 2型文法：又称为上下文无关文法， （1）：式子左边只能有一个字符，而且必须是非终结符 （2）：式子右边可以有多个字符，可以是终结符，也可以是非终结符，8但必须是有限个字符 3型文法：又称为正规文法（正规文法又包括左线性文法和右线性文法）或或（大写字母表示非终结符，小写字母表示终结符）]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu14+vmwear联网]]></title>
    <url>%2F2018%2F10%2F15%2Fubuntu14%2Bvmwear%E8%81%94%E7%BD%91%2F</url>
    <content type="text"><![CDATA[1.在虚拟机中添加vmnet8，设置为nat模式 点击虚拟机菜单栏的编辑–&gt;虚拟网络编辑器：弹出窗口如下 打开网络共享中心–&gt;更改适配器设置：可以看到有一个vmnet8 然后点击物理机联网的适配器–&gt;共享–&gt;勾选“允许其他网络用户。。。。”–&gt;选择vmnet8–&gt;确认保存 3.设置ubuntu14虚拟计算机网络属性，选择自定义为vnet8，确认保存，进入虚拟计算机就可以了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验室网线联网经验]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%AE%9E%E9%AA%8C%E5%AE%A4%E7%BD%91%E7%BA%BF%E8%81%94%E7%BD%91%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[由于学校实验室是局域网，所给的ip都是分配好了的，需要设置固定ip地址才能上网 打开文件管理（按win+E） 在搜索框输入（控制面板\网络和 Internet\网络和共享中心）括号中的内容，enter搜索（打开网络共享中心） 点击以太网 点击属性 双击击ipv4，如下 进入后就可以选择固定ip，输入IP相关信息 最后确认保存。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fzu Problem 2169 shadow]]></title>
    <url>%2F2018%2F08%2F23%2Ffzu%20%20Problem%202169%20shadow%2F</url>
    <content type="text"><![CDATA[Problem 2169 shadow Accept: 425 Submit: 1666 Time Limit: 1000 mSec Memory Limit : 32768 KB Problem Description YL是shadow国的国王,shadow国有N个城市。为了节省开支,shadow国只有N-1条道路,这N-1条道路使得N个城市连通。某一年,shadow国发生了叛乱,叛军占领了多个城市,王都岌岌可危。王都为编号为1的城市，除了王都外有K个城市有YL的军队。现在这K支军队要向王都进军，并且消灭沿途经过的城市中的叛军。现给出N个城市的道路情况以及城市的叛军数量，问总共需要消灭多少叛军？ Input 第一行输入两个整数N，K，接下来输入N(1&lt;=N&lt;=100000)个整数Ai(0&lt;=Ai&lt;=10000)，表示第i个城市的叛军数量。接下来输入K个大于等于1且小于等于N的整数，表示有军队的城市的编号。数据保证王都以及有军队的城市没有叛军。接下来输入N-1行，每行两个整数u、v，表示连接u和v的一条道路。每支军队只能沿着道路走，并且是其所在城市与王都之间的最短路线走。 Output 输出一行一个整数表示消灭的叛军数量。 Sample Input 4 2 0 3 0 0 3 4 1 2 2 3 2 4 Sample Output 3 虽然数据很弱，可以很简单的代码就过，但是还是不要错过这个简单的图算法题目。 广度优先搜索，从1开始搜遇到一个有友军的城市就回溯，将路径上的所有敌军消灭，一个队列就可以解决，但是需要制作很多标记，敌军标记，友军标记，访问标记，然后队列就要有上一个城市标记，图因为太大使用邻接表存储，ylarmy.a[i]为0表示没有访问过，1表示访问过，2表示友军所在城市，为3表示皇城。ylarmy.b[i]表示回溯过的城市，也就是走过的路，这个标记是防止走重复路的，因为每一次回溯都回溯到皇城的话就会走太多的重复路，差不多就是dp中剪枝的意思。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 #include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=1e5+5;struct Enode&#123;int endpoint;Enode *nextEdg;&#125;;//边终点标记struct Vnode&#123;int reble_army;Enode *firstedg;&#125;;//叛军//第一条边struct Graph&#123;Vnode vnode[maxn];int n;&#125;g;struct&#123;int a[maxn];bool b[maxn];&#125;ylarmy;struct queue&#123;int pre,d;&#125;;void clearg(int n)&#123; g.n=n; for(int i=0;i&lt;=n;i++) g.vnode[i].firstedg=NULL;&#125;void insert(int start,int end)&#123; Enode *p=(Enode*)malloc(sizeof(Enode)); p-&gt;endpoint=end; p-&gt;nextEdg=g.vnode[start].firstedg; g.vnode[start].firstedg=p;&#125;int Bfs()&#123; int ans=0,x;Enode *e; queue q[maxn];int front=-1,rear=-1; rear++;q[rear].pre=-1;q[rear].d=1; ylarmy.a[1]=3;ylarmy.b[1]=true; while(front!=rear)&#123; e=g.vnode[q[++front].d].firstedg; while(e!=NULL&#123; if(ylarmy.a[e-&gt;endpoint]==2)&#123; ans+=g.vnode[e-&gt;endpoint].reble_army; int d=q[front].d; int pre=q[front].pre; while(!ylarmy.b[d])&#123; ans+=g.vnode[d].reble_army; g.vnode[d].reble_army=0; ylarmy.b[d]=true; d=q[pre].d; pre=q[pre].pre; &#125; ylarmy.a[e-&gt;endpoint]=0; &#125; if(ylarmy.a[e-&gt;endpoint]==0)&#123; ylarmy.a[e-&gt;endpoint]=1;///表示已经走过的点 q[++rear].pre=front; q[rear].d=e-&gt;endpoint; &#125; e=e-&gt;nextEdg; &#125; &#125; return ans;&#125;int main()&#123; int n,k; int i,p1,p2,d; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k))&#123; memset(ylarmy.a,0,sizeof(ylarmy.a)); memset(ylarmy.b,0,sizeof(ylarmy.b)); clearg(n); for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;g.vnode[i].reble_army); for(i=0;i&lt;k;i++)&#123; scanf(&quot;%d&quot;,&amp;d); ylarmy.a[d]=2;///表示友军 &#125; i=n-1; while(i--)&#123; scanf(&quot;%d%d&quot;,&amp;p1,&amp;p2); insert(p1,p2); insert(p2,p1); &#125; printf(&quot;%d\n&quot;,Bfs()); &#125; return 0;&#125; 有点长，但是思路很清晰，容易理解。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[紫书中所说的代码仓库链接]]></title>
    <url>%2F2018%2F08%2F20%2F%E7%B4%AB%E4%B9%A6%E4%B8%AD%E6%89%80%E8%AF%B4%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[git]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ Problem Set - 4020]]></title>
    <url>%2F2018%2F08%2F18%2FZOJ%20Problem%20Set%20-%204020%2F</url>
    <content type="text"><![CDATA[ZOJ Problem Set - 4020 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int maxn=1e5+5;vector&lt;int&gt; mg[maxn];vector&lt;int&gt; t[maxn];int n,m;struct node&#123; int x,y; int step;&#125;;bool mgph(int xi,int yi,int xe,int ye)&#123; queue&lt;node&gt; qu; node temp; temp.x=yi,temp.y=xi,temp.step=0; t[xi][yi]=-1; qu.push(temp); int x,y; while(!qu.empty()) &#123; temp=qu.front(); //cout&lt;&lt;temp.y&lt;&lt;ends&lt;&lt;temp.x&lt;&lt;ends&lt;&lt;temp.step&lt;&lt;endl; qu.pop(); if(temp.x==ye&amp;&amp;temp.y==xe) &#123; printf(&quot;%d\n&quot;,temp.step); return true; &#125; for(int i=0;i&lt;2;i++) &#123; if((mg[temp.y][temp.x]+temp.step)%2==0) &#123; x=temp.x; switch(i) &#123; case 0: y=temp.y+1;break; case 1: y=temp.y-1;break; &#125; &#125; else &#123; y=temp.y; switch(i) &#123; case 0: x=temp.x+1;break; case 1: x=temp.x-1;break; &#125; &#125; if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;(t[y][x]==0||(t[y][x]==-1&amp;&amp;temp.step%2==0))) &#123; node temp1; temp1.x=x,temp1.y=y,temp1.step=temp.step+1; t[y][x]-=1; qu.push(temp1); &#125; &#125; &#125; return false;&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int d; for(int i=0;i&lt;n;i++)&#123; mg[i].clear(); t[i].clear(); for(int j=0;j&lt;m;j++)&#123; scanf(&quot;%d&quot;,&amp;d); mg[i].push_back(d); t[i].push_back(false); &#125; &#125; int xi,yi,xe,ye; scanf(&quot;%d%d%d%d&quot;,&amp;xi,&amp;yi,&amp;xe,&amp;ye); if(!mgph(xi-1,yi-1,xe-1,ye-1)) &#123; printf(&quot;-1\n&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多边形面积]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 #include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define eps 1e-8using namespace std;struct node&#123; double x,y;&#125;z;bool cmp_node(node a,node b)&#123; double ans=(b.x-z.x)*(a.y-z.y)-(b.y-z.y)*(a.x-z.x); if(fabs(ans)&lt;eps) return sqrt(pow(a.x-z.x,2)+pow(a.y-z.y,2))&lt;sqrt(pow(b.x-z.x,2)+pow(b.y-z.y,2)); return ans&gt;0;&#125;double PolygonArea(node I[],int cnt)&#123; int pos=0; double ans=0; if(cnt&lt;3)return 0; for(int i=0;i&lt;cnt;i++) &#123; if(I[pos].y&gt;I[i].y) pos=i; else if(I[pos].y==I[i].y&amp;&amp;I[pos].x&gt;I[i].x) pos=i; &#125; swap(I[pos],I[0]); z=I[0]; sort(I+1,I+cnt,cmp_node); for(int i=0;i&lt;cnt;++i) &#123; ans+=(I[(i+1)%cnt].x*I[i].y-I[(i+1)%cnt].y*I[i].x)/2.0; &#125; return ans;&#125;int main()&#123; node p[5]; p[0].x=1;p[0].y=5; p[1].x=1;p[1].y=3; p[2].x=3;p[2].y=1; p[3].x=3;p[3].y=3; double area=PolygonArea(p,4); cout&lt;&lt;area&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速选择问题]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[输入n个整数和一个正整数k（1&lt;=k&lt;=n)，输出这k[n]。 快速排序 将序列分成两部分，大于tmp小于tmp 分别对两部分进行排序 不要合并 12345678910111213141516171819202122 void QuickSort(RecType R[],int s,int t,int k)&#123; int i=s,j=t; RecType tmp; if(s&lt;t) &#123; tmp=R[s]; while(i!=j) &#123; while(j&gt;i&amp;&amp;R[j].key&gt;=tmp.key) j--; R[i]=R[j]; while(i&lt;j&amp;&amp;R[i].key&lt;=tmp.key) i++; R[j]=R[i]; &#125; R[i]=tmp; QuickSort(R,i+1,t,k); QuickSort(R,s,i-1,k); &#125;&#125;//代码来自数据结构-李春葆 的时间内将k[n]找出来 12345678910111213141516171819202122232425262728293031323334353637383940414243 #include&lt;iostream&gt;using namespace std;struct RecType&#123; int key;&#125;;int rk;void QuickSort(RecType R[],int s,int t,int k)&#123; int i=s,j=t; RecType tmp; if(s&lt;t) &#123; tmp=R[s]; while(i!=j) &#123; while(j&gt;i&amp;&amp;R[j].key&gt;=tmp.key) j--; R[i]=R[j]; while(i&lt;j&amp;&amp;R[i].key&lt;=tmp.key) i++; R[j]=R[i]; &#125; R[i]=tmp; if(k&gt;i) QuickSort(R,i+1,t,k); else if(k&lt;i) QuickSort(R,s,i-1,k); else rk=R[k].key; &#125; rk=R[k].key;&#125;int main()&#123; int s=1,t,k; RecType r[100]; cin&gt;&gt;t&gt;&gt;k; for(int i=1;i&lt;=t;i++) cin&gt;&gt;r[i].key; QuickSort(r,s,t,k); cout&lt;&lt;rk&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆序对]]></title>
    <url>%2F2018%2F08%2F13%2F%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[输入一个序列求序列中的逆序对 归并排序代码 1234567891011121314151617 void merge_sort(int *a,int x,int y,int *T)&#123;if(y-x&lt;=1)return ;int m=x+(y-x)/2;int p=x,q=m,i=x;merge_sort(a,x,m,T);merge_sort(a,m,y,T);while(p&lt;m||q&lt;y)&#123;if(q&gt;=y||(p&lt;m&amp;&amp;a[p]&lt;=a[q]))T[i++]=a[p++];elseT[i++]=a[q++];&#125;for(int x;i&lt;y;i++)a[i]=T[i];&#125;//代码来自紫书 分治方法，先分开，然后递归求解，最后合并问题。 将序列分成差不多等长的两部分，统计i和j均在左边或者均在右边的逆序对数，再统计i在左边，j在右边的逆序对数。 求i，j分别在两边的情况，可以通过上面的排序算法所用的技巧算，因为归并排序最后合并i在左j在右，并且两边有序所以每一次找到a[p]&gt;a[q]就可以判定为是逆序，并且可以判定a[p]到a[m]中间的都大于a[q]。于是 可以直接cnt+=m-p。 12345678910111213141516171819202122232425262728293031323334 #include&lt;iostream&gt;using namespace std;int a[100];int t[100];int cnt=0;void merge_sort(int *a,int x,int y,int *T)&#123; if(y-x&gt;1) &#123; int m=x+(y-x)/2; int p=x,q=m,i=x; merge_sort(a,x,m,T); merge_sort(a,m,y,T); while(p&lt;m||q&lt;y) &#123; if(q&gt;=y||(p&lt;m&amp;&amp;a[p]&lt;=a[q])) T[i++]=a[p++]; else &#123;T[i++]=a[q++];cnt+=m-p;&#125; &#125; for(i=x;i&lt;y;i++) a[i]=T[i]; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; merge_sort(a,0,n,t); cout&lt;&lt;cnt&lt;&lt;endl;&#125;//代码来自对紫书上修改]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续和]]></title>
    <url>%2F2018%2F08%2F13%2F%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C%2F</url>
    <content type="text"><![CDATA[用一般暴力方法： 12345678 best = a[i]//初始化最大值for(int i = 1;i &lt;= n;i++)for(int j = i;j &lt;= n;j++)&#123;int sum=0; //检查连续子序列a[i] + ... ... + a[j]for(int k = i;k &lt;= j;k++)sum += a[k]; //累加元素和if(sum &gt; best) best = sum;//更新最大值&#125; 优化时间复杂度为 12345 s[0]=0;//s存前缀和for(int i = 1; i &lt;= n; i++)s[i]=s[i-1]+a[i];for(int i = 1; i &lt;= n; i++)for(int j = i; j &lt;= n; j++)best = max(best, s[j]-s[i-1]); 分治法使时间复杂度更优 123456789101112 int maxum(int *a,int x,int y)//返回数组在[x,y)区间中最大连续和&#123;int v,l,r,maxs;if(y-x==1)return a[x];//只有一个元素，直接返回int m=(x+y)/2;int maxs=max(maxsum(a,x,m),maxsum(a,m,y));//分治第二步：递归求解v=0;l=a[m-1];for(int i=m-1;i&gt;=x;i--)l=max(l,v+=a[i]);//分治第三步合并(1)：从分界点开始往左的最大连续和lv=0;r=a[m];for(int i=m;i&lt;y;i++)r=max(r,v+=a[i]);//分支第三部合并(2):从分界点开始往右的最大连续和rreturn max(maxs,l+r);//把子问题的解与l和r比较&#125; 用前面时间复杂度为的代码加以改进，在的到s后对数组进行维护，得到s的前i项最小，在后面的是s[j]-s[i-1]中只要找到最小的s[i-1]就ok了，所以只要直接减去维护后的s[i-1]就可以了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件运行不了需安装.NET fremework3.5，或0xc0000135初始化失败怎么解决]]></title>
    <url>%2F2018%2F08%2F12%2F%E8%BD%AF%E4%BB%B6%E8%BF%90%E8%A1%8C%E4%B8%8D%E4%BA%86%E9%9C%80%E5%AE%89%E8%A3%85.NET%20fremework3.5%EF%BC%8C%E6%88%960xc0000135%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[xp的0xc0000135初始化失败怎么解决 win10的需安装.NET fremework3.5 都是没有安装要安装.NET fremework3.5的原因 要安装系统也是有的，只要选中上图的.NET fremework3.5选项是会弹出提示安装的，但是亲身体验有点慢，于是找了一下教程 https://jingyan.baidu.com/article/fedf0737acc34f35ac897782.html 离线安装包安装方法（推荐） 1 下载NET Framework 3.5.zip文件包 下载链接：https://pan.baidu.com/s/1brhhrY3 密码：2fc8 2 将下载的NET Framework 3.5.zip解压，解压后如下图！ 3 将解压得到【sxs】文件夹复制到C盘根目录（就是直接拖进C盘,用完后可以删除） 4 【右键】&gt;【以管理员身份运行】NET Framework 3.5，完成 温馨提示：一定要【右键】以管理员身份运行NET Framework 3.5！ 5 随后会出现一个黑框，等到100%就完成了！有时速度会很快，闪一下就过去了。 6 第一种方法完成！不明白的地方看说明！ END 方法2：在线安装方法（不推荐） 如图，右键点击【Windows标】 点击【功能和应用】 现在window10会进入如图的界面，滚动到最下面点击【应用和程序】 点击【启用或关闭Windows功能】 然后如图，勾上图示选项 最后点击【确定】，然后就等着系统自己安装完成！]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows10关闭安全服务]]></title>
    <url>%2F2018%2F08%2F11%2Fwindows10%E5%85%B3%E9%97%AD%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[一、彻底关闭系统自带的windows defender 不管你用的是哪个版本的Win10，其实只要停了Windows Defender的实时监控，也就等于让这款内置杀软“离职”，至少是被架空了。所以，在创意者更新中，进入Windows Defender安全中心，找到“病毒和威胁防护设置”，把里面“实时保护”等选项关了就好。老版本Win10在设置→更新和安全→Windows Defender中关闭“实时保护”之类的开关就行。 新版本中找不到这个东西，就用注册表关闭的方法 关闭Windows Defender安全中心具体方法如下： 1、win+R打开运行小窗口，输入regedit，按回车键进入注册表编辑器。 2、定位到 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\SecurityHealthService 3、在右侧找到DWORD（32位）值，命名为Start。 4、修改数值数据为4。 5、重启文件资源管理器，或注销再登录/重启系统。 Windows10系统彻底关闭Windows Defender的技巧就为大家介绍到这里了。按照上述步骤操作，会看到Windows Defender安全中心不再出现，再配合停用Windows Defender，内置安全软件就不会打扰到大家了。当然，如果用户安装第三方杀软或安全软件，Windows Defender会自动被关闭。 二、彻底关闭360 关闭360以后发现其实后台还是有360的主动防御服务，打开任务管理器，找到360的主动服务，点击结束任务是关闭不了的。 因为360为了防止病毒强制结束进程而设有进程保护 所以我们是无法通过任务管理器结束360的 360涉及到系统底层的一些东西 所以被默认为是系统进程 不能随便关闭 要想退出只能通过它自身退出 360涉及到系统底层的一些东西 所以被默认为是系统进程 不能随便关闭 要想退出只能通过它自身退出 在你右下角的360图标上点右键退出 选择时间或者完全关闭退出就行了 360涉及到系统底层的一些东西 所以被默认为是系统进程 不能随便关闭 要想退出只能通过它自身退出 选择网络防护中心最下面的，主动防御服务]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SecureCRT链接失败+ubuntu中root用户登录失败]]></title>
    <url>%2F2018%2F08%2F10%2FSecureCRT%E9%93%BE%E6%8E%A5%E5%A4%B1%E8%B4%A5%2Bubuntu%E4%B8%ADroot%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[事情是这样的，前几天使用redhat的时候用到了securecrt软件登录linux终端，最近又使用ubuntu系统，在使用找这个软件的时候发现连接不了然后在找了好久终于找到了原因。 原来是Ubuntu是没有带ssh这个软件的， // 1.sudo apt-get install openssh-server openssh-client // 2.rpm -qa | grep ssh查看SSH是否安装 若没有执行第1步 // 3.service sshd status 查看是否开启 如果没有继续下面 // 4.启动SSH服务 service sshd restart 停止服务 service sshd stop // 5.netstat -antp | grep sshd 查看是否启动22端口 // 6.chkconfig sshd on 设置SSH服务为开机启 sudo apt install ssh 下载这个软件后是用root用户还是不能链接 思考了一下是不是密码忘了 然后我就直接gurb模式改了root密码，像前一篇文章一样 改了之后我又登，发现还是登不上，我还是怀疑密码有问题 于是打开虚拟机登了一下，发现密码还真是错的，于是又进入那个模式开始改密码，发现进去不了了 于是我找原因，其实我第一次进入的时候是在虚拟机加载界面的时候像redhat那样随便按e进入的，原来redhat还没有打开开机grub选项，于是我又找到grub的配置文件/etc/default/grub 打开/etc/default/grub文件 找到 GRUB_HIDDEN_TIMEOUT=0 这行，使用#注释掉，变成 #GRUB_HIDDEN_TIMEOUT=0 找到 GRUB_TIMEOUT=10 把10变成3,意思是等待3秒钟。 保存文件 其实在这个过程中，还好我的本地用户在root组中，不然可能就要以其它的方式进入grub了，因为grub这个文件是readonly只读文件 sudo chmod 666 grub，更改文件权限，当然是在/etc/default文件目录下执行的 然后vi grub 然后改咯（命令模式下：i前插，a后插，x删字，dd删行，p粘贴，u撤回，hjkl移动；然后wq保存退出） 执行命令 sudo update-grub 现在启动的时候就会显示grub菜单了，如果3秒内不选择，则会自动进入系统。 有了这个以后，用上一篇文章更改，但是在下面登录的时候，老是提示要ctrl+d,然后一直循环，仔细一看说要确认密码，然后改输入，上一次没有打开Num Lock，的数字密码后enter，就进入了root了 更改密码以后，还是不行 于是我又找，发现下载的ssh是没有把root设置允许的,于是寻找配置文件 $ sudo vi /etc/ssh/sshd_config 找到PermitRootLogin no（prohibit password)一行，改为PermitRootLogin yes 重启 openssh server service sshd restart 然后就可以了登陆了。 中间参考文章 https://blog.csdn.net/sfe1012/article/details/53113271 https://blog.csdn.net/xiaocai9999/article/details/78012235 https://blog.csdn.net/cnyygj/article/details/76086430]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客2018年第七次acm暑期培训----A-Minimum Cost Perfect Matching]]></title>
    <url>%2F2018%2F08%2F10%2F%E7%89%9B%E5%AE%A22018%E5%B9%B4%E7%AC%AC%E4%B8%83%E6%AC%A1acm%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD----A-Minimum%20Cost%20Perfect%20Matching%2F</url>
    <content type="text"><![CDATA[链接：https://www.nowcoder.com/acm/contest/145/A 来源：牛客网 Minimum Cost Perfect Matching 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K Special Judge, 64bit IO Format: %lld 题目描述 You have a complete bipartite graph where each part contains exactly n nodes, numbered from 0 to n - 1 inclusive. The weight of the edge connecting two vertices with numbers x and y is (bitwise AND). Your task is to find a minimum cost perfect matching of the graph, i.e. each vertex on the left side matches with exactly one vertex on the right side and vice versa. The cost of a matching is the sum of cost of the edges in the matching. denotes the bitwise AND operator. If you’re not familiar with it, see {https://en.wikipedia.org/wiki/Bitwise_operation#AND}. 输入描述:1The input contains a single integer n (1 ≤ n ≤ 5 * 105). 输出描述:123 Output n space-separated integers, where the i-th integer denotes pi (0 ≤ pi ≤ n - 1, the number of the vertex in the right part that is matched with the vertex numbered i in the left part. All pi should be distinct.Your answer is correct if and only if it is a perfect matching of the graph with minimal cost. If there are multiple solutions, you may output any of them. 示例1 输入13 输出10 2 1 说明1For n = 3, p0 = 0, p1 = 2, p2 = 1 works. You can check that the total cost of this matching is 0, which is obviously minimal. 12345678910111213141516171819202122232425262728293031 #include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=500100;int d[MAXN];int c[20];int main()&#123; int n,i,j; c[0]=1; for(int i=0;i&lt;20;i++) &#123; c[i+1]=2&lt;&lt;i; &#125; scanf(&quot;%d&quot;,&amp;n); int p=upper_bound(c,c+20,n-1)-c; if(p!=0)p--; for(int i=n-1;i&gt;=0;i--) &#123; if(i!=0&amp;&amp;d[i]==0) &#123; while(i&lt;c[p])p--; d[i]=2*c[p]-i-1; d[2*c[p]-i-1]=i; &#125; &#125; for(int i=0;i&lt;n-1;i++) printf(&quot;%d &quot;,d[i]); printf(&quot;%d\n&quot;,d[n-1]); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux跳过root密码登陆]]></title>
    <url>%2F2018%2F08%2F09%2Flinux%E8%B7%B3%E8%BF%87root%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[redhat： 进入grub模式，然后向下面一样，在最后加s，enter，b进入系统 ubuntu： 进入grub模式，然后将recover，前面的ro改成rw，ctrl+x保存，root登陆系统 passwd更改root密码 Ubuntu，第一次成功了，之后不知道为什么失败了好几次。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划----最长上升子序列]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92----%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[有一个长为n的数列a0,a1… …an-1。请求出这个序列中最长的上升子序列的长度。上升子序列指的是对于任意的i&lt;j都满足ai&lt;aj的子序列。 限制条件{ n[1,1000]、n[0,1000000] } dp[i]表示以ai为末尾的最长上升子序列的长度 dp[i]=max( 1,max{dp[j]+1 | j&lt;i且aj&lt;ai }) 123456789101112131415161718192021222324252627 #include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1e3+1;int n;int a[MAXN];int dp[MAXN];int solve()&#123; int re=0; for(int i=0;i&lt;n;i++)&#123; dp[i]=1; for(int j=0;j&lt;i;j++) if(a[j]&lt;a[i]) dp[i]=max(dp[i],dp[j]+1); re=max(re,dp[i]); &#125; return re;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); printf(&quot;%d\n&quot;,solve()); return 0;&#125; 前面的dp针对最末位元素的最长的子序列。如果子序列的长度相同，那么最末位的元素较小的在之后会更加有优势，因此反过来针对相同长度，末尾元素较小会更加有优势。 dp[i]表示长度位i+1的上升子序列中末尾元素的最小值（不存在的话就时INF） 更新数组：开始将dp初始化为INF，然后由前到后逐个考虑数列的元素，对于每个aj，如果i=0或者dp[i-1]&lt;aj的话，就用dp[i]=min(dp[i],a[j])进行更新。最终找到dp[i]&lt;INF的最大值的i+1就是结果。直接实现时间还是，但还可以优化。首先dp数列中除INF之外是单调递增的，因此可以知道对于每个aj最多只需要一次更新。对于这次更新究竟在什么位置，不必逐个遍历，可以利用二分搜索，这样时间就变成了。 12345678 int dp[MAXN];int solve()&#123; fill(dp,dp+n,INF); for(int i=0;i&lt;n;i++) *lower_bound(dp,dp+n,a[i])=a[i]; return lowwer_bound(dp,dp+n,INF)-dp;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划----背包问题]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92----%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[0-1背包之一 n个重量价值分别为wi，vi的物品。从这些物品中挑选出总重量不超过W的物品，求价值总和的最大值。 限制条件{n(1,100)、wi,vi(1,100)、W(1,1000)} 枚举+dfs： 123456789101112131415161718192021222324252627282930313233343536373839404142 #include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100;int w[MAXN],v[MAXN];int n;int solve(int i,int j)&#123; int re; if(i==n) re=0; else if(j&lt;w[i]) re=solve(i+1,j); else re=max(solve(i+1,j),solve(i+1,j-w[i])+v[i]); return re;&#125;int main()&#123; int i,W; scanf(&quot;%d%d&quot;,&amp;n,&amp;W); for(i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,w[i],v[i]); printf(&quot;%d\n&quot;,solve(0,W)); return 0;&#125;由于dfs会出现很多重复计算的情况；剪枝后；int dp[MAXN][MAXN];int solve(int i,int j)&#123; int re; if(dp[i][j]) re = dp[i][j]; else if(i==n) re = 0; else if(j&lt;w[i]) re = solve(i+1,j); else re = max(solve(i+1,j),solve(i+1,j-w[i])+v[i]); return re=dp[i][j];&#125; 动态规划 递推1：dp[i][j]表示考虑第i个物品后w用j的最优挑选方案 dp[n][j]=0； 当j&lt;w[j]时，dp[i][j]=dp[i+1][j]； 其它，dp[i][j]=max(dp[i+1][j],dp[i+1][j-w[i]]+v[i])； 1234567891011 int dp[MAXN][MAXN_W];int solve()&#123; for(int i=n-1;i&gt;=0;i--) for(int j=0;j&lt;=w;j++) if(j&lt;w[i]) dp[i][j]=dp[i+1][j]; else dp[i][j]=max(dp[i+1][j],dp[i+1][j-w[i]]+v[j]); return dp[0][w];&#125; 递推2：dp[i+1][j]表示从前i个物品中选出总重量不超过j的物品时总价值的最大值 dp[0][j]=0； 当j&lt;w[i]时，dp[i+1][j]=dp[i][j]； 其它情况，dp[i+1][j]=max(dp[i][j],dp[i][j-w[i]]+v[i])； 12345678910 int solve()&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=w;j++) if(j&lt;w[i]) dp[i+1][j]=dp[i][j]; else dp[i+1][j]=max(dp[i+1][j],dp[i+1][j-w[i]]+v[i]); return dp[n][w];&#125; 状态转移：“前 i 个物品中挑选总重量不超过 j 时的状态” 向 “前 i+1 个物品中选取总重不超过 j ” 和 “前 j+1 个物品中选取总重不超过 j+w[i] 时的状态” 转移。 1234567891011 void solve()&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=w;j++) &#123; dp[i+1][j]=max(dp[i+1][j],dp[i][j]); if(j+w[i]&lt;=W) dp[i+1][j+w[i]] = max(dp[i+1][j+w[i]],dp[i][j]+v[i]); &#125; return dp[n][W];&#125; 完全背包 有n种重量和价值分别为wi，vi的物体。从这些物品中挑选总重量不超过W的物品，求出挑选物品价值总和的最大值。 限制条件：{ n[1,100] 、wi,vi[1,1000]、W[1,10000]) } dp[i+1][j]表示从前 i 种物品中挑选总重量不超过 j 时总价值的最大值。 dp[0][j]=0； dp[i+1][j] = max{ dp[ i-kw[i]]+kv[i] | 0&lt;=k }； 123456789 int dp[MAXN][MAXN];int solve()&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=W;j++) for(int k=0;k*w[i]&lt;=j;k++) dp[i+1][j] = max(dp[i+1][j],dp[i][j-k*w[i]]+k*v[i]); return dp[n][w];&#125; 上面的程序三层循环。其实在计算每一行的结果的时候都重复计算了，j=j+w[i]，在dp[i][j] 计算dp[i][j-k*w[i]]+k*v[i]后，会计算dp[i][j-kw[i]]+k`v[i]，而当k=k`-1前面的计算就是和后面的计算是一样的。也就是当k&gt;0的时候的计算都是重复计算。 1234 dp[i+1][j] = max&#123; dp[i][j-k*w[i]]+k*v[i] | 0&lt;=k &#125;​​​​​​​ = max( dp[i][j],max&#123; dp[i][j-k*w[i]]+k*v[i] | 1&lt;=k ) = max( dp[i][j],max&#123; dp[i][(j-w[i])-k*w[i]]+k*v[i] | 0&lt;=k &#125;+v[i]) = max( dp[i][j],dp[i+1][j-w[i]]+v[i]) 12345678910111213141516171819202122232425 #include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=101;int dp[MAXN][MAXN];int v[MAXN],w[MAXN];int n,W;int solve()&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=W;j++) if(j&lt;w[i]) dp[i+1][j]=dp[i][j]; else dp[i+1][j]=max( dp[i][j],dp[i+1][j-w[i]]+v[i] ); return dp[n][W];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;W); for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;w[i],&amp;v[i]); printf(&quot;%d\n&quot;,solve()); return 0;&#125; 使用一维数组实现0-1背包和完全背包 12345678910111213141516171819202122232425262728293031323334 #include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=101;int dp[MAXN];int w[MAXN],v[MAXN];int n,W;int solve_01()&#123; for(int i=0;i&lt;n;i++) for(int j=W;j&gt;=w[i];j--) dp[j]=max(dp[j],dp[j-w[i]]+v[i]); return dp[W];&#125;int solve_com()&#123; for(int i=0;i&lt;n;i++) for(int j=w[i];j&lt;=W;j++) dp[j]=max(dp[j],dp[j-w[i]]+v[i]); return dp[W];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;W); for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;w[i],&amp;v[i]); char op[10]; scanf(&quot;%s&quot;,op); if(op[0]==&apos;0&apos;) printf(&quot;%d\n&quot;,solve_01()); else printf(&quot;%d\n&quot;,solve_com()); return 0;&#125; 0-1背包之二 有n个重量和价值分别为wi,vi的物品。从这些物品中挑选总重量不超过W的物品，求所有挑选方案中价值总和最大值。 限制条件：{ n[1,n]、wi[1,1e7]、vi[1,100]、W[1,1e9] }； 因为限制条件的变化，如果方法不变的话dp数组中的j最大为1e9，内存是超级大的，因此可以试着改变DP的对象。之前的方法中，是真多重量，这里不妨针对价值计算最小的重量。 dp[i+1][j]表示前i个物品中挑选出价值总和为j时总重量的最小值（不存在时就是一个充分大的数值INF）。 dp[0][0]=0； dp[0][j]=INF； dp[i+1][j]=min(dp[i][j],dp[i][j-v[i]]+w[i])； 12345678910111213141516171819202122232425262728293031 #include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100,MAXV=100,INF=1e9+1;int dp[MAXN+1][MANX*MANV+1];int w[MAXN],v[MAXN];int n,W;int solve()&#123; fill(dp[0],dp[0]+MAXN*MAXV+1,INF); dp[0][0]=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=MAXN*MAXV;j++) if(j&lt;v[i]) dp[i+1][j]=dp[i][j]; else dp[i+1][j]=min(dp[i][j],dp[i][j-v[i]]+w[i]); int re=0; for(int i=0;i&lt;=MAXN*MAXV;i++) if(dp[n][i]&lt;=W) re = i; return re;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;W); for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;w[i],&amp;v[i]); printf(&quot;%d\n&quot;,solve()); return 0;&#125; 多重背包 有n种不同大小的数组ai，每种各mi个。判断是否可以从这些数组之中选出若干使他们的和恰好为k。 限制条件{ n[1,100]、ai,mi[1,100000]、k[1,100000] } dp[i+1][j]表示前i种数加和得到j时第i种数最多能剩余多少个（不能加和得到i的情况下为-1） dp[i][j]&gt;=0时，dp[i+1][j]=m[i]； j&lt;a[i]或者dp[i+1][j-a[i]]&lt;=0时，dp[i+1][j]=-1； 其它情况，dp[i+1][j]=dp[i+1][j-a[i]]-1； 123456789101112131415161718192021222324252627282930313233 #include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN=1e5+1;int a[MAXN],m[MAXN];int dp[MAXN];int n,k;void solve()&#123; memset(dp,-1,sizeof(dp)); dp[0]=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=k;j++) if(dp[j]&gt;=0) dp[j]=m[i]; else if(j&lt;a[i]||dp[j-a[i]]&lt;=0) dp[j]=-1; else dp[j]=dp[j-a[i]]-1; if(dp[k]&gt;=0)printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,a[i]); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,m[i]); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划----最长公共子序列]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92----%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[给定连个字符串s1s2… …sn和t1t2… …tn。求出这两个字符串最长的公共子序列的长度。字符串s1s2… …sn的子序列可以表示为si1si2… …sim(i1&lt;i2&lt;… …&lt;sim)的序列。（1&lt;=n,m&lt;=1000) dp[i][j]表示s1… … si和t1… …tj对应的LCS的长度。 当s[i+1]==t[i+1]时，dp[i+1][j+1] = max(dp[i][j]+1, dp[i+1][j], dp[i][j+1])；//其实只要dp[i+1][j+1]=dp[i][j]+1 就可以了。 其它情况，dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])； 123456789101112131415161718192021222324 #include&lt;cstdio&gt;using namespace std;const int MAXN=1001;int char s[MAXN],t[MAXN];int n,m;int solve()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; if(s[i-1]==t[i-1]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; return dp[n][m];&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s%s&quot;,s,t); printf(&quot;%d&quot;,solve); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法---codeforce680D Bear and Tower of Cubes]]></title>
    <url>%2F2018%2F07%2F31%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95---codeforce680D%20Bear%20and%20Tower%20of%20Cubes%2F</url>
    <content type="text"><![CDATA[D. Bear and Tower of Cubes time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output Limak is a little polar bear. He plays by building towers from blocks. Every block is a cube with positive integer length of side. Limak has infinitely many blocks of each side length. A block with side a has volume a3. A tower consisting of blocks with sides a1, a2, …, ak has the total volume a13 + a23 + … + ak3. Limak is going to build a tower. First, he asks you to tell him a positive integer X — the required total volume of the tower. Then, Limak adds new blocks greedily, one by one. Each time he adds the biggest block such that the total volume doesn’t exceed X. Limak asks you to choose X not greater than m. Also, he wants to maximize the number of blocks in the tower at the end (however, he still behaves greedily). Secondarily, he wants to maximize X. Can you help Limak? Find the maximum number of blocks his tower can have and the maximum X ≤ m that results this number of blocks. Input The only line of the input contains one integer m (1 ≤ m ≤ 1015), meaning that Limak wants you to choose X between 1 and m, inclusive. Output Print two integers — the maximum number of blocks in the tower and the maximum required total volume X, resulting in the maximum number of blocks. Examples inputCopy 48 outputCopy 9 42 inputCopy 6 outputCopy 6 6 每一次选择最大的x3和次大的x3计算两个中更优的那个，贪心加dfs。 1234567891011121314151617181920212223242526272829 #include&lt;cstdio&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int MAXN=1e5+10;ll x3[MAXN];pair&lt;ll,ll&gt;ans(0,0);void dfs(ll m,ll cnt,ll t)&#123; if(!m)&#123; ans=max(ans,make_pair(cnt,t)); return ; &#125; int q=upper_bound(x3+1,x3+100002,m)-x3; q--; dfs(m-x3[q],cnt+1,t+x3[q]); if(q&gt;1)dfs(x3[q]-1-x3[q-1],cnt+1,t+x3[q-1]);&#125;int main()&#123; ll m; for(ll i=1;i&lt;=100001;i++) x3[i]=i*i*i; scanf(&quot;%I64d&quot;,&amp;m); dfs(m,0,0); printf(&quot;%I64d %I64d\n&quot;,ans.first,ans.second);&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法----Fence Repair(POJ 3253)]]></title>
    <url>%2F2018%2F07%2F31%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95----Fence%20Repair(POJ%203253)%2F</url>
    <content type="text"><![CDATA[Fence Repair Time Limit: 2000MS Memory Limit: 65536K Total Submissions: 60866 Accepted: 20067 Description Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too. FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw. Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents. Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths. Input Line 1: One integer N, the number of planks Lines 2..N+1: Each line contains a single integer describing the length of a needed plank Output Line 1: One integer: the minimum amount of money he must spend to make N-1 cuts Sample Input 3 8 5 8 Sample Output 34 切割方法最优就是每一次都切割两个最大的，倒过来就是将最小的接上 ，然后再将接好的替换原来的两根，再找最小的。形成一棵二叉树，二叉树的木板长度x节点深度的总和就是最优。 1234567891011121314151617181920212223 #include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N=2e4+10;int L[N];int main()&#123; int n,i; long long total=0; scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;L[i]); sort(L,L+n); for(i=0;i&lt;n-1;i++) &#123; total+=(L[i]+L[i+1]); L[i+1]+=L[i]; for(int j=i+2;j&lt;n&amp;&amp;L[j]&lt;L[j-1];j++) swap(L[j],L[j-1]); &#125; printf(&quot;%lld\n&quot;,total); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树拓展----HDU 6315 Naive Operations]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%8B%93%E5%B1%95----HDU%206315%20Naive%20Operations%2F</url>
    <content type="text"><![CDATA[Naive Operations Time Limit: 6000/3000 MS (Java/Others) Memory Limit: 502768/502768 K (Java/Others) Total Submission(s): 2623 Accepted Submission(s): 1143 Problem Description In a galaxy far, far away, there are two integer sequence a and b of length n. b is a static permutation of 1 to n. Initially a is filled with zeroes. There are two kind of operations: add l r: add one for al,al+1…ar query l r: query ∑ri=l⌊ai/bi⌋InputThere are multiple test cases, please read till the end of input file.For each test case, in the first line, two integers n,q, representing the length of a,b and the number of queries.In the second line, n integers separated by spaces, representing permutation b.In the following q lines, each line is either in the form ‘add l r’ or ‘query l r’, representing an operation.1≤n,q≤100000, 1≤l≤r≤n, there’re no more than 5 test cases.OutputOutput the answer for each ‘query’, each one line.Sample Input5 121 5 2 4 3add 1 4query 1 4add 2 5query 2 5add 3 5query 1 5add 2 4query 1 4add 2 5query 2 5add 2 2query 1 5Sample Output112446题目大意：两个数组，长度都为n，b数组元素属于[1,n],每个元素都不相同，a数组初始都为0，输入n,q,然后输入b数组，再输入q行，两种操作，add表示a数组[i,j]每个元素加一，q表示 计算[i,j]的∑ri=l⌊ai/bi⌋。分析：每个元素增一对整体的共享都是不相同的，相当于每一个b元素都对应一种进制，查询的时候计算区间和。建设线段树的时候用两个元素俩判断性质：maxa表示区间最大的a元素的值，minb表示区间最小的b元素的值，建树的时候，minb表示区间最小，mina都为0，更新的时候判断maxa&gt;=minb？是则向下产生影响，如果是叶子节点那就对总数产生影响。其它操作都是基本的区间更新区间查询的操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 #include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int MAXN=1e5+10;struct&#123; int l,r,lazy; ll maxa,minb,cnt;&#125;tree[MAXN&lt;&lt;2];ll b[MAXN];void PushUp(int i)&#123;//求子节点和 tree[i].minb=min(tree[i&lt;&lt;1].minb,tree[i&lt;&lt;1|1].minb); tree[i].maxa=max(tree[i&lt;&lt;1].maxa,tree[i&lt;&lt;1|1].maxa); tree[i].cnt=tree[i&lt;&lt;1].cnt+tree[i&lt;&lt;1|1].cnt;&#125;void BuildTree(int i,int L,int R)&#123;//建立一颗[L,R]的树 tree[i].l=L; tree[i].r=R; tree[i].lazy=0; tree[i].maxa=0; tree[i].cnt=0; if(L==R)&#123; tree[i].minb=b[L]; return ; &#125; BuildTree(i&lt;&lt;1,L,(L+R)&gt;&gt;1); BuildTree(i&lt;&lt;1|1,((L+R)&gt;&gt;1)+1,R); tree[i].minb=min(tree[i&lt;&lt;1].minb,tree[i&lt;&lt;1|1].minb); return ;&#125;void PushDown(int i)&#123;//判断延迟父节点的延迟变量，作用到子节点 if(tree[i].lazy)&#123; tree[i&lt;&lt;1].maxa+=tree[i].lazy; tree[i&lt;&lt;1|1].maxa+=tree[i].lazy; tree[i&lt;&lt;1].lazy+=tree[i].lazy; tree[i&lt;&lt;1|1].lazy+=tree[i].lazy;//更新左右子节点的lazy tree[i].lazy=0;//将lazy传给子节点后字节归零 &#125;&#125;void Update(int L,int R,int i)&#123;//更新[L,R] if(L&lt;=tree[i].l&amp;&amp;R&gt;=tree[i].r)&#123; tree[i].maxa++; if(tree[i].maxa&lt;tree[i].minb) &#123; tree[i].lazy++; return ; &#125; if(tree[i].l==tree[i].r&amp;&amp;tree[i].maxa&gt;=tree[i].minb) &#123; tree[i].cnt++; tree[i].minb+=b[tree[i].l]; return ; &#125; &#125; PushDown(i);//否则，将i的延迟变化量作用到左右子节点上 if(L&lt;=tree[i&lt;&lt;1].r) Update(L,R,i&lt;&lt;1); if(R&gt;=tree[i&lt;&lt;1|1].l) Update(L,R,i&lt;&lt;1|1); PushUp(i);&#125;ll Query(int L,int R,int i)&#123;//查询[L,R]区间，从i开始查询 if(L&lt;=tree[i].l&amp;&amp;R&gt;=tree[i].r) return tree[i].cnt; PushDown(i); ll t=0; if(L&lt;=tree[i&lt;&lt;1].r) t+=Query(L,R,i&lt;&lt;1); if(R&gt;=tree[i&lt;&lt;1|1].l) t+=Query(L,R,i&lt;&lt;1|1); return t;&#125;int main()&#123; int n,q,l,r; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;q)) &#123; for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;b[i]); BuildTree(1,1,n); while(q--) &#123; char op[6]; scanf(&quot;%s&quot;,op); scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(op[0]==&apos;q&apos;) printf(&quot;%lld\n&quot;,Query(l,r,1)); else Update(l,r,1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Saruman`s Army(POJ 3069)]]></title>
    <url>%2F2018%2F07%2F30%2FSaruman%60s%20Army(POJ%203069)%2F</url>
    <content type="text"><![CDATA[Saruman’s Army Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 13974 Accepted: 7011 Description Saruman the White must lead his army along a straight path from Isengard to Helm’s Deep. To keep track of his forces, Saruman distributes seeing stones, known as palantirs, among the troops. Each palantir has a maximum effective range of R units, and must be carried by some troop in the army (i.e., palantirs are not allowed to “free float” in mid-air). Help Saruman take control of Middle Earth by determining the minimum number of palantirs needed for Saruman to ensure that each of his minions is within R units of some palantir. Input The input test file will contain multiple cases. Each test case begins with a single line containing an integer R, the maximum effective range of all palantirs (where 0 ≤ R ≤ 1000), and an integer n, the number of troops in Saruman’s army (where 1 ≤ n ≤ 1000). The next line contains n integers, indicating the positions x1, …, xn of each troop (where 0 ≤ xi ≤ 1000). The end-of-file is marked by a test case with R = n = −1. Output For each test case, print a single integer indicating the minimum number of palantirs needed. Sample Input 0 3 10 20 20 10 7 70 30 1 7 15 20 50 -1 -1 Sample Output 2 4 将点从小到大排序，从左边开始选点，排除覆盖的点，再从新开始选点。 1234567891011121314151617181920212223242526272829 #include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int r,n,d=0; int data[1010]; while(cin&gt;&gt;r&gt;&gt;n&amp;&amp;(r!=-1||n!=-1)) &#123; d++; for(int i=0;i&lt;n;i++) cin&gt;&gt;data[i]; sort(data,data+n); int i=0; int a=data[0]; int b=data[n-1]; int total=0; while(i&lt;n&amp;&amp;a&lt;=b) &#123; while(i&lt;n&amp;&amp;data[i]&lt;=a+r)i++; a=data[i-1]; while(i&lt;n&amp;&amp;data[i]&lt;=a+r)i++; total++; if(i&lt;n)a=data[i]; &#125; cout&lt;&lt;total&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典序最小问题 Best Cow Line (POJ 3617)]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98%20Best%20Cow%20Line%20(POJ%203617)%2F</url>
    <content type="text"><![CDATA[Best Cow Line Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 32184 Accepted: 8533 Description FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges. The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names. FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them. FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order. Given the initial order of his cows, determine the least lexicographic string of initials he can make this way. Input Line 1: A single integer: N Lines 2..N+1: Line i+1 contains a single initial (‘A’..’Z’) of the cow in the ith position in the original line Output The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line. Sample Input 6ACDBCB 先对第一个字母和最后一个字母进行比较，取较小的那个，如果相等对顺序序列和逆序序列进行比较，取小的那头。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; char cow[2010],ne[2010]; int n; scanf(&quot;%d&quot;,&amp;n); getchar(); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%c&quot;,&amp;cow[i]); getchar(); &#125; int a=0,b=n-1,j=0; while(a&lt;=b) &#123; bool cmp=false; for(int i=0;a+i&lt;=b;i++) &#123; if(cow[a+i]&lt;cow[b-i]) &#123; cmp=false; break; &#125; else if(cow[a+i]&gt;cow[b-i]) &#123; cmp=true; break; &#125; &#125; if(cmp) &#123; ne[j++]=cow[b--]; &#125; else &#123; ne[j++]=cow[a++]; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; printf(&quot;%c&quot;,ne[i]); if((i+1)%80==0&amp;&amp;i&lt;n-1) printf(&quot;\n&quot;); &#125;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RMQ]]></title>
    <url>%2F2018%2F07%2F27%2FRMQ%2F</url>
    <content type="text"><![CDATA[RMQ（Range Minimum/Maximum Query），即区间最值查询，是指这样一个问题：对于长度为n的数列A，回答若干次询问RMQ(i,j)，返回数列A中下标在区间[i,j]中的最小/大值。 本文介绍一种比较高效的ST算法解决这个问题。ST（Sparse Table）算法可以在O(nlogn)时间内进行预处理，然后在O(1)时间内回答每个查询。 1）预处理 设A[i]是要求区间最值的数列，F[i, j]表示从第i个数起连续2^j个数中的最大值。（DP的状态） 例如： A数列为：3 2 4 5 6 8 1 2 9 7 F[1，0]表示第1个数起，长度为2^0=1的最大值，其实就是3这个数。同理 F[1,1] = max(3,2) = 3, F[1，2]=max(3,2,4,5) = 5，F[1，3] = max(3,2,4,5,6,8,1,2) = 8; 并且我们可以容易的看出F[i,0]就等于A[i]。（DP的初始值） 我们把F[i，j]平均分成两段（因为F[i，j]一定是偶数个数字），从 i 到i + 2 ^ (j - 1) - 1为一段，i + 2 ^ (j - 1)到i + 2 ^ j - 1为一段(长度都为2 ^ (j - 1))。于是我们得到了状态转移方程F[i, j]=max（F[i，j-1], F[i + 2^(j-1)，j-1]）。 2)查询 假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询1，2，3，4，5，我们可以查询1234和2345）。 因为这个区间的长度为j - i + 1,所以我们可以取k=log2( j - i + 1)，则有：RMQ(i, j)=max{F[i , k], F[ j - 2 ^ k + 1, k]}。 举例说明，要求区间[1，5]的最大值，k = log2（5 - 1 + 1）= 2，即求max(F[1, 2]，F[5 - 2 ^ 2 + 1, 2])=max(F[1, 2]，F[2, 2])； 1234567891011121314 void ST(int n) &#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = A[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) &#123; dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int RMQ(int l, int r) &#123; int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= r - l + 1) k++; return max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);&#125; 转载博客：https://blog.csdn.net/qq_31759205/article/details/75008659]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客2018年第二次acm暑期培训----H-Diff-prime Pairs]]></title>
    <url>%2F2018%2F07%2F27%2F%E7%89%9B%E5%AE%A22018%E5%B9%B4%E7%AC%AC%E4%BA%8C%E6%AC%A1acm%E6%9A%91%E6%9C%9F%E5%9F%B9%E8%AE%AD----H-Diff-prime%20Pairs%2F</url>
    <content type="text"><![CDATA[题目描述： 链接：https://www.nowcoder.com/acm/contest/141/H 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 Eddy has solved lots of problem involving calculating the number of coprime pairs within some range. This problem can be solved with inclusion-exclusion method. Eddy has implemented it lots of times. Someday, when he encounters another coprime pairs problem, he comes up with diff-prime pairs problem. diff-prime pairs problem is that given N, you need to find the number of pairs (i, j), where %7D) and %7D) are both prime and i ,j ≤ N. gcd(i, j) is the greatest common divisor of i and j. Prime is an integer greater than 1 and has only 2 positive divisors. Eddy tried to solve it with inclusion-exclusion method but failed. Please help Eddy to solve this problem. Note that pair (i1, j1) and pair (i2, j2) are considered different if i1 ≠ i2 or j1 ≠ j2. 输入描述:123 Input has only one line containing a positive integer N.1 ≤ N ≤ 107 输出描述:1Output one line containing a non-negative integer indicating the number of diff-prime pairs (i,j) where i, j ≤ N 示例1 输入13 输出12 示例2 输入15 输出16 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 #include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int MAXSIZE=1e7+10;int Mark[MAXSIZE&lt;&lt;2];int prime[MAXSIZE]; ll sum(ll n)&#123; if(n%2==0)return (n+1)*(n&gt;&gt;1); else return ((n+1)&gt;&gt;1)*n;&#125;int Prime(int n)&#123; int index = 0; memset(Mark,0,sizeof(Mark)); for(int i = 2; i &lt;= n; i++) &#123; if(Mark[i] == 0)&#123; prime[index++] = i; &#125; for(int j = 0; j &lt; index &amp;&amp; prime[j] * i &lt;= n; j++) &#123; Mark[i * prime[j]] = 1; if(i % prime[j] == 0)&#123; break; &#125; &#125; &#125; return index;&#125;int main()&#123; int n,total,i=2; ll s=0; ios::sync_with_stdio(false); cin&gt;&gt;n; total=Prime(n); s+=sum((ll)total-1)*2; while(total&gt;=2)&#123; if(prime[total-1]*i&lt;=n)&#123; s+=sum((ll)total-1)*2; i++; &#125; else total--; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客2018年第二次多校培训----A-run]]></title>
    <url>%2F2018%2F07%2F27%2F%E7%89%9B%E5%AE%A22018%E5%B9%B4%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%A4%9A%E6%A0%A1%E5%9F%B9%E8%AE%AD----A-run%2F</url>
    <content type="text"><![CDATA[题目描述： 链接：https://www.nowcoder.com/acm/contest/140/A 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K 64bit IO Format: %lld 题目描述 White Cloud is exercising in the playground. White Cloud can walk 1 meters or run k meters per second. Since White Cloud is tired,it can’t run for two or more continuous seconds. White Cloud will move L to R meters. It wants to know how many different ways there are to achieve its goal. Two ways are different if and only if they move different meters or spend different seconds or in one second, one of them walks and the other runs. 输入描述:12 The first line of input contains 2 integers Q and k.Q is the number of queries.(Q&lt;=100000,2&lt;=k&lt;=100000)For the next Q lines,each line contains two integers L and R.(1&lt;=L&lt;=R&lt;=100000) 输出描述:1For each query,print a line which contains an integer,denoting the answer of the query modulo 1000000007. 示例1 输入1234 3 33 31 41 5 输出123 2711 1234567891011121314151617181920212223242526272829 #include &lt;iostream&gt;#include &lt;stdio.h&gt;#define MOD 1000000007using namespace std;int main()&#123; long long a[100005],b[100005]; int q,k,l,r; cin&gt;&gt;q&gt;&gt;k; b[0]=0; for(int i=1;i&lt;k;i++) &#123; a[i]=1; b[i]=b[i-1]+a[i]; &#125; a[k]=2;b[k]=b[k-1]+a[k]; a[k+1]=3;b[k+1]=b[k]+a[k+1]; for(int i=k+2;i&lt;100005;i++) &#123; a[i]=(a[i-1]+a[i-k-1])%MOD; b[i]=(b[i-1]+a[i])%MOD; &#125; for(int i=0;i&lt;q;i++) &#123; cin&gt;&gt;l&gt;&gt;r; printf(&quot;%lld\n&quot;,(MOD+b[r]-b[l-1])%MOD); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（dp)----hdu1024 Max Sum Plus Plus]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp)----hdu1024%20Max%20Sum%20Plus%20Plus%2F</url>
    <content type="text"><![CDATA[题目描述： Max Sum Plus Plus Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 36429 Accepted Submission(s): 12963 Problem Description Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence S_1_, S_2_, S_3_, S_4_ … S_x_, … S_n_ (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ S_x_ ≤ 32767). We define a function sum(i, j) = S_i_ + … + S_j_ (1 ≤ i ≤ j ≤ n). Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i_1_, j_1_) + sum(i_2_, j_2_) + sum(i_3_, j_3_) + … + sum(i_m_, j_m_) maximal (i_x_ ≤ i_y_ ≤ j_x_ or i_x_ ≤ j_y_ ≤ j_x_ is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(i_x_, j_x_)(1 ≤ x ≤ m) instead. ^_^ Input Each test case will begin with two integers m and n, followed by n integers S_1_, S_2_, S_3_ … S_n_. Process to the end of file. Output Output the maximal summation described above in one line. Sample Input 1 3 1 2 3 2 6 -1 4 -2 3 -2 3 Sample Output 6 8 题目大意：先输入两个数m,n，n表示接下来输入一个含有n个元素的序列，m表示在序列中，找到m个连续子段，相互不相交不包含。输出m个子段和最大的子段的和。 题目分析：dp解决就是将问题缩小，求n个元素的序列中m个子段，可以通过一种方式将问题转换为求m-1个子段，或者求n-1个元素的子段中m个子段。就会得到求n序列m子段就是求n-1序列中m-1子段与n-1序列总m子段的最大值，前者表示将在n-1序列中找到m-1子段的最大值再加上最后一个元素单独成一段就是n个元素中m个子段，后者表示在n-1序列中m个子段的最后一个段中加上第n个元素。两者加起来就是n序列m子段的全部情况了。 实现：用一个二维数组进行模拟，i行表示分成i段，j列表示j个元素的序列。dp[i][j]表示包含第j个元素在内的j个元素序列分成i段的子段和。 假设我们要球的序列m=4，那么我们要求的就是左下图最下面那一行的最大值，然后我们删除没有用的元素得到右下图。 其实我们要求的元素就只有中间类似的几条对角线中的元素。并且求每行元素都只与其前面那行元素有联系，因此我们要保存的元素就只有两行。 然后我们再通过t=1-t的变化滚动数组得到第一行，然后得到第二行… …直到得到第m行。 再计算过程中由于只要得到中间几个元素，因此要确定每一次计算的右边界。如下图得到第i行的边界n-m-i： 代码如下： 12345678910111213141516171819202122232425262728293031 #include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=1e6+10;int dp[2][MAXN],d[MAXN];int Max(int x,int y)&#123;return x&gt;y?x:y;&#125;int main()&#123; ios::sync_with_stdio(false); int i,j,m,n,maxn,re,t=1; while(cin&gt;&gt;m&gt;&gt;n)&#123; dp[0][0]=dp[1][0]=d[0]=0;//初始化 for(i=1;i&lt;=n;i++)&#123; dp[0][i]=dp[1][i]=0;//初始化 cin&gt;&gt;d[i]; &#125; for(i=1;i&lt;=m;i++)&#123;//左界 dp[t][i]=dp[1-t][i-1]+d[i]; maxn=dp[1-t][i-1]; for(j=i+1;j&lt;=n-m+i;j++)&#123;//右界 maxn=Max(maxn,dp[1-t][j-1]);//得到上一行j之前的最大值 dp[t][j]=Max(maxn,dp[t][j-1])+d[j]; &#125; t=1-t;//滚动 &#125; t=1-t; for(i=m+1,re=dp[t][m];i&lt;=n;i++) re=Max(re,dp[t][i]); cout&lt;&lt;re&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法----nyoj 14 会场安排]]></title>
    <url>%2F2018%2F07%2F26%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95----nyoj%2014%20%E4%BC%9A%E5%9C%BA%E5%AE%89%E6%8E%92%2F</url>
    <content type="text"><![CDATA[题目详情： 会场安排问题 时间限制：3000 ms | 内存限制：65535 KB 描述 学校的小礼堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校小礼堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。 输入 第一行是一个整型数m(m&lt;100)表示共有m组测试数据。 每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。 随后的n行，每行有两个正整数Bi,Ei(0&lt;=Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;=Ei) 输出 对于每一组输入，输出最多能够安排的活动数量。 每组的输出占一行 样例输入 12345678 221 1010 1131 1010 1111 20 样例输出 12 12 解题思路：先将数据进行排序，根据时间段的结束时间从小到大安排，然后根据开始时间从大到小安排，最后从序列中找到第一个时间段，再将一天的开始时间设置为前面那段时间的结束时间，再找下面的时间段，知道所有的时间段都找完。 1234567891011121314151617181920212223242526272829303132333435363738 #include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int MAXN=1e4+10;struct Time&#123; int b,e;&#125;;bool operator&lt;(Time a,Time b)&#123; if(a.e==b.e) return a.b&gt;=b.b; return a.e&lt;b.e;&#125;int main()&#123; ios::sync_with_stdio(false);//关闭同步，节约时间 int m,n,i,count,first; cin&gt;&gt;m; while(m--)&#123; cin&gt;&gt;n; vector&lt;Time&gt; t(n); for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;t[i].b&gt;&gt;t[i].e; &#125; sort(t.begin(),t.end()); first=-1;i=0;count=0; while(i&lt;n)&#123; if(t[i].b&gt;first)&#123; count++; first=t[i].e; &#125; i++; &#125; cout&lt;&lt;count&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组解决区间更新单点查询----hdu 1556 Color the ball]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2----hdu%201556%20Color%20the%20ball%2F</url>
    <content type="text"><![CDATA[题目详情： Color the ball Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 26931 Accepted Submission(s): 13049 Problem Description N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？ Input 每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。 当N = 0，输入结束。 Output 每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。 Sample Input 3 1 1 2 2 3 3 3 1 1 1 2 1 3 0 Sample Output 1 1 1 3 2 1 题目分析：其实这个题目根本不需要用到树状数组，完全可以用简单的技巧解出来。代码如下： 123456789101112131415161718192021222324 #include &quot;stdio.h&quot;int main()&#123; int n,i,l,s,r; while(scanf(&quot;%d&quot;,&amp;n),n) &#123; int c[100001]=&#123;0&#125;; i=n; s=0; while(i--) &#123; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); c[l]++; c[r+1]--; &#125; for(i=1;i&lt;n;i++) &#123; s+=c[i]; printf(&quot;%d &quot;,s); &#125; printf(&quot;%d\n&quot;,s+c[n]); &#125; return 0;&#125; 虽然能这样解，但是下次遇到不是查询所有点而是查询，更新一次查询一次，并且查询不是连续的就不能直接这样了。树状数组是这样的，因为我们要求的是每一个点的和所以只要将更新区间的c[l]加上增量然后c[r+1]减去增量就可以了。如下图 为什么会有这样的效果呢，每一次更新都会将后面+=lowbit（）的下标更新,c[i]+add后面相应的位置都会+add，然后再c[j]-add,后面的相应位置都会-add。 下面是树状数组的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 #include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=1e5+10;int s[MAXN];int n;int lowbit(int x)&#123;return x&amp;(-x);&#125;int sum(int x)&#123; int sum=0; while(x)&#123; sum+=s[x]; x-=lowbit(x); &#125; return sum;&#125;void add(int x)&#123; while(x&lt;=MAXN)&#123; s[x]++; x+=lowbit(x); &#125;&#125;void sub(int x)&#123; while(x&lt;=MAXN)&#123; s[x]--; x+=lowbit(x); &#125;&#125;int main()&#123; int a,b; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n!=0)&#123; memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a);//在做端点加 sub(b+1);//在有端点后面一个位置减 &#125; for(int i=1;i&lt;=n;i++)&#123; printf(&quot;%d&quot;,sum(i)); if(i!=n)printf(&quot; &quot;); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeblocks调试问题--单步调试遇到breakpoint不停---不能单步调试--运行按钮是灰色但是没有dos窗口]]></title>
    <url>%2F2018%2F07%2F24%2Fcodeblocks%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98--%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%E9%81%87%E5%88%B0breakpoint%E4%B8%8D%E5%81%9C---%E4%B8%8D%E8%83%BD%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95--%E8%BF%90%E8%A1%8C%E6%8C%89%E9%92%AE%E6%98%AF%E7%81%B0%E8%89%B2%E4%BD%86%E6%98%AF%E6%B2%A1%E6%9C%89dos%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[今天晚上调试的时候可能不小心改了设置，还是其它原因，codeblocks突然遇到breakpoint不停了，然后百度了一下，大部分是说project创建的问题，感觉和自己的问题不同，我的问题是所有的project都不能单步调试。然后在seting-&gt;debug设置中找了一会都没有找到相应的设置，然后我就到debug中找到了debug-&gt;active debuggers-&gt;gdb/cdb debugger:default,勾选之后发现可以调试了，然后决定用博客记录下来，希望能给遇到相似的问题的同学也能得到帮助。 以前刚用codeblocks编写程序的时候发现也不能但不单步调试，单步调试的时候提示下面一样的信息，其实下面的信息就是解决方法，下面大概意思就是没有但不调试的软件。 点开setting-&gt;debugger 上面的红色框中就是你要选择调试器的路径，点开选择路径，如果codeblocks软件是安装在C:\Program Files (x86)下面的话就是下面图片中所示的路径了，然后选择gdb32.exe，点击ok保存就可以调试了。（对了，还要选择上图中的GDB选项） 有时候调试器出错了，虽然你看不到程序的运行窗口，但是程序其实是在运行的。并且你是不可以再点击运行按钮运行程序的，这个时候就可以打开任务管理器，关闭相应的任务了，一般关闭想下图所示的那样的图标一样的任务就可以了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树+树状数组----hdoj 1166 敌兵布阵]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84----hdoj%201166%20%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目描述： 敌兵布阵 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 117851 Accepted Submission(s): 49318 Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。 中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。 每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。 接下来每行有一条命令，命令有4种形式： (1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30） (2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）; (3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数; (4)End 表示结束，这条命令在每组数据最后出现; 每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车, 对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input 1 10 1 2 3 4 5 6 7 8 9 10 Query 1 3 Add 3 6 Query 2 7 Sub 10 2 Add 6 3 Query 3 10 End Sample Output Case 1: 6 33 59 题目分析：单点更新，求区间和，即可以用树状数组模板解决，也可以用线段树模板解决。 树状数组： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 #include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=50005;int d[maxn];//记录前缀和int lowbit(int x)&#123;return x&amp;(-x);&#125;int Queries(int x,int y)//查询&#123; int sumx,sumy; sumx=sumy=0; while(x) &#123; sumx+=d[x]; x-=lowbit(x); &#125; while(y) &#123; sumy+=d[y]; y-=lowbit(y); &#125; return sumy-sumx;&#125;void add(int x,int v)//更新&#123; while(x&lt;maxn) &#123; d[x]+=v; x+=lowbit(x); &#125;&#125;int main()&#123; int T,i,x,y,v,n; char order[10]; scanf(&quot;%d&quot;,&amp;T); i=1; while(i&lt;=T) &#123; memset(d,0,sizeof(d)); scanf(&quot;%d&quot;,&amp;n); for(int j=1;j&lt;=n;j++) &#123; scanf(&quot;%d&quot;,&amp;v); add(j,v); &#125; printf(&quot;Case %d:\n&quot;,i++); while(true) &#123; scanf(&quot;%s&quot;,order); if(order[0]==&apos;A&apos;) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;v); add(x,v); &#125; else if(order[0]==&apos;S&apos;) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;v); add(x,-v); &#125; else if(order[0]==&apos;Q&apos;) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\n&quot;,Queries(x-1,y)); &#125; else break; &#125; &#125; return 0;&#125; 线段树： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 #include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;const int MAXNODE=1&lt;&lt;17;const int MAXN=50005;struct &#123; int value,right,left;&#125;node[MAXNODE];int father[MAXN];void BuildTree(int i,int left,int right)&#123; node[i].left = left; node[i].right = right; node[i].value = 0; if(left==right)&#123; father[left] = i; return ; &#125; BuildTree(i&lt;&lt;1,left,(int) floor((right+left)/2.0)); BuildTree((i&lt;&lt;1)+1,(int) floor((right+left)/2.0+1),right);&#125;void UpdateTree(int ni,int add)&#123; node[ni].value+=add; if(ni==1) return ; UpdateTree(ni/2,add);&#125;int Sum;void Query(int i,int left,int right)&#123; if(node[i].left==left&amp;&amp;node[i].right==right)&#123; Sum+=node[i].value; return ; &#125; i=i&lt;&lt;1; if(left&lt;=node[i].right)&#123; if(right&lt;=node[i].right)Query(i,left,right); else Query(i,left,node[i].right); &#125; i++; if(right&gt;=node[i].left)&#123; if(left&gt;=node[i].left)Query(i,left,right); else Query(i,node[i].left,right); &#125;&#125;int main()&#123; int T,n; scanf(&quot;%d&quot;,&amp;T); int i,j=1,d; while(j&lt;=T)&#123; scanf(&quot;%d&quot;,&amp;n); BuildTree(1,1,n); for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;d); UpdateTree(father[i],d); &#125; char par[6]; int a,b; printf(&quot;Case %d:\n&quot;,j++); while(~scanf(&quot;%s&quot;,par)&amp;&amp;par[0]!=&apos;E&apos;)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(par[0]==&apos;Q&apos;)&#123; Sum=0; Query(1,a,b); printf(&quot;%d\n&quot;,Sum); &#125; else if(par[0]==&apos;A&apos;)&#123; UpdateTree(father[a],b); &#125; else if(par[0]==&apos;S&apos;)&#123; UpdateTree(father[a],-b); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树----hdoj 1754 I here it]]></title>
    <url>%2F2018%2F07%2F23%2F%E7%BA%BF%E6%AE%B5%E6%A0%91----hdoj%201754%20I%20here%20it%2F</url>
    <content type="text"><![CDATA[题目表述： I Hate It Time Limit: 9000/3000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 96882 Accepted Submission(s): 36592 Problem Description 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。 这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。 在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。 当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input 5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output 5 6 5 9 题目分析： 因为学生的成绩的动态更新的，并且是区间查询，求区间的最大值。这是一个很明显的线段树的题目，线段树记录每一段区间的最大值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 #include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int MAXN = 2e6+10;//学生的最大个数const int MAXNODE = 1&lt;&lt;19;//线段树节点的最多个数//学生数量在最下层，我们可以根据满二叉树的性质计算所有节点的性质struct &#123; int value,right,left;//value记录区间的最大值&#125;node[MAXNODE];int father[MAXN];//记录节点在二叉树中的位置void BuildTree(int i,int left,int right)&#123;//建树，将树所有节点初始化为0，得到father的数据 node[i].left = left; node[i].right = right; node[i].value = 0; if(left==right)&#123; father[left] = i; return ; &#125; BuildTree(i&lt;&lt;1,left,(int) floor((right+left)/2.0));//建左数 BuildTree((i&lt;&lt;1)+1,(int) floor((right+left)/2.0+1),right);//建右树&#125;void UpdateTree(int ni)&#123;//更新树 if(ni==1)return ; int fni=ni/2; int lv=node[fni&lt;&lt;1].value; int rv=node[(fni&lt;&lt;1)+1].value; node[fni].value=max(lv,rv);//得到左右孩子的最大值 UpdateTree(ni/2);//更新父亲&#125;int Max;void Query(int i,int left,int right)//从i位置开始查询(left,right)区间的的最大值&#123; if(node[i].left==left&amp;&amp;node[i].right==right)&#123;//找到要查询的区间计算 Max = max(Max,node[i].value); return ; &#125; i=i&lt;&lt;1; if(left&lt;=node[i].right)&#123;//对左孩子查询 if(right&lt;=node[i].right)Query(i,left,right); else Query(i,left,node[i].right); &#125; i++; if(right&gt;=node[i].left)//对有孩子查询 &#123; if(left&gt;=node[i].left)Query(i,left,right); else Query(i,node[i].left,right); &#125;&#125;int main()&#123; int n,m,i,g; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; BuildTree(1,1,n);//从1开始键树 for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;g); node[father[i]].value=g;//更新叶子节点 UpdateTree(father[i]);//向上更新父亲节点 &#125; char par[2]; int a,b; while(m--)&#123; scanf(&quot;%s&quot;,par); scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(par[0]==&apos;Q&apos;)&#123; Max=0; Query(1,a,b);//查询 printf(&quot;%d\n&quot;,Max); &#125; else&#123; node[father[a]].value=b;//更新a学生的成绩 UpdateTree(father[a]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队算法]]></title>
    <url>%2F2018%2F07%2F21%2F%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[莫队算法是一种解决区间问题的算法，是一种很优的暴力算法。 莫队算法的基本思想是，知道一个区间[l,r]的一些信息，就可以在很短的时间内求出它的扩展区间的一些信息。 算法讲解挺详细的链接点击跳转到百度文库pdf文档 题目描述 Given a sequence of integers a1, a2, …, an and q pairs of integers (l1, r1), (l2, r2), …, (lq, rq), find count(l1, r1), count(l2, r2), …, count(lq, rq) where count(i, j) is the number of different integers among a1, a2, …, ai, aj, aj + 1, …, an. 输入描述:1234 The input consists of several test cases and is terminated by end-of-file.The first line of each test cases contains two integers n and q.The second line contains n integers a1, a2, ..., an.The i-th of the following q lines contains two integers li and ri. 输出描述:1For each test case, print q integers which denote the result. 示例1 输入 复制 1234567 3 21 2 11 21 34 11 2 3 41 3 输出 复制 123 213 备注:1234 * 1 ≤ n, q ≤ 105* 1 ≤ ai ≤ n* 1 ≤ li, ri ≤ n* The number of test cases does not exceed 10. 题目意思是给定一个序列，输入下标（i，j)计算序列不包括区间（i，j）之后的不同数字的个数。 首先用暴力求解：直接对于每一个样例进行去掉中间区间再进行遍历 1234567891011121314151617181920212223242526272829303132333435363738394041 #include&lt;iostream&gt;using namespace std;const int maxn=100005;int q,m;int s[maxn],rec[maxn],Ans[manx];struct Par&#123;int lef,rig&#125;par[maxn];int main()&#123; int i,j; while(scanf(&quot;%d%d&quot;,&amp;q,&amp;m)!=EOF) &#123; memset(Ans,0,sizeof(Ans)); for(i=0;i&lt;q;i++) &#123; scanf(&quot;%d&quot;,&amp;s[i]); &#125; for(i=0;i&lt;m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;par[i].lef,&amp;par[i].rig); &#125; for(i=0;i&lt;m;i++) &#123; memset(rec,0,sizoef(rec)); for(j=0;j&lt;par[i].lef;j++) &#123; if(rec[j]==0) Ans[i]++; rec[j]=1; &#125; for(j=par[i].rig;j++) &#123; if(rec[j]==0) Ans[i]++; rec[j]=1; &#125; &#125; for(j=0;j&lt;m;j++) printf(&quot;%d\n&quot;,Ans[j]); &#125; return 0;&#125; 提交的结果是运行超时。 莫队算法，同样是暴力但是它是根据知道了区间O(1)的时间去求它旁边的区间。 其算法思路是这样的，先将n个元素的序列分成sqrt（n）组，然后对查询区间先根据左端点所在的组排序，然后再根据右端点排序，再进行查询，每一次查询都使用前面得到的查询结果进行更新。 下面代码的思路是：先对整个序列进项查询，记录不同数组的总数，然后减去莫队算法得到的中间区间的总数，但是提交还是超时的，不过可以看出时间复杂度要比之前的暴力要更少。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 #include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int q,m;int s[maxn],rec[maxn],md[maxn],Ans[maxn];struct Par&#123;int lef,rig,id;&#125;par[maxn];bool cmp(Par a,Par b)&#123; if(md[a.lef]!=md[b.lef])return a.lef&lt;b.lef; return a.rig&lt;b.rig;&#125;void solve()&#123; int i,lef=1,rig=1,ans=0; for(i=1;i&lt;=m;i++) &#123; while(lef&lt;par[i].lef) if(--rec[s[lef++]]==0) ans--; while(lef&gt;par[i].lef) if(rec[s[--lef]]++==0) ans++; while(rig&lt;par[i].rig) if(rec[s[++rig]]++==0) ans++; while(rig&gt;par[i].rig) if(--rec[s[rig--]]==0) ans--; Ans[par[i].id]=ans; &#125; return ;&#125;int main()&#123; int i,temp,total; while(scanf(&quot;%d%d&quot;,&amp;q,&amp;m)!=EOF) &#123; memset(rec,0,sizeof(rec)); temp=sqrt(q); total=0; for(i=1;i&lt;=q;i++) &#123; scanf(&quot;%d&quot;,&amp;s[i]); md[i]=(i-1)/temp+1; if(rec[s[i]]==0) &#123; total++; rec[s[i]]=1; &#125; &#125; for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;par[i].lef,&amp;par[i].rig); par[i].lef++; par[i].rig--; par[i].id=i; &#125; sort(par+1,par+m+1,cmp); memset(rec,0,sizeof(rec)); solve(); for(i=1;i&lt;=m;i++)printf(&quot;%d\n&quot;,total-Ans[i]); &#125; return 0;&#125; 下面的代码是优化后的莫队排序，通过直接计算两边区间的总数得到答案。提交时通过的，但是运行的时间和时间限制很接近，所以莫队算法并不是解这道题的最优算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 #include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=100005;int q,m;int s[maxn],rec[maxn],md[maxn],Ans[maxn];struct Par&#123;int lef,rig,id;&#125;par[maxn];bool cmp(Par a,Par b)&#123; if(md[a.lef]!=md[b.lef])return a.lef&lt;b.lef; return a.rig&lt;b.rig;&#125;void solve()&#123; int i,lef=0,rig=q+1,ans=0; for(i=1;i&lt;=m;i++) &#123; while(rig&lt;par[i].rig) &#123; rec[s[rig]]--; if(rec[s[rig]]==0) ans--; rig++; &#125; while(rig&gt;par[i].rig) &#123; rig--; if(rec[s[rig]]==0) ans++; rec[s[rig]]++; &#125; while(lef&lt;par[i].lef) &#123; lef++; if(rec[s[lef]]==0) ans++; rec[s[lef]]++; &#125; while(lef&gt;par[i].lef) &#123; rec[s[lef]]--; if(rec[s[lef]]==0) ans--; lef--; &#125; Ans[par[i].id]=ans; &#125; return ;&#125;int main()&#123; int i,temp; while(scanf(&quot;%d%d&quot;,&amp;q,&amp;m)!=EOF) &#123; memset(rec,0,sizeof(rec)); memset(Ans,0,sizeof(Ans)); temp=sqrt(q); for(i=1;i&lt;=q;i++) &#123; scanf(&quot;%d&quot;,&amp;s[i]); md[i]=(i-1)/temp+1; &#125; for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;par[i].lef,&amp;par[i].rig); par[i].id=i; &#125; sort(par+1,par+m+1,cmp); solve(); for(i=1;i&lt;=m;i++)printf(&quot;%d\n&quot;,Ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GetModuleFileName函数]]></title>
    <url>%2F2018%2F07%2F05%2FGetModuleFileName%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[GetModuleFileName函数检索指定模块的完全限定路径。 要指定包含模块的进程，请使用GetModuleFileNameEx函数。 1**DWORD GetModuleFileName( HMODULE**_ [hModule]()_**, **// handle to module ** LPTSTR**_ [lpFilename]()_**, **// path buffer ** DWORD**_ [nSize]()_ // size of buffer **);** 参数 hModule:[in]请求路径的模块的句柄。如果该参数为空，GetModuleFileName将检索当前模块的路径。 lpFilename:[out]指向缓冲区的指针，该缓冲区接收模块的完全限定路径。如果字符串的长度超过了nSize参数指定的大小，则该字符串将被截断。 Windows NT/2000/XP:路径可以有前缀“\?”基于加载模块的方式。有关更多信息，请参见文件名称约定。nSize:[in]在TCHARs中指定lpFilename缓冲区的长度。 返回值 如果函数成功，返回值是在TCHARs中复制到缓冲区的字符串的长度。如果函数失败，返回值为0。要获得扩展错误信息，请调用GetLastError。 示例代码： 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main(void)&#123; char regname[]=&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run&quot;; HKEY hkResult; int ret; ret=RegOpenKey(HKEY_CURRENT_USER,regname,&amp;hkResult); ret=RegSetValueEx(hkResult,&quot;door&quot;,0,REG_EXPAND_SZ,(unsigned char *)&quot;%systemroot%\\door.exe&quot;,25); if(ret==0) &#123; printf(&quot;success to write run key\n&quot;); RegCloseKey(hkResult); &#125; else &#123; printf(&quot;failed to open regedit.%d\n&quot;,ret); RegCloseKey(hkResult); &#125; char modlepath[256]; char syspath[256]; GetModuleFileName(0,modlepath,256);//获取当前执行模块所在路径 GetSystemDirectory(syspath,256); ret=CopyFile(modlepath,strcat(syspath,&quot;\\door.exe&quot;),1); if(ret) printf(&quot;%s has been copyed to sys dir %s\n&quot;,modlepath,syspath); else printf(&quot;%s is exisis&quot;,modlepath); return 0;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegQueryValueEx函数]]></title>
    <url>%2F2018%2F07%2F05%2FRegQueryValueEx%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[RegQueryValueEx函数检索与开放注册表键关联的指定值名称的类型和数据。 1**LONG RegQueryValueEx( HKEY**_ [hKey]()_**, **// handle to key ** LPCTSTR**_ [lpValueName]()_**, **// value name ** LPDWORD**_ [lpReserved]()_**, **// reserved ** LPDWORD**_ [lpType]()_**, **// type buffer ** LPBYTE**_ [lpData]()_**, **// data buffer ** LPDWORD**_ [lpcbData]()_ // size of data buffer **);** 参数 hKey：当前打开的密钥或以下预定义密钥之一的句柄: HKEY_CLASSES_ROOTHKEY_CURRENT_CONFIGHKEY_CURRENT_USERHKEY_LOCAL_MACHINEHKEY_USERSWindows NT/2000/XP: HKEY_PERFORMANCE_DATAWindows XP: HKEY_PERFORMANCE_TEXTHKEY_PERFORMANCE_NLSTEXTWindows 95/98/Me: HKEY_DYN_DATA lpValueName：指向一个以null结尾的字符串的指针，该字符串包含要查询的值的名称。如果lpValueName是NULL或空字符串“”，函数将检索键的未命名或默认值(如果有的话)的类型和数据。 Windows 95/98/Me:每个键都有一个默认值，最初不包含数据。在Windows 95上，默认值类型总是REG_SZ。在Windows 98上，键的默认值的类型最初是REG_SZ，但是RegSetValueEx可以指定具有不同类型的默认值。 Windows NT/2000/XP:键不自动具有未命名或默认值。未命名值可以是任何类型。 lpReserved：保留;必须为NULL。 lpType：指向一个变量的指针，该变量接收指示存储在指定值中的数据类型的代码。有关可能的类型代码的列表，请参见注册表值类型。如果不需要类型代码，则lpType参数可以为NULL。 lpData：指向接收该值数据的缓冲区的指针。如果不需要数据，此参数可以为空。 lpcbData：指向一个变量的指针，该变量指定lpData参数指向的缓冲区的大小(以字节为单位)。当函数返回时，该变量包含复制到lpData的数据的大小。 如果数据具有REG_SZ、REG_MULTI_SZ或REG_EXPAND_SZ类型，那么lpcbData也将包含终止null字符或字符的大小。 只有当lpData为空时，lpcbData参数才可以为NULL。如果lpData参数指定的缓冲区不够大，无法容纳数据，则函数返回值ERROR_MORE_DATA，并将所需的缓冲区大小(以字节为单位)存储到lpcbData指向的变量中。在这种情况下，lpValue缓冲区的内容没有定义。 如果lpData是NULL，并且lpcbData是非NULL，那么函数将返回ERROR_SUCCESS，并在lpcbData指向的变量中存储数据的大小(以字节为单位)。这让应用程序确定为值的数据分配缓冲区的最佳方法。如果hKey指定HKEY_PERFORMANCE_DATA，而lpData缓冲区太小，RegQueryValueEx返回ERROR_MORE_DATA，但是lpcbData不返回所需的缓冲区大小。这是因为性能数据的大小可以从一个调用更改为下一个调用。在这种情况下，您必须增加缓冲区大小并调用RegQueryValueEx，在lpcbData参数中再次传递更新的缓冲区大小。重复此操作，直到函数成功。您需要维护一个单独的变量来跟踪缓冲区大小，因为lpcbData返回的值是不可预测的。 返回值 如果函数成功，返回值为ERROR_SUCCESS。 如果函数失败，返回值是Winerror.h中定义的非零错误代码。您可以使用FormatMessage函数和FORMAT_MESSAGE_FROM_SYSTEM标志来获得错误的通用描述。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;conio.h&gt;#include&lt;windows.h&gt;void main(void)&#123; long lRet; HKEY hKey; TCHAR tchData[64]; DWORD dwSize; lRet=RegOpenKeyEx( HKEY_LOCAL_MACHINE, // handle to open key &quot;Hardware\\Description\\System\\CentralProcessor\\0&quot;, // subkey name 0, // reserved KEY_QUERY_VALUE, // security access mask &amp;hKey // handle to open key ); if(lRet==ERROR_SUCCESS) &#123; dwSize=sizeof(tchData); lRet=RegQueryValueEx( hKey, // handle to key &quot;ProcessorNameString&quot;, // value name NULL, // reserved NULL, // type buffer (LPBYTE)tchData, // data buffer &amp;dwSize // size of data buffer ); if(lRet==ERROR_SUCCESS) &#123; printf(&quot;\n CPU INFO:&quot;); printf(&quot;%s\n&quot;,tchData); &#125; //以下是失败的内容 else &#123; printf(&quot;\nCPU INFO:&quot;); printf(&quot;UNKNOWN\n&quot;); &#125; &#125; //以下是打开失败 else &#123; printf(&quot;\n CPU INFO:&quot;); printf(&quot;UNKNOWN\n&quot;); &#125; RegCloseKey(hKey); getch();&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegOpenKeyEx函数]]></title>
    <url>%2F2018%2F07%2F05%2FRegOpenKeyEx%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[RegOpenKeyEx函数打开指定的注册表项。 1**LONG RegOpenKeyEx( HKEY**_ [hKey]()_**, **// handle to open key ** LPCTSTR**_ [lpSubKey]()_**, **// subkey name **DWORD** _[ulOptions]()_**,** // reserved ** REGSAM**_ [samDesired]()_**, **// security access mask ** PHKEY**_ [phkResult]()_ // handle to open key **);** 参数 hkey：当前打开的密钥或以下预定义密钥之一的句柄 HKEY_CLASSES_ROOTHKEY_CURRENT_CONFIGHKEY_CURRENT_USERHKEY_LOCAL_MACHINEHKEY_USERSWindows NT/2000/XP: HKEY_PERFORMANCE_DATAWindows 95/98/Me: HKEY_DYN_DATA lpSubKey：指向一个空终止字符串的指针，该字符串包含要打开的子键的名称。如果该参数为NULL或指向空字符串的指针，则函数将为由hKey参数标识的键打开一个新句柄。在这种情况下，函数将不会关闭先前打开的句柄。 ulOptions：保留;必须是零。 samDesired：一个访问掩码，它指定对密钥的期望访问权限。这个参数可以是以下值的组合。KEY_CREATE_LINK、KEY_CREATE_SUB_KEY、KEY_ENUMERATE_SUB_KEYS、KEY_EXECUTE、KEY_NOTIFY、KEY_QUERY_VALUE、KEY_SET_VALUE、KEY_ALL_ACCESS、KEY_READ、KEY_WOW64_64KEY、KEY_WOW64_32KEY、KEY_WRITE。 phkResult：指向变量的指针，该变量接收打开的键的句柄。当您不再需要返回的句柄时，请调用RegCloseKey函数来关闭它。 返回值 如果函数成功，返回值为ERROR_SUCCESS。如果函数失败，返回值是Winerror.h中定义的非零错误代码。您可以使用FormatMessage函数和FORMAT_MESSAGE_FROM_SYSTEM标志来获得错误的通用描述。示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;conio.h&gt;#include&lt;windows.h&gt;void main(void)&#123; long lRet; HKEY hKey; TCHAR tchData[64]; DWORD dwSize; lRet=RegOpenKeyEx( HKEY_LOCAL_MACHINE, // handle to open key &quot;Hardware\\Description\\System\\CentralProcessor\\0&quot;, // subkey name 0, // reserved KEY_QUERY_VALUE, // security access mask &amp;hKey // handle to open key ); if(lRet==ERROR_SUCCESS) &#123; dwSize=sizeof(tchData); lRet=RegQueryValueEx( hKey, // handle to key &quot;ProcessorNameString&quot;, // value name NULL, // reserved NULL, // type buffer (LPBYTE)tchData, // data buffer &amp;dwSize // size of data buffer ); if(lRet==ERROR_SUCCESS) &#123; printf(&quot;\n CPU INFO:&quot;); printf(&quot;%s\n&quot;,tchData); &#125; //以下是失败的内容 else &#123; printf(&quot;\nCPU INFO:&quot;); printf(&quot;UNKNOWN\n&quot;); &#125; &#125; //以下是打开失败 else &#123; printf(&quot;\n CPU INFO:&quot;); printf(&quot;UNKNOWN\n&quot;); &#125; RegCloseKey(hKey); getch();&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegSetValueEx函数]]></title>
    <url>%2F2018%2F07%2F05%2FRegSetValueEx%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[RegSetValueEx函数在注册表项下设置指定值的数据和类型。 1**LONG RegSetValueEx( HKEY**_ [hKey]()_**, **// handle to key ** LPCTSTR**_ [lpValueName]()_**, **// value name **DWORD** _[Reserved]()_**,** // reserved ** DWORD**_ [dwType]()_**, **// value type ** CONST BYTE**_ _*****_[lpData]()_**, **// value data ** DWORD**_ [cbData]()_ // size of value data **);** 参数 hkey： 当前打开的密钥或以下预定义密钥之一的句柄: HKEY_CLASSES_ROOTHKEY_CURRENT_CONFIGHKEY_CURRENT_USERHKEY_LOCAL_MACHINEHKEY_USERSWindows NT/2000/XP: HKEY_PERFORMANCE_DATAWindows 95/98/Me: HKEY_DYN_DATA lpValueName：指向一个字符串的指针，该字符串包含要设置的值的名称。如果键中不存在这个名称的值，函数将其添加到键中。如果lpValueName是NULL或空字符串””，函数将为键的未命名或默认值设置类型和数据。 Reserved：保留;必须是零。 dwType：指定由lpData参数指向的数据类型的代码。有关可能类型代码的列表，请参见注册表值类型。 Ipdata：指向一个缓冲区的指针，该缓冲区包含以指定值名存储的数据。对于基于字符串的数据类型，如REG_SZ，字符串必须为空终止。对于REG_MULTI_SZ数据类型，字符串必须以双null结尾。 cbData：指定lpData参数指向的信息的大小(以字节为单位)。如果数据类型为REG_SZ、REG_EXPAND_SZ或REG_MULTI_SZ，则cbData必须包括终止null字符或字符的大小。 返回值 如果函数成功，返回值为ERROR_SUCCESS。如果函数失败，返回值是Winerror.h中定义的非零错误代码。您可以使用FormatMessage函数和FORMAT_MESSAGE_FROM_SYSTEM标志来获得错误的通用描述。示例代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;windows.h&gt;void main(void)&#123; //根键、子键名称和到子键的句柄 HKEY hRoot=HKEY_LOCAL_MACHINE; char *szSubKey=&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;; HKEY hKey;//打开指定子键 DWORD dwDisposition=REG_OPENED_EXISTING_KEY; //如果不存在就创建 LONG lRet=RegCreateKeyEx( hRoot, szSubkey, 0, NULL, REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS, NULL, &amp;hKey, &amp;dwDisposition ); if(lRet!=ERROR_SUCCESS) return; //得到当前执行文件的文件名（包含路径） char szModule[MAX_PATH]; GetModuleFileName(NULL,szModule,MAX_PATH); //创建一个新的键值，设置键值数据为文件 lRet=RegSetValueEx( hKey, &quot;SelfRunDemo&quot;, 0, REG_SZ, (BYTE*)szModule, strlen(szModule) ); if(lRet==ERROR_SUCCESS) printf(&quot;self run success\n&quot;); //关闭子键句柄 RegCloseKey(hKey);]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegCreateKeyEx函数]]></title>
    <url>%2F2018%2F07%2F05%2FRegCreateKeyEx%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[RegCreateKeyEx函数：创建指定的注册表项。如果键已经存在，函数将打开它。 1**LONG RegCreateKeyEx( HKEY**_ [hKey]()_**, **// handle to open key ** LPCTSTR**_ [lpSubKey]()_**, **// subkey name ** DWORD**_ [Reserved]()_**, **// reserved ** LPTSTR**_ [lpClass]()_**, **// class string ** DWORD**_ [dwOptions]()_**, **// special options ** REGSAM**_ [samDesired]()_**, **// desired security access ** LPSECURITY_ATTRIBUTES**_ [lpSecurityAttributes]()_**,** // inheritance ** PHKEY**_ [phkResult]()_**, **// key handle ** LPDWORD**_ [lpdwDisposition]()_ ** ** // disposition value buffer **);** 参数 hkey：当前打开的密钥或以下预定义密钥之一的句柄: HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS Windows NT / 2000 / XP:HKEY_PERFORMANCE_DATA Windows 95/98 / Me:HKEY_DYN_DATA RegCreateKeyEx函数打开或创建的键是由hKey参数标识的键的子键。 lpSubKey：指向空终止字符串的指针，该字符串指定此函数打开或创建的子键的名称。指定的子键必须是由hKey参数标识的键的子键。这个参数不能为空。 Windows NT/2000/XP: lpSubKey指定的子键名不能以反斜杠字符(‘\’)开头。如果是，则返回ERROR_BAD_PATHNAME。 Windows 95/98/Me:忽略lpSubKey指定的子键名称中的开始反斜杠字符。 Reserved：保留;必须是零。 lpClass：指向空终止字符串的指针，该字符串指定此键的类(对象类型)。如果键已经存在，则忽略此参数。目前没有定义类;应用程序应该传递一个空字符串。Windows 95和Windows 98只对远程注册表键使用此参数;对于本地注册表项，它是被忽略的。对于本地和远程注册表键，Windows NT/Windows 2000都支持此参数。 dwOptions ：指定密钥的特殊选项。此参数可以是以下值之一。REG_OPTION_NON_VOLATILE、REG_OPTION_VOLATILE、REG_OPTION_BACKUP_RESTORE。 samDesired ：一个访问掩码，它指定对密钥的期望访问权限。这个参数可以是以下值的组合。KEY_CREATE_LINK、KEY_CREATE_SUB_KEY、KEY_ENUMERATE_SUB_KEYS、KEY_EXECUTE、KEY_NOTIFY、KEY_QUERY_VALUE、KEY_SET_VALUE、KEY_ALL_ACCESS、KEY_READ、KEY_WOW64_64KEY、KEY_WOW64_32KEY、KEY_WRITE。 lpSecurityAttributes ：一个SECURITY_ATTRIBUTES结构的指针，该结构确定返回的句柄是否可以被子进程继承。如果lpSecurityAttributes为NULL，则不能继承该句柄。 Windows NT/2000/XP:结构的lpSecurityDescriptor成员为新密钥指定了安全描述符。如果lpSecurityAttributes为空，则该键获得一个默认的安全描述符。phkResult ：指向一个变量的指针，该变量接收以下配置值之一。REG_CREATED_NEW_KEY、REG_OPENED_EXISTING_KEY， 返回值 如果函数成功，返回值为ERROR_SUCCESS。 如果函数失败，返回值是Winerror.h中定义的非零错误代码。您可以使用FormatMessage函数和FORMAT_MESSAGE_FROM_SYSTEM标志来获得错误的通用描述。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;aclapi.h&gt;void main(int argc, char *argv[]) &#123;DWORD dwRes, dwDisposition;PSID pEveryoneSID = NULL, pAdminSID = NULL;PACL pACL = NULL;PSECURITY_DESCRIPTOR pSD = NULL;EXPLICIT_ACCESS ea[2];SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;SECURITY_ATTRIBUTES sa;LONG lRes;HKEY hkSub = NULL;// Create a well-known SID for the Everyone group.if(! AllocateAndInitializeSid( &amp;SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &amp;pEveryoneSID) ) &#123; printf( &quot;AllocateAndInitializeSid Error %u\n&quot;, GetLastError() ); return;&#125;// Initialize an EXPLICIT_ACCESS structure for an ACE.// The ACE will allow Everyone read access to the key.ZeroMemory(&amp;ea, 2 * sizeof(EXPLICIT_ACCESS));ea[0].grfAccessPermissions = KEY_READ;ea[0].grfAccessMode = SET_ACCESS;ea[0].grfInheritance= NO_INHERITANCE;ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;ea[0].Trustee.ptstrName = (LPTSTR) pEveryoneSID;// Create a SID for the BUILTIN\Administrators group.if(! AllocateAndInitializeSid( &amp;SIDAuthNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &amp;pAdminSID) ) &#123; printf( &quot;AllocateAndInitializeSid Error %u\n&quot;, GetLastError() ); goto Cleanup; &#125;// Initialize an EXPLICIT_ACCESS structure for an ACE.// The ACE will allow the Administrators group full access to the key.ea[1].grfAccessPermissions = KEY_ALL_ACCESS;ea[1].grfAccessMode = SET_ACCESS;ea[1].grfInheritance= NO_INHERITANCE;ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;ea[1].Trustee.ptstrName = (LPTSTR) pAdminSID;// Create a new ACL that contains the new ACEs.dwRes = SetEntriesInAcl(2, ea, NULL, &amp;pACL);if (ERROR_SUCCESS != dwRes) &#123; printf( &quot;SetEntriesInAcl Error %u\n&quot;, GetLastError() ); goto Cleanup;&#125;// Initialize a security descriptor. pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH); if (pSD == NULL) &#123; printf( &quot;LocalAlloc Error %u\n&quot;, GetLastError() ); goto Cleanup; &#125; if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) &#123; printf( &quot;InitializeSecurityDescriptor Error %u\n&quot;, GetLastError() ); goto Cleanup; &#125; // Add the ACL to the security descriptor. if (!SetSecurityDescriptorDacl(pSD, TRUE, // fDaclPresent flag pACL, FALSE)) // not a default DACL &#123; printf( &quot;SetSecurityDescriptorDacl Error %u\n&quot;, GetLastError() ); goto Cleanup; &#125; // Initialize a security attributes structure.sa.nLength = sizeof (SECURITY_ATTRIBUTES);sa.lpSecurityDescriptor = pSD;sa.bInheritHandle = FALSE;// Use the security attributes to set the security descriptor // when you create a key. lRes = RegCreateKeyEx(HKEY_CURRENT_USER, &quot;mykey&quot;, 0, &quot;&quot;, 0, KEY_READ | KEY_WRITE, &amp;sa, &amp;hkSub, &amp;dwDisposition); printf( &quot;RegCreateKeyEx result %u\n&quot;, lRes );Cleanup: if (pEveryoneSID) FreeSid(pEveryoneSID); if (pAdminSID) FreeSid(pAdminSID); if (pACL) LocalFree(pACL); if (pSD) LocalFree(pSD); if (hkSub) RegCloseKey(hkSub); return;&#125;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegConnectRegistry函数]]></title>
    <url>%2F2018%2F07%2F05%2FRegConnectRegistry%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[RegConnectRegistry函数在另一台计算机上建立到预定义注册表键的连接。 1**LONG RegConnectRegistry( LPCTSTR**_ [lpMachineName]()_**, **// 计算机名称 ** HKEY**_ [hKey]()_**, **// 预定义的注册表处理 ** PHKEY**_ [phkResult]()_ // 用于远程关键句柄的缓冲区。 **);** 参数 lpMachineName：指向指定远程计算机名称的空终止字符串的指针。如果该参数为空，则使用本地计算机名。 hkey：指定远程计算机上的下列预定义键之一。 HKEY_LOCAL_MACHINE HKEY_USERS Windows NT / 2000 / XP:HKEY_PERFORMANCE_DATA Windows 95/98 / Me:HKEY_DYN_DATA Windows 95/98 / Me:HKEY_CURRENT_CONFIG 不能为该参数指定HKEY_CLASSES_ROOT或HKEY_CURRENT_USER值。 phkResult：指向一个变量的指针，该变量接收一个关键句柄，用于识别远程计算机上的预定义句柄。返回值 如果函数成功，返回值为ERROR_SUCCESS。如果函数失败，返回值是Winerror.h中定义的非零错误代码。可以使用FormatMessage函数和FORMAT_MESSAGE_FROM_SYSTEM标志来获得错误的通用描述。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegCloseKey函数]]></title>
    <url>%2F2018%2F07%2F05%2FRegCloseKey%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[RegCloseKey函数是释放一个对指定注册表项的句柄。 123LONG RegCloseKey( HKEY hKey // 处理键关闭。); #### Parameters hKey 对打开键的句柄关闭。 返回值 如果函数成功，返回值为ERROR_SUCCESS。如果函数失败，返回值是Winerror.h中定义的非零错误代码。您可以使用FormatMessage函数和FORMAT_MESSAGE_FROM_SYSTEM标志来获得错误的通用描述。例子代码 1#define RTN_UNKNOWN 0 #define RTN_SERVER 1 #define RTN_WORKSTATION 2 #define RTN_NTAS 3 #define RTN_ERROR 13 DWORD GetWindowsVariant(void) &#123; #define MY_BUFSIZE 32 // Arbitrary initial value. // Dynamic allocation will be used. HKEY hKey; TCHAR szProductType[MY_BUFSIZE]; DWORD dwBufLen = MY_BUFSIZE; LONG lRet; if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT(&quot;SYSTEM\\CurrentControlSet\\Control\\ProductOptions&quot;), 0, KEY_QUERY_VALUE, &amp;hKey) != ERROR_SUCCESS) return RTN_ERROR; lRet = RegQueryValueEx(hKey, TEXT(&quot;ProductType&quot;), NULL, NULL, (LPBYTE)szProductType, &amp;dwBufLen); RegCloseKey(hKey); if(lRet != ERROR_SUCCESS) return RTN_ERROR; // check product options, in order of likelihood if(lstrcmpi(TEXT(&quot;WINNT&quot;), szProductType) == 0) return RTN_WORKSTATION; if(lstrcmpi(TEXT(&quot;SERVERNT&quot;), szProductType) == 0) return RTN_SERVER; if(lstrcmpi(TEXT(&quot;LANMANNT&quot;), szProductType) == 0) return RTN_NTAS; // else return &quot;unknown variant&quot; code else return RTN_UNKNOWN; &#125;** **]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSASocket函数未定义和重定义错误]]></title>
    <url>%2F2018%2F07%2F03%2FWSASocket%E5%87%BD%E6%95%B0%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%92%8C%E9%87%8D%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[报错error C2065: ‘WSASocket’ : undeclared identifier 意思是WSASocket函数没有声明定义 WSASocket()是：创建一个与指定传送服务提供者捆绑的套接口，可选地创建和/或加入一个套接口组。 此函数为socket（）的扩展版本，其功能都是创建一个原始套接字。使用时需要包含 winsock2.h 头文件和链接ws2_32.lib库。 刚开始我的情况是再cpp文件中包含了windows.h的头文件，也链接了ws2_32.lib库，然后出现没有定义的错误，后来我通过百度查到其需要包含winsock2.h的头文件然后我再windows.h后面又包含了winsock2.h的头文件，但是出现的报错就更多了，报错如下： c:\program files\microsoft visual studio\vc98\include\winsock2.h(99) : error C2011: ‘fd_set’ : ‘struct’ type redefinition c:\program files\microsoft visual studio\vc98\include\winsock2.h(134) : warning C4005: ‘FD_SET’ : macro redefinition c:\program files\microsoft visual studio\vc98\include\winsock.h(84) : see previous definition of ‘FD_SET’ 。。。。。。。。（还有好多） 然后我将winsock2.h的头文件删了，又到百度找答案，然后查到一篇博文说他误打误撞在winsock.h的头文件中包含stdafx.h头文件，我也试了一下，但是还是不行，可能是我的文件不同吧，因为编译之后我说stdafx.h没有定义，我找一下放头文件的文件夹是没有这个文件，我不至于这样就到网上找找一个包含进去吧，然后我打开我引入的头文件windows.h看了一下，里面包含了winsock.h，然后我到MSDN Library 找才知道winsock2.h是winsock.h的升级版，不能放在一起用，所以我就将winsock2.和定义到windows.h文件的前面，然后就可以了。 最后我打开winsock2.h和winsock.h两个文件，发现他们的宏定义是这样的 winsock2.h中定义了winsock.h的宏，说明如果先引入了winsock2.h同文件再引入winsock.h头文件，编译器是不会去编译winsock.h头文件的，如果倒过来就不同，并且会出现很多错误，是因为winsock.h和winsock2.h存在很多相同的定义或者其它。其实在winsock2.h文件中就能找到答案，下图“阻止包含windows.h中的winsock.h”。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海明校验码]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E7%A0%81%2F</url>
    <content type="text"><![CDATA[基本思想：将有效信息位按某种规律分成若干组，每组安排一个校验位进行奇偶测试。在一个数据位组中加入几个校验位，增大数据代码间的码距，当某一位发生变化时会引起校验结果发生变化，不同代码微商的凑无会得到不同的校验结果。 校验码的位数：设位数为N位，其中有效信息为k位，校验位为r位，分成r组奇偶校验，能产生r位验错信息，这r位信息就构成了一个二进制数的指误字，能指出2∧r-1位错误。所以N=k+r&lt;=2∧r-1 有效信息分组规律：若海明校验码有m位，最高为第m位，最低为第1位，即H[m]、H[m-1]… … H[2]、H[1],其中中括号里面的数为位号数，位号数等于2的次方的那些位（即1（2^0）、2(2^1)、4(2^2)、… …2^(r-1)位），作为奇偶校验位，并记为P1、P2……Pr，余下的位则为有效信息位。校验位与有效信息位之和为m。 每一位海明码由某些校验位所校验：即第i位由校验位位号之和等于i的那些校验位所校验。如下表： 海明校验 占用校 备注码位号 验位号1 1 1=12 2 2=23 1，2 3=1+24 4 4=45 1，4 5=1+46 2，4 6=2+47 1，2，4 7=1+2+4 海明码的编码、查找、纠错原理： 设有4位有效信息b1、b2、b3、b4和3位校验码P1、P2、P3 海明校验 码序号 1 2 3 4 5 6 7 出错位 含义 P1 P2 b1 P2 b2 b3 b4 指误字 无错误 1 2 3 4 5 6 7 第一组 G1 0 1 0 1 0 1 0 1 第二组 G2 0 0 1 1 0 0 1 1 第三组 G3 0 0 0 0 1 1 1 1 编码原理 ： 若有效信息b1、b2、b3、b4=1011，则先将它分别填入第3、5、6、7位，再分组进行奇偶统计，分别将值填入校验位P1、P2、P3。这里分组采用偶校验，因此要确保三组校验位的取值都满足偶校验规则。例如第一组有P1b1b2b4，已含有偶数个1，因此P1应为0，以确保第一组为偶性。由此可得P1 P2 b1 P2 b2 b3 b4=0110011。 差错和纠错原理 ：计算G1=P1⊕b1⊕b2⊕b4;G2=P2⊕b1⊕b3⊕b4;G3=P2⊕b2⊕b3⊕b4;得到的G1G2G3的值就是出错位的二进制码序号，如G1G2G2=001，说明出错位的码序号是1。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word纠错设置]]></title>
    <url>%2F2018%2F06%2F21%2Fword%E7%BA%A0%E9%94%99%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置windows10 的默认应用]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%AE%BE%E7%BD%AEwindows10%20%E7%9A%84%E9%BB%98%E8%AE%A4%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[先按win键]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window10设置文件的默认打开方式]]></title>
    <url>%2F2018%2F06%2F21%2Fwindow10%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[//以下是设置图片管理器的默认文件打开方式 左键点击“保存”然后退出。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置windows10相应文件格式的打开方式]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%AE%BE%E7%BD%AEwindows10%E7%9B%B8%E5%BA%94%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[上一篇我们讲到了卸载自带软件的方法，其原因就是打开方式不能根据自己想要的方式打开。而这里正是解决这个问题的更加符合要求的方式。 设置某格式打开方式是如下： //该经验是设置将图片管理器设置可以打开.gif后缀文件，其它文件格式可以依次类推 首先我们按win+r键打开运行窗口如下： 然后我们打开注册表编辑器，在运行窗口中输入regedit点击确认，具体操作如上图 找到目录 计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsPhoto Viewer\Capabilities\FileAssociations 如下： 将新值设置为.gif后在右键点击文件然后左键点击“_修改_” 然后退出注册表，再右键.gif后缀的文件选择打开方式就会有图片管理器选项了。 附：如果你想要使用Windows照片查看器查看.png后缀的文件，那么数值名称写为.png，数值数据还是为PhotoViewer.FileAssoc.Tiff。换句话说，只要你想更改任何格式的图片文件打开方式，那么数值名称就是.格式名称，数值数据一直为PhotoViewer.FileAssoc.Tiff。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows10卸载自带软件的方法]]></title>
    <url>%2F2018%2F06%2F21%2Fwindows10%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大部分手机用户可能因为手机自带软件对我们没有用想卸载，但是手机在没有刷机的情况下是不能卸载的。而电脑不同，但是我们想卸载的原因可能和我们想卸载手机软件是不同的，就比如说我，我当时是因为电脑自带软件打开太慢，而当时又想用自己设置的软件默认打开，但是window10的设置我设置了多次都没有用，所以就产生了想卸载它的想法。 卸载自带软件的步骤如下： 首先我们按window键然后在所有程序列表中找到Windows powershell文件夹打开，找到第一个Windows power shell程序，右键以管理员运行，如下图 运行结果如下 比如我们要卸载3d画图软件我们在命令行输入 Get-AppxPackage Paint3D |Remove-AppxPackage 其它的自带软件卸载命令如下： OneNote： Get-AppxPackageOneNote | Remove-AppxPackage 3D： Get-AppxPackage3d | Remove-AppxPackage Camera相机： Get-AppxPackagecamera | Remove-AppxPackage 邮件和日历： Get-AppxPackagecommuni | Remove-AppxPackage 新闻订阅： Get-AppxPackagebing | Remove-AppxPackage Groove音乐、电影与电视： Get-AppxPackagezune | Remove-AppxPackage 人脉： Get-AppxPackagepeople | Remove-AppxPackage 手机伴侣（Phone Companion）： Get-AppxPackagephone | Remove-AppxPackage 照片： Get-AppxPackagephoto | Remove-AppxPackage 纸牌游戏： Get-AppxPackagesolit | Remove-AppxPackage 录音机： Get-AppxPackagesoundrec | Remove-AppxPackage Xbox： Get-AppxPackagexbox | Remove-AppxPackage]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu与windows10双系统安装]]></title>
    <url>%2F2018%2F06%2F20%2Fubuntu%E4%B8%8Ewindows10%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[第一步将ubuntu写入u盘 安装ultralso软件，选择继续使用软件（安装系统只要制作一次，没有必要买） 进入软件界面，再上面的菜单栏中选择，文件-&gt;打开 进入如下界面，然后进入你要写入u盘的ios文件所在的文件夹 选择你要写入的ios文件然后点击打开 再点击菜单栏的启动选项-&gt;写入硬盘映像 在磁盘驱动器中选择你要写入ios文件的U盘（如果不要找打开我的电脑，查看u盘的盘符）在写入方式中选择usb-hdd+ 然后点击便捷启动-&gt;写入新硬盘主引导纪录(MBR)-&gt;usb-hdd+ 弹出提示窗口，选择是，再弹出提示窗口，选择确认 再在出现的提示窗口选择是。 进入如下界面，等待一段时间。 刻录完成点击返回。 第二步安装系统 u盘插到电脑上重启电脑 //进入bios会根据电脑牌子的不同有不同的进入方式，可以百度。一般是f10或者f2，笔记本的话有fn键就fn+f10或fn+f2，以前我笔记本老是进不去我直接戳复位键进入的。 进入u盘的bios系统，设置电脑的第一启动项为u盘，再重启电脑进入u盘系统如下图 点击桌面的install 然后出现语言选择，找到汉语，点击下一步（continue） 再选择键盘布局，选择汉语或者English都可以 也可以选择下面的测试键盘来测试你的键盘 然后选择继续，接下来真正进入安装系统的重要设置了 如果不是安装双系统可以不要更改，如果是安装双系统就按照上图选择 点击继续 这是分区设置界面，给系统设置分区系统结构，选自空闲，然后点击+号会出现如下弹窗 一般的用户没有对系统有过高要求的可以按照我的方式设置分区 我的是设置一个/分区15G，/swap分区1.5G，/boot分区500m，/home分区把剩下的都分给它；其它都是默认选项，然后ok。在选择主分区和逻辑分区的时候我百度了一下，然后我选择了逻辑分区。分区格式是ext4。设置好分区后就可以点击选在安装了 写后感，其实以前就有装过很多次双系统的经历，而且以前在安装双系统的时候由于不是ubuntu系统还会遇到很多的安装问题，而且英文界面看不同，但是其实是大同小异的，先是制作U盘然后再安装系统，安装系统的时候做一些语言时间用户地点的简单设置，还有磁盘分区设置网络设置的一些稍微复杂一点的设置等。以前映像比较深刻的一次是centos在选择分区的时候，它不像ubuntu那样有图形界面的选择，他是通过命令行设置，而且是英文界面又看不懂，如果遇到那样的问题网上也是能找到的设置方法的。其实不能忘记的是安装windows10和centos7双系统的时候，真的是把我的意志给消磨尽了，它不仅出现了各种各样的问题卡住安装的进程，而且在安装成功后居然不能找到window10的引导了，导致安装完成后只能进入centos7系统，如果遇到这种情况也不要急，因为windows中的所有文件是没有丢失的，只要centos7系统文件格式化就可以了。但是后来我在网上找类似的经验的时候，看到一些成功的例子，虽然后来我去测试过那些解决办法，但是最后我还是没有测试成功，因为在安装的时候我又遇到了好多问题让我难以前进。这一次我写这个也有一些是因为它的失败吧。把失败或者成功的经历写下来，以后看到就能更加清晰的回忆起来当时的教训与体会。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘使用率达到100%]]></title>
    <url>%2F2018%2F06%2F19%2F%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BE%BE%E5%88%B0100%25%2F</url>
    <content type="text"><![CDATA[磁盘使用率达到100%问题描述：电脑开机后电脑磁盘使用率100%且居高不下，通过在网上搜索办法，关闭服务家庭组、superfetch服务没有多大效果，开始关掉super fetch后发现有了效果，后来打开电脑后又出现了。我开始以为是电脑自启了服务然后我又点开设置发现关闭的服务没有启用，所以不是服务的问题。解决办法：我再次去网上搜索后有一条贴说它将分区太多的分区删除后发现问题解决了，然后将注意了转移到磁盘文件调用这一块来，我回忆一下好像自从我将一些文件安装在e盘之后电脑就开始出现运行不顺畅的情况，然后我就开始找删以前安装在e盘的软件，在删的同时我打开任务管理器发现删到最后一个在外分区的软件的时候还是没有降下来，我看了一下使用磁盘的服务和软件后发现有一款叫Tiwork的程序占用占用非常大，然后我又在网上搜索这款软件，发现这款软件是在电脑装其他软件和卸载其他软件的时候才会出现，所以我就等到电脑卸载最后的软件的时候再打开任务管理器的，这个是时候磁盘占用也已经降到20%一下。因此这个问题才真正圆满解决。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse编辑的代码在dos下运行的问题]]></title>
    <url>%2F2018%2F06%2F10%2Feclipse%E7%BC%96%E8%BE%91%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9C%A8dos%E4%B8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[dos下也不能编译eclipse以前编辑的文件。因为eclipse文件里面有package**语句。 如果非要在dos下编译那就需要将程序里面的package语句注释掉，在前面加两条反斜杠\package 另外在eclipse下编译出来的.class文件，就我的的编译器而言是不可以的，可能是jdk不同的问题，具体我也不清楚，以后有时间再研究。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse的@override报错问题]]></title>
    <url>%2F2018%2F05%2F27%2Feclipse%E7%9A%84%40override%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[要解决报错就要知道报错的原因。 在继承java父类的时候我们通过自动生成的时候会给我们自动加上@override。 @Override是Java5的元数据，自动加上去的一个标志，告诉你说下面这个方法是从父类/接口 继承过来的，需要你重写一次，这样就可以方便你阅读，也不怕会忘记 @Override是伪代码,表示重写(当然不写也可以),不过写上有如下好处: 1&gt;可以当注释用,方便阅读 2&gt;编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错 比如你如果没写@Override而你下面的方法名又写错了,这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法) 使用该标记是为了增强程序在编译时候的检查，如果该方法并不是一个覆盖父类的方法，在编译时编译器就会报告错误。 在父类生成这个的时候报错我将“@override”删去就就可以了。但是当实现接口的时候，发现删掉还是会报错会报错。 把@override不能从根本上解决问题这是jdk的问题，@Override是JDK5就已经有了，但是不支持对接口的实现，认为这不是Override而报错。JDK6修正了这个Bug，无论是对父类的方法覆盖还是对接口的实现都可以加上@Override。 要解决该问题，首先要确保机器上安装了jdk 1.6， 然后，选择eclipse菜单Windows-&gt;Preferences–&gt;java-&gt;Compiler–&gt;compiler compliance level选择 1.6，刷新工程，重新编译。 如果问题还没解决，就在报错的工程上，鼠标右键选择 Properties–&gt;Java Compiler–&gt;compiler compliance level 中选择 1.6,刷新工程，重新编译。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的宽度]]></title>
    <url>%2F2017%2F08%2F07%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[二叉树的宽度就是每一层的宽度的最大值 要求二叉树的宽度，不许先求出每一层的宽度，求每一层的宽度必须知道每一层的元素 作为初学的我，看到树本来就是从括号表示来的，所以我在这里借助里开始时候的树的括号表示的字符串，对每一个元素都在字符串中查找并进进行括号匹配返回留下有括号的个数就是树的节点的层次。 其实，我的最外面的一层循环就是层次查找，所以每一次都是将同一层的元素放在一块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 int WidthBT(BTNode *b,char str[])&#123; BTNode *St[MaxSize],*p; int front,rear,tier,tier1=0; int s=1,max=0; char ch; front=rear=-1; if(b!=NULL) &#123; rear++; St[rear]=b; while(front!=rear) &#123; p=St[front]; ch=str[0]; int j=0; char ch1[MaxSize]; int top=-1; front=(front+1)%MaxSize; tier=0; while(str[j]!=p-&gt;date) &#123; if(str[j]==&apos;(&apos;) ch1[++top]=&apos;(&apos;; else if(str[j]==&apos;)&apos;) top--; j++; &#125; tier=top+1; if(tier1==tier) s++; else &#123; max=s&gt;max?s:max; s=1; &#125; tier1=tier; if(p-&gt;lchild!=NULL) &#123; rear=(rear+1)%MaxSize; St[rear]=p-&gt;lchild; &#125; if(p-&gt;rchild!=NULL) &#123; rear=(rear+1)%MaxSize; St[rear]=p-&gt;rchild; &#125; &#125; &#125; return max;&#125; 初学数据结构，不太懂，希望看到的大神能够多多指教。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言字符串处理函数]]></title>
    <url>%2F2017%2F07%2F27%2Fc%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数名: strcpy 功 能: 拷贝一个字符串到另一个 用 法: char stpcpy(char destin, char *source); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string[10]; char *str1 = “abcdefghi”; stpcpy(string, str1); printf(“%sn”, string); return 0; } 函数名: strcat 功 能: 字符串拼接函数 用 法: char strcat(char destin, char *source); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char destination[25]; char blank = “ “, c = “C++”, *Borland = “Borland”; strcpy(destination, Borland); strcat(destination, blank); strcat(destination, c); printf(“%sn”, destination); return 0; } 函数名: strchr 功 能: 在一个串中查找给定字符的第一个匹配之处 用 法: char strchr(char str, char c); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char string[15]; char *ptr, c = ‘r’; strcpy(string, “This is a string”); ptr = strchr(string, c); if (ptr) printf(“The character %c is at position: %dn”, c, ptr-string); else printf(“The character was not foundn”); return 0; } 函数名: strcmp 功 能: 串比较 用 法: int strcmp(char str1, char str2); 看Asic码，str1&gt;str2，返回值 &gt; 0；两串相等，返回0 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “aaa”, buf2 = “bbb”, *buf3 = “ccc”; int ptr; ptr = strcmp(buf2, buf1); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); else printf(“buffer 2 is less than buffer 1n”); ptr = strcmp(buf2, buf3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 3n”); else printf(“buffer 2 is less than buffer 3n”); return 0; } 函数名: strncmpi 功 能: 将一个串中的一部分与另一个串比较, 不管大小写 用 法: int strncmpi(char str1, char str2, unsigned maxlen); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBB”, buf2 = “bbb”; int ptr; ptr = strcmpi(buf2, buf1); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strcpy 功 能: 串拷贝 用 法: char strcpy(char str1, char *str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string[10]; char *str1 = “abcdefghi”; strcpy(string, str1); printf(“%sn”, string); return 0; } 函数名: strcspn 功 能: 在串中查找第一个给定字符集内容的段 用 法: int strcspn(char str1, char str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;alloc.h&gt; int main(void) { char string1 = “1234567890”; char string2 = “747DC8”; int length; length = strcspn(string1, string2); printf(“Character where strings intersect is at position %dn”, length); return 0; } 函数名: strdup 功 能: 将串拷贝到新建的位置处 用 法: char strdup(char str); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;alloc.h&gt; int main(void) { char dup_str, string = “abcde”; dup_str = strdup(string); printf(“%sn”, dup_str); free(dup_str); return 0; } 函数名: strcmp 功 能: 比较字符串str1和str2。 用 法: int strcmp(char str1, char str2); 说 明: 当s1&lt;s2时，返回值s2时，返回值&gt;0 即：两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇’\0’为止。 程序例: #include&lt;stdio.h&gt; #include&lt;string.h&gt; void main() { char string[20]; char str[3][20]; int i; for(i=0;i&lt;3;i++) gets(str[i]); if(strcmp(str[0],str[1])&gt;0) strcpy(string,str[0]); else strcpy(string,str[1]); if(strcmp(str[2],string)&gt;0) strcpy(string,str[2]); printf(“\nThe largest string is %s\n”,string); } 函数名: stricmp 功 能: 以大小写不敏感方式比较两个串 用 法: int stricmp(char str1, char str2); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBB”, buf2 = “bbb”; int ptr; ptr = stricmp(buf2, buf1); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strerror 功 能: 返回指向错误信息字符串的指针 用 法: char *strerror(int errnum); 程序例: #include &lt;stdio.h&gt; #include &lt;errno.h&gt; int main(void) { char *buffer; buffer = strerror(errno); printf(“Error: %sn”, buffer); return 0; } 函数名: strcmpi 功 能: 将一个串与另一个比较, 不管大小写 用 法: int strcmpi(char str1, char str2); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBB”, buf2 = “bbb”; int ptr; ptr = strcmpi(buf2, buf1); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strncmp 功 能: 串比较 用 法: int strncmp(char str1, char str2, int maxlen); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “aaabbb”, buf2 = “bbbccc”, *buf3 = “ccc”; int ptr; ptr = strncmp(buf2,buf1,3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); else printf(“buffer 2 is less than buffer 1n”); ptr = strncmp(buf2,buf3,3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 3n”); else printf(“buffer 2 is less than buffer 3n”); return(0); } 函数名: strncmpi 功 能: 把串中的一部分与另一串中的一部分比较, 不管大小写 用 法: int strncmpi(char str1, char str2); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBBccc”, buf2 = “bbbccc”; int ptr; ptr = strncmpi(buf2,buf1,3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strncpy 功 能: 串拷贝 用 法: char strncpy(char destin, char *source, int maxlen); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string[10]; char *str1 = “abcdefghi”; strncpy(string, str1, 3); string[3] = ‘’; printf(“%sn”, string); return 0; } 函数名: strnicmp 功 能: 不注重大小写地比较两个串 用 法: int strnicmp(char str1, char str2, unsigned maxlen); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char buf1 = “BBBccc”, buf2 = “bbbccc”; int ptr; ptr = strnicmp(buf2, buf1, 3); if (ptr &gt; 0) printf(“buffer 2 is greater than buffer 1n”); if (ptr &lt; 0) printf(“buffer 2 is less than buffer 1n”); if (ptr == 0) printf(“buffer 2 equals buffer 1n”); return 0; } 函数名: strnset 功 能: 将一个串中的所有字符都设为指定字符 用 法: char strnset(char str, char ch, unsigned n); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char *string = “abcdefghijklmnopqrstuvwxyz”; char letter = ‘x’; printf(“string before strnset: %sn”, string); strnset(string, letter, 13); printf(“string after strnset: %sn”, string); return 0; } 函数名: strpbrk 功 能: 在串中查找给定字符集中的字符 用 法: char strpbrk(char str1, char *str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string1 = “abcdefghijklmnopqrstuvwxyz”; char string2 = “onm”; char ptr; ptr = strpbrk(string1, string2); if (ptr) printf(“strpbrk found first character: %cn”, ptr); else printf(“strpbrk didn’t find character in setn”); return 0; } 函数名: strrchr 功 能: 在串中查找指定字符的最后一个出现 用 法: char strrchr(char str, char c); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char string[15]; char *ptr, c = ‘r’; strcpy(string, “This is a string”); ptr = strrchr(string, c); if (ptr) printf(“The character %c is at position: %dn”, c, ptr-string); else printf(“The character was not foundn”); return 0; } 函数名: strrev 功 能: 串倒转 用 法: char strrev(char str); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char *forward = “string”; printf(“Before strrev(): %sn”, forward); strrev(forward); printf(“After strrev(): %sn”, forward); return 0; } 函数名: strset 功 能: 将一个串中的所有字符都设为指定字符 用 法: char strset(char str, char c); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string[10] = “123456789”; char symbol = ‘c’; printf(“Before strset(): %sn”, string); strset(string, symbol); printf(“After strset(): %sn”, string); return 0; } 函数名: strspn 功 能: 在串中查找指定字符集的子集的第一次出现 用 法: int strspn(char str1, char str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;alloc.h&gt; int main(void) { char string1 = “1234567890”; char string2 = “123DC8”; int length; length = strspn(string1, string2); printf(“Character where strings differ is at position %dn”, length); return 0; } 函数名: strstr 功 能: 在串中查找指定字符串的第一次出现 用 法: char strstr(char str1, char *str2); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char str1 = “Borland International”, str2 = “nation”, *ptr; ptr = strstr(str1, str2); printf(“The substring is: %sn”, ptr); return 0; } 函数名: strtod 功 能: 将字符串转换为double型值 用 法: double strtod(char *str, char **endptr); 程序例: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { char input[80], *endptr; double value; printf(“Enter a floating point number:”); gets(input); value = strtod(input, &amp;endptr); printf(“The string is %s the number is %lfn”, input, value); return 0; } 函数名: strsep 功 能: 分解字符串为一组字符串。从str1指向的位置起向后扫描，遇到delim指向位置的字符后，将此字符替换为NULL，返回str1指向的地址。 用 法: char strtok(char **str1, const char delim); 程序例: int main() { int len, nel; char query[] =”user_command=appleboy&amp;test=1&amp;test2=2”; char q, name, value; / Parse into individualassignments / q = query; fprintf(stderr, “CGI[query string] : %s\n”,query); len = strlen(query); nel = 1; while (strsep(&amp;q, “&amp;”)) nel++; fprintf(stderr, “CGI[nel string] : %d\n”, nel); for (q = query; q&lt; (query + len);) { value = name = q; / Skip to next assignment / fprintf(stderr, “CGI[string] :%s\n”, q); fprintf(stderr, “CGI[stringlen] : %d\n”, strlen(q)); fprintf(stderr, “CGI[address] :%x\n”, q); for (q += strlen(q); q &lt; (query +len) &amp;&amp; !q; q++); / Assign variable / name = strsep(&amp;value,”=”); fprintf(stderr, “CGI[name ] :%s\n”, name); fprintf(stderr, “CGI[value] :%s\n”, value); } return 0; } 函数名: strtok 功 能: 查找由在第二个串中指定的分界符分隔开的单词 用 法: char strtok(char str1, char *str2); 程序例: #include &lt;string.h&gt; #include &lt;stdio.h&gt; int main(void) { char input[16] = “abc,d”; char p; / strtok places a NULL terminator in front of the token, if found / p = strtok(input, “,”); if (p) printf(“%sn”, p); / A second call to strtok using a NULL as the first parameter returns a pointer to the character following the token */ p = strtok(NULL, “,”); if (p) printf(“%sn”, p); return 0; } 函数名: strtol 功 能: 将串转换为长整数 用 法: long strtol(char *str, char **endptr, int base); 程序例: #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(void) { char string = “87654321”, endptr; long lnumber; / strtol converts string to long integer / lnumber = strtol(string, &amp;endptr, 10); printf(“string = %s long = %ldn”, string, lnumber); return 0; } 函数名: strupr 功 能: 将串中的小写字母转换为大写字母 用 法: char strupr(char str); 程序例: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char string = “abcdefghijklmnopqrstuvwxyz”, ptr; / converts string to upper case characters / ptr = strupr(string); printf(“%sn”, ptr); return 0; } 函数名: swab 功 能: 交换字节 用 法: void swab (char from, char to, int nbytes); 程序例: #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; char source[15] = “rFna koBlrna d”; char target[15]; int main(void) { swab(source, target, strlen(source)); printf(“This is target: %sn”, target); return 0; } PS:isalpha()是字符函数，不是字符串函数， isalpha 原型：extern int isalpha(int c); 用法：#include &lt;ctype.h&gt; 功能：判断字符c是否为英文字母 说明：当c为英文字母a-z或A-Z时，返回非零值，否则返回零。 举例： // isalpha.c #include &lt;syslib.h&gt; #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; main() { int c; clrscr(); // clear screen printf(“Press a key”); for(;;) { c=getchar(); clrscr(); printf(“%c: %s letter”,c,isalpha(c)?”is”:”not”); } return 0; // just to avoid warnings by compiler }]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
</search>
